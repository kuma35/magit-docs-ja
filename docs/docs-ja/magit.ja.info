This is magit.ja.info, produced by .texi2any-real version 7.0.3 from
magit.ja.texi.

     Copyright (C) 2015-2022 Jonas Bernoulli <jonas@bernoul.li>

     You can redistribute this document and/or modify it under the terms
     of the GNU General Public License as published by the Free Software
     Foundation, either version 3 of the License, or (at your option)
     any later version.

     This document is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     General Public License for more details.

INFO-DIR-SECTION Magit文書翻訳
START-INFO-DIR-ENTRY
* Magit(ja): (magit.ja).     MagitでEmacsのGitを使用する。
END-INFO-DIR-ENTRY


File: magit.ja.info,  Node: Top,  Next: Introduction,  Up: (dir)

Magit User Manual
*****************

Magitは、バージョン管理システムGitへのインターフェースであり、Emacsパッ
ケージとして実装されています。Magitは完全なGit磁器を目指しています。
MagitがすべてのGitコマンドをラップして改善するとは(まだ)主張できませんが
、経験豊富なGitユーザーでさえEmacs内から直接毎日のバージョン管理タスクの
ほとんどすべてを実行できるほど十分に完全です。多くの優れたGitクライアン
トが存在しますが、磁器と呼ばれるのはMagitとGit自体だけです。(訳注:低レベ
ルのを配管(plumbing)コマンド、よりユーザーフレンドリーなのを磁器
(porcelain)コマンドと称する)

This manual is for Magit version 3.3.0-git.

     Copyright (C) 2015-2022 Jonas Bernoulli <jonas@bernoul.li>

     You can redistribute this document and/or modify it under the terms
     of the GNU General Public License as published by the Free Software
     Foundation, either version 3 of the License, or (at your option)
     any later version.

     This document is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     General Public License for more details.

* Menu:

* Introduction::             Introduction
* Installation::             Installation
* Getting Started::          Getting Started
* Interface Concepts::       Interface Concepts
* Inspecting::               Inspecting
* Manipulating::             Manipulating
* Transferring::             Transferring
* Miscellaneous::            Miscellaneous
* Customizing::              Customizing
* 配管コマンド(Plumbing)::  配管コマンド(Plumbing)
* FAQ::                      FAQ
* Debugging Tools::          Debugging Tools
* Keystroke Index::          Keystroke Index
* Function and Command Index::  Function and Command Index
* Variable Index::           Variable Index

— The Detailed Node Listing —



Installation



* Installing from Melpa::    Installing from Melpa
* Installing from the Git Repository::  Installing from the Git Repository
* Post-Installation Tasks::  Post-Installation Tasks

Interface Concepts



* Modes and Buffers::        Modes and Buffers
* Sections::                 Sections
* トランジェントコマンド::  トランジェントコマンド
* Transient Arguments and Buffer Variables::  Transient Arguments and Buffer
                                                Variables
* Completion(補完)とConfirmation(確認)とSelection(選択範囲): Completion Confirmation(確認補完)とSelection(選択範囲).  Completion(補完)とConfirmation(確認)とSelection(選択範囲):
                                                                                                                                           Completion
                                                                                                                                           Confirmation(確認補完)とSelection(選択範囲)
* Mouse Support::            Mouse Support
* Running Git::              Running Git

Modes and Buffers



* バッファの切り替え::  バッファの切り替え
* バッファの名付け::  バッファの名付け
* Quitting Windows::         Quitting Windows
* Automatic Refreshing of Magit Buffers::  Automatic Refreshing of Magit
                                             Buffers
* Automatic Saving of File-Visiting Buffers::  Automatic Saving of
                                                 File-Visiting Buffers
* Automatic Reverting of File-Visiting Buffers::  Automatic Reverting of
                                                    File-Visiting Buffers



Sections



* Section Movement::         Section Movement
* Section Visibility::       Section Visibility
* Section Hooks::            Section Hooks
* Section Types and Values::  Section Types and Values
* Section Options::          Section Options



Completion(補完)とConfirmation(確認)とSelection(選択範囲)



* アクションの確認::  アクションの確認
* 補完と確認::          補完と確認
* 選択範囲::             選択範囲
* ハンク内部リージョン::  ハンク内部リージョン
* 補完フレームワークのサポート::  補完フレームワークのサポート
* 追加の補完オプション::  追加の補完オプション



Running Git



* Viewing Git Output::       Viewing Git Output
* Git Process Status::       Git Process Status
* Gitを手動で実行::    Gitを手動で実行
* Git実行ファイル::    Git実行ファイル
* Global Git Arguments::     Global Git Arguments



Inspecting



* Status Buffer::            Status Buffer
* Repository List::          Repository List
* Logging::                  Logging
* Diffing::                  Diffing
* Ediffing::                 Ediffing
* References Buffer::        References Buffer
* Bisecting::                Bisecting
* Visiting Files and Blobs::  Visiting Files and Blobs
* Blaming::                  Blaming

Status Buffer



* Status Sections::          Status Sections
* Status Header Sections::   Status Header Sections
* Status Module Sections::   Status Module Sections
* Status Options::           Status Options



Logging



* Refreshing Logs::          Refreshing Logs
* Log Buffer::               Log Buffer
* Log Margin::               Log Margin
* Select from Log::          Select from Log
* Reflog::                   Reflog
* Cherries::                 Cherries



Diffing



* Refreshing Diffs::         Refreshing Diffs
* Commands Available in Diffs::  Commands Available in Diffs
* Diff Options::             Diff Options
* Revision Buffer::          Revision Buffer



References Buffer



* References Sections::      References Sections



Visiting Files and Blobs



* General-Purpose Visit Commands::  General-Purpose Visit Commands
* Visiting Files and Blobs from a Diff::  Visiting Files and Blobs from a
                                            Diff



Manipulating



* Creating Repository::      Creating Repository
* Cloning Repository::       Cloning Repository
* Staging and Unstaging::    Staging and Unstaging
* Applying::                 Applying
* Committing::               Committing
* Branching::                Branching
* Merging::                  Merging
* Resolving Conflicts::      Resolving Conflicts
* Rebasing::                 Rebasing
* Cherry Picking::           Cherry Picking
* Resetting::                Resetting
* Stashing::                 Stashing

Staging and Unstaging



* Staging from File-Visiting Buffers::  Staging from File-Visiting Buffers



Committing



* コミット開始::       コミット開始
* Editing Commit Messages::  Editing Commit Messages



Branching



* The Two Remotes::          The Two Remotes
* Branch Commands::          Branch Commands
* Branch Git Variables::     Branch Git Variables
* Auxiliary Branch Commands::  Auxiliary Branch Commands



Rebasing



* Editing Rebase Sequences::  Editing Rebase Sequences
* Information About In-Progress Rebase::  Information About In-Progress
                                            Rebase



Cherry Picking



* Reverting::                Reverting



Transferring



* Remotes::                  Remotes
* Fetching::                 Fetching
* Pulling::                  Pulling
* Pushing::                  Pushing
* Plain Patches::            Plain Patches
* Maildir Patches::          Maildir Patches

Remotes



* Remote Commands::          Remote Commands
* Remote Git Variables::     Remote Git Variables



Miscellaneous



* Tagging::                  Tagging
* Notes::                    Notes
* Submodules::               Submodules
* Subtree::                  Subtree
* Worktree::                 Worktree
* Sparse checkouts::         Sparse checkouts
* Bundle::                   Bundle
* Common Commands::          Common Commands
* Wip Modes::                Wip Modes
* Commands for Buffers Visiting Files::  Commands for Buffers Visiting Files
* Minor Mode for Buffers Visiting Blobs::  Minor Mode for Buffers Visiting
                                             Blobs

Submodules



* Listing Submodules::       Listing Submodules
* submodule用トランジェントコマンド::  submodule用トランジェントコマンド



Wip Modes



* Wip Graph::                Wip Graph
* Legacy Wip Modes::         Legacy Wip Modes



Customizing



* Per-Repository Configuration::  Per-Repository Configuration
* 基本設定::             基本設定

基本設定



* Safety::                   Safety
* Performance::              Performance
* Default Bindings::         Default Bindings



配管コマンド(Plumbing)



* Calling Git::              Calling Git
* Section Plumbing::         Section Plumbing
* Refreshing Buffers::       Refreshing Buffers
* 慣習::                   慣習

Calling Git



* Getting a Value from Git::  Getting a Value from Git
* Calling Git for Effect::   Calling Git for Effect



Section Plumbing



* Creating Sections::        Creating Sections
* Section Selection::        Section Selection
* Matching Sections::        Matching Sections



慣習



* Theming Faces::            Theming Faces



FAQ



* FAQ - How to ...?::    FAQ - How to ...?
* FAQ - Issues and Errors::  FAQ - Issues and Errors

FAQ - How to ...?



* Magitの発音は？::     Magitの発音は？
* How to show git's output?::  How to show git’s output?
* How to install the gitman info manual?::  How to install the gitman info
                                              manual?
* How to show diffs for gpg-encrypted files?::  How to show diffs for
                                                  gpg-encrypted files?
* How does branching and pushing work?::  How does branching and pushing
                                            work?
* VCを無効にする必要がありますか？::  VCを無効にする必要がありますか？



FAQ - Issues and Errors



* Magit is slow::            Magit is slow
* I changed several thousand files at once and now Magit is unusable::  I
                                                                          changed
                                                                          several
                                                                          thousand
                                                                          files
                                                                          at
                                                                          once
                                                                          and
                                                                          now
                                                                          Magit
                                                                          is
                                                                          unusable
* コミットに問題があります::  コミットに問題があります
* MS WindowsではMagitでpushできません::  MS
                                                   WindowsではMagitでpushできません
* 私は macOS を使用しています。その何かはシェルでは動きますが、Magitでは動きません: 私は macOS を使用しています。その何かはシェルでは動きますが、Magitでは動きません.  私は
                                                                                                                                                                                                                                             macOS
                                                                                                                                                                                                                                             を使用しています。その何かはシェルでは動きますが、Magitでは動きません:
                                                                                                                                                                                                                                             私は
                                                                                                                                                                                                                                             macOS
                                                                                                                                                                                                                                             を使用しています。その何かはシェルでは動きますが、Magitでは動きません
* ファイルを展開してdiffを表示するとファイルが消えます::  ファイルを展開してdiffを表示するとファイルが消えます
* COMMIT_EDITMSGバッファのpointが間違っています::  ‘COMMIT_EDITMSG’バッファのpointが間違っています
* モード行の情報が常に最新ではない::  モード行の情報が常に最新ではない
* 同じ名前を共有するブランチとタグは何かを壊します::  同じ名前を共有するブランチとタグは何かを壊します
* 私のGitフックはコマンドラインでは機能しますが、Magit内では機能しません::  私のGitフックはコマンドラインでは機能しますが、Magit内では機能しません
* コマンドラインからコミットする場合、git-commit-modeは使用されません::  コマンドラインからコミットする場合、‘git-commit-mode’は使用されません
* file-visitingバッファにジャンプすると、ポイントは非表示のテキスト内にあります::  file-visitingバッファにジャンプすると、ポイントは非表示のテキスト内にあります
* MS-WindowsからEmacsのTrampモードを使用するとステージできません::  MS-WindowsからEmacsのTrampモードを使用するとステージできません
* 私はポップアップのデフォルトを保存できなくなりました::  私はポップアップのデフォルトを保存できなくなりました





File: magit.ja.info,  Node: Introduction,  Next: Installation,  Prev: Top,  Up: Top

1 Introduction
**************

Magitは、バージョン管理システムGitへのインターフェースであり、Emacsパッ
ケージとして実装されています。Magitは完全なGit磁器を目指しています。
MagitがすべてのGitコマンドをラップして改善するとは(まだ)主張できませんが
、経験豊富なGitユーザーでさえEmacs内から直接毎日のバージョン管理タスクの
ほとんどすべてを実行できるほど十分に完全です。多くの優れたGitクライアン
トが存在しますが、磁器と呼ばれるのはMagitとGit自体だけです。(訳注:低レベ
ルのを配管(plumbing)コマンド、よりユーザーフレンドリーなのを磁器
(porcelain)コマンドと称する)

ステージやその他の変更の適用は、Git磁器の最も重要な機能の1つであり、ここ
でMagitは、Git自体を含む他のどれよりも優れています。Git独自のステージイ
ンターフェース(‘git add --patch’)は非常に扱いにくいため、多くのユーザー
は例外的な場合にのみ使用します。 Magitでは、ハンクまたはハンクの一部をス
テージすることは、ファイルに加えられたすべての変更をステージするのと同じ
くらい簡単です。(訳注:ハンク(hunk) 大きなかたまり。関数単位とかじゃない
けどファイル全体でもないようなかたまりのこと)

Magitのインターフェースの最も目に見える部分は、現在のリポジトリに関する
情報を表示するステータスバッファです。そのコンテンツは、いくつかのGitコ
マンドを実行し、それらの出力に対して操作可能にしたもので作成されます。 特
に、現在のブランチに関する情報を表示し、プルされていない変更(unpulled
changes)とプッシュされていない変更(unpushed changes)を一覧表示し、ステー
ジされた変更(staged changes)とステージされていない変更(unstaged
changes)を表示するセクションを含みます。煩雑な表示に思えるえるかもしれま
せんが、セクションは折りたたみ可能であるため、そんなことはありません。

変更をステージ(stage)またはステージ解除(unstage)するには、変更にカーソル
を置き、‘s’または‘u’と入力します。変更対象はファイルやハンクで、領域がア
クティブな場合(つまり選択がある場合)、それは複数ファイルやハンク、あるい
はハンクの一部分かもしれません。これらのコマンド(および他の多くのコマン
ド)が作用する1つまたは複数の変更が強調表示されます。

Magitは、ステージとステージ解除に加えて、他のいくつかの適用バリエーショ
ン("apply variants")も実装しています。 変更を破棄または元に戻すか、作業
ツリーに適用できます。Git自身の磁器は、ステージとステージ解除でのみこれ
をサポートしており、‘git diff ... | ??? | git apply ...’を使用して、コマ
ンドラインで単一のハンクを破棄、revert、または適用します。 実際、これは
まさにMagitが内部で行っていることです(これが適用バリエーション("apply
variants")という用語につながるものです)。

MagitはGitの専門家だけのものではありませんが、GitやEmacsでの経験があるこ
とを前提としています。 そうは言っても、多くのMagitユーザーは、Magitを使
用することで、Gitの機能と、Gitを最大限に活用する方法を悟ったといっていま
す。他のユーザーは、Magitをもっと早く手に入れることができるように、もっ
と早くEmacsに切り替えたいと願っていました。

Magitを最大限に活用するにはEmacsの基本機能を知っている必要がありますが、
他のエディターを好むユーザーにとっても、十分なEmacsスキルを習得するのに
時間はかからず、それだけの価値があります。 Vimユーザーは、Evil
(https://github.com/emacs-evil/evil)「Extensible VI Layer for Emacs」、
およびSpacemacs (https://github.com/syl20bnr/spacemacs)「Emacs
starter-kit focused on Evil」を試してみることをお勧めします。

Magitは、一貫性のある効率的なGit磁器を提供します。短い学習期間の後、コマ
ンドラインよりも高速に毎日のバージョン管理タスクのほとんどを実行できるよ
うになります。また、過去には気が遠くなるように思われた機能も使い始めるで
しょう。

MagitはGitを完全に包含しています。多くのGUIクライアントのように些細なも
のをラップするだけでなく、シンプルでありながら柔軟なインターフェイスを使
用して、多くの高度な機能を公開します。 もちろん、Magitは、ロギング、クロ
ーン作成、プッシュ、および通常は見事な方法により失敗することはないその他
のコマンドをサポートしています。ただし、1つのステップで完了できないこと
が多いタスクもサポートします。Magitは、これらのタスクを開始するコマンド
を提供するだけでなく、途中で状況に応じた情報を表示し、競合の解決と再開後
の作業に役立つコマンドを提供することにより、マージ、リベース、チェリーピ
ッキング、revert、blameなどのタスクを完全にサポートします。

Magitはラップすることにより、多くの場合、少なくとも次のGit磁器コマンドを
改善します: ‘add’, ‘am’, ‘bisect’, ‘blame’, ‘branch’, ‘checkout’,
‘cherry’, ‘cherry-pick’, ‘clean’, ‘clone’, ‘commit’, ‘config’,
‘describe’, ‘diff’, ‘fetch’, ‘format-patch’, ‘init’, ‘log’, ‘merge’,
‘merge-tree’, ‘mv’, ‘notes’, ‘pull’, ‘rebase’, ‘reflog’, ‘remote’,
‘request-pull’, ‘reset’, ‘revert’, ‘rm’, ‘show’, ‘stash’, ‘submodule’,
‘subtree’, ‘tag’, ‘worktree.’ そして、さらに多くのMagit磁器コマンドが
Git配管コマンドの上に実装されています。


File: magit.ja.info,  Node: Installation,  Next: Getting Started,  Prev: Introduction,  Up: Top

2 Installation
**************

Magitは、Emacsのパッケージマネージャーを使用してインストールすることも、
開発リポジトリから手動でインストールすることもできます。

* Menu:

* Installing from Melpa::    Installing from Melpa
* Installing from the Git Repository::  Installing from the Git Repository
* Post-Installation Tasks::  Post-Installation Tasks


File: magit.ja.info,  Node: Installing from Melpa,  Next: Installing from the Git Repository,  Up: Installation

2.1 Installing from Melpa
=========================

MagitはMelpaおよびMelpa-Stableから入手できます。まだEmacsのパッケージマ
ネージャーを使用したことがない場合は、Emacsマニュアルのドキュメントを読
んで慣れてください(*note (emacs)Packages::)。次に、アーカイブの1つを
‘package-archives’に追加します:

   • Melpaを使うなら:

     (require 'package)
     (add-to-list 'package-archives
                  '("melpa" . "http://melpa.org/packages/") t)

   • Melpa-Stableを使うなら:

     (require 'package)
     (add-to-list 'package-archives
                  '("melpa-stable" . "http://stable.melpa.org/packages/") t)

あなたの好きな方のアーカイブを追加したら、以下を使用してローカルパッケー
ジリストを更新する必要があります:

     M-x package-refresh-contents RET

それが完了したら、以下を使用してMagitとその依存関係にあるパッケージをイ
ンストールできます:

     M-x package-install RET magit RET

なお、インストール後にしなければならない作業があります。こちらを参照して
下さい(*note Post-Installation Tasks::)。


File: magit.ja.info,  Node: Installing from the Git Repository,  Next: Post-Installation Tasks,  Prev: Installing from Melpa,  Up: Installation

2.2 Installing from the Git Repository
======================================

Magitは、MelpaおよびMelpa-Stableから入手できる、‘dash’と‘transient’と
‘with-editor’ライブラリに依存しています。‘M-x package-install RET
<package> RET’を使用してインストールします。もちろん、それぞれのリポジト
リから手動でインストールすることもできます。

次に、Magitリポジトリのクローンを作成します:

     $ git clone https://github.com/magit/magit.git ~/.emacs.d/site-lisp/magit
     $ cd ~/.emacs.d/site-lisp/magit

次に、ライブラリをコンパイルして、infoマニュアルを生成します:

     $ make

Melpaや‘/path/to/magit/../<package>’から‘dash’と‘transient’と
‘with-editor’をインストールした場合は、以下のようにして‘make’にそれらの
場所を指示します。これを行うには、‘make’を実行する前に、以下の内容のファ
イル‘/path/to/magit/config.mk’を作成します:

     LOAD_PATH  = -L ~/.emacs.d/site-lisp/magit/lisp
     LOAD_PATH += -L ~/.emacs.d/site-lisp/dash
     LOAD_PATH += -L ~/.emacs.d/site-lisp/transient/lisp
     LOAD_PATH += -L ~/.emacs.d/site-lisp/with-editor

最後に、以下をEmacsのinitファイルに追加します:

     (add-to-list 'load-path "~/.emacs.d/site-lisp/magit/lisp")
     (require 'magit)

     (with-eval-after-load 'info
       (info-initialize)
       (add-to-list 'Info-directory-list
                    "~/.emacs.d/site-lisp/magit/Documentation/"))

依存関係パッケージも手動でインストールした場合は、もちろん、上記Lispコー
ドより前に以下を挿入して、Emacsにも依存関係について通知する必要がありま
す:

     (add-to-list 'load-path "~/.emacs.d/site-lisp/dash")
     (add-to-list 'load-path "~/.emacs.d/site-lisp/transient/lisp")
     (add-to-list 'load-path "~/.emacs.d/site-lisp/with-editor")

注意: ‘lisp’サブディレクトリをリポジトリのトップレベルではなく
‘load-path’に追加する必要があり、‘load-path’の要素はスラッシュで終わって
いるべきではありません。逆に‘Info-directory-list’の要素はスラッシュで終
わっているべきです。

‘magit’機能をrequireする代わりに、ファイル‘magit-autoloads.el’をロードす
ることにより、autoload定義のみをロードできます。

     (load "/path/to/magit/lisp/magit-autoloads")

クローンしたリポジトリのMagitを‘load-path’に追加してクローンしたリポジト
リから直接実行する代わりに、‘sudo make install’を使用して他のディレクト
リにインストールし、そこからの‘load-path’を設定することをお勧めします。

Magitを更新するには、以下を使用します:

     $ git pull
     $ make

代わりに‘make clean all’を実行する必要がある場合があります。

使用可能なすべてのターゲットを表示するには、‘make help’を使用します。

なお、インストール後にしなければならない作業があります。こちらを参照して
下さい(*note Post-Installation Tasks::)。


File: magit.ja.info,  Node: Post-Installation Tasks,  Prev: Installing from the Git Repository,  Up: Installation

2.3 Post-Installation Tasks
===========================

Magitインストール後、あなたが使用していると思っている、MagitとGitと
Emacsのリリースを、実際に使用していることを確認する必要があります。なお
、‘load-path’に編集前の古い値を使用していないことを確実するために、
Magitを再起動する前にEmacsを再起動することをお勧めします。

     M-x magit-version RET

次のようなものが表示される必要があります

     Magit 2.8.0, Git 2.10.2, Emacs 25.1.1, gnu/linux

取り急ぎ、多くのユーザーがカスタマイズを検討するオプションついて知りたい
なら、こちらを参照するといいでしょう(*note 基本設定::)

このマニュアルにあるGit manpageへの相互参照をたどることができるようにす
るには、‘gitman’ infoマニュアルを手動でインストールするか、
‘Info-follow-nearest-node’でアドバイスして実際のmanpageを開く必要がある
場合もあります。 (*note How to install the gitman info manual?::)

あなたがMagitを完全に初めて触る場合は→(*note Getting Started::)

問題が発生した場合は(*note FAQ::)や(*note Debugging Tools::)を参照して下
さい。

そして最後になりましたが、私がMagitに取り組み続けることができるように、
寄付を検討してください。<https://magit.vc/donations>を参照してください。
さまざまな寄付オプションがあります。


File: magit.ja.info,  Node: Getting Started,  Next: Interface Concepts,  Prev: Installation,  Up: Top

3 Getting Started
*****************

この短いチュートリアルでは、多くのマジシャン(Magitian)が日常的に使用する
最も重要な機能について説明します。それは表面を引っ掻く程度ですが、あなた
が始めるのに十分なはずです。

重要: このチュートリアルのためだけにリポジトリのクローンを作成するのが最
も安全です。または、既存のローカルリポジトリを使用することもできますが、
その場合は、作業を続行する前に、コミットされていないすべての変更をコミッ
トする必要があります。

‘C-x g’と入力して、ステータスバッファと呼ばれる専用バッファ内の現在の
Gitリポジトリに関する情報を表示します。

ほとんどのMagitコマンドは、通常、ステータスバッファから呼び出されます。
これは、Magitを使用してGitと対話するための主要なインターフェースと見なす
ことができます。他の多くのMagitバッファが特定の時間に存在する可能性があ
りますが、多くの場合、これらはこのバッファから作成されます。

リポジトリの状態に応じて、このバッファには、"Staged changes"、"Unstaged
changes"、"Unmerged into origin/master"、"Unpushed to origin/master"、そ
の他のタイトルのセクションが含まれる場合があります。

(‘git reset --hard PRE-MAGIT-STATE’を実行することで)簡単に戻ることができ
る安全な状態から開始しているため、現在、ステージされた変更(staged
changes)またはステージされてない変更(unstaged changes)はありません。いく
つかのファイルを編集し、変更を保存します。それから‘C-x g’と入力して、ス
テータスバッファに戻り、同時にリフレッシュします(ステータスバッファ、ま
たはそのためのMagitバッファが現在のバッファである場合は、‘g’だけを使用し
てリフレッシュすることもできます)。

‘p’と‘n’を使用してセクション間を移動します。一部のセクションの本文は非表
示になっていることに注意してください。‘TAB’と入力して、ポイントでセクシ
ョンを展開または折りたたみます。‘C-tab’を使用して、現在のセクションとそ
の子の表示を循環させることもできます。"Unstaged changes"という名前のセク
ション内のファイルセクションに移動し、‘s’と入力して、そのファイルに加え
た変更をステージします。 そのファイルは"Staged changes"の下に表れます。

Magitは、完全なファイルだけでなく、個々のハンクをステージ(stage)およびス
テージ解除(unstage)できます。ステージしたファイルに移動し、‘TAB’を使用し
て展開し、‘n’を使用してハンクのいずれかに移動し、‘u’と入力してステージを
解除します。ステージ(‘s’)コマンドとステージ解除(‘u’)コマンドがポイントで
の変更に対してどのように動作するかに注意してください。他の多くのコマンド
も同じように動作します。

ハンクの一部だけをステージ解除(unstage)/ステージ(stage)することもできま
す。ハンクセクションの本体内(‘C-n’を使用してそこに移動する)で、‘C-SPC’を
使用してマークを設定し、追加または削除された行がすべてリージョン内に収ま
るまで下に移動します。そして、もう一度‘s’と入力してステージします。

複数のファイルを一度にステージ解除(unstage)/ステージ(stage)することも可
能です。ファイルセクションに移動し、‘C-SPC’と入力し、‘n’を使用して次のフ
ァイルに移動し、次に‘s’を使用して両方のファイルをステージします。これが
機能するには、マークとポイントの両方が兄弟セクションの見出しにある必要が
あることに注意してください。リージョンが他のバッファと同じように見える場
合、ユニットとして機能できるMagitセクションは選択されません。

そしてもちろん、変更をコミットする必要があります。‘c’と入力します。ここ
で、フレームの下部にあるバッファで使用可能なコミットコマンドと引数を示し
ています。各コマンドと引数には、それを呼び出す/設定するキーがプレフィッ
クスとして付けられます。ここではこれについて気にする必要はありません。「
通常の」コミットを作成します。これは、‘c’をもう一度入力することで実行さ
れます。

これで、2つの新しいバッファが表示されます。1つはコミットメッセージを書き
込むためのもので、もう1つはコミットしようとしている変更とのdiffを示しま
す。メッセージを書き込んでから、‘C-c C-c’と入力して、実際にコミットを作
成します。

ランダムな変更をコミットしただけなので、作成したばかりのコミットをプッシ
ュしたくない場合がありますが、そうでない場合は、‘P’と入力して、使用可能
なすべてのプッシュコマンドと引数を表示してからプッシュできます。‘p’は、
ローカルブランチと同じ名前のブランチにpush-remoteとして構成された
remoteにプッシュします。(push-remoteがまだ構成されていない場合は、最初に
プッシュするためのremoteを求められます。)

これまで、commit、push、およびlogメニューコマンドについて説明してきまし
た。これらはおそらくあなたが最も使用するメニューの1つですが、他にもたく
さんあります。他のすべてのメニュー(およびさまざまなapplyコマンドやその他
の重要なコマンド)を一覧表示するメニューを表示するには、‘h’と入力します。
いくつか試してみてください。(このようなメニューは、トランジェントプレフ
ィックスコマンド(一時的接頭辞コマンド)または単にトランジェントとも呼ばれ
ます。）

そのメニューのキーバインディングは、ステータスバッファを含むがこれに限定
されない、Magitバッファのバインディングに対応します。したがって、‘h d’と
入力してdiffメニューを表示できますが、「d」が「diff」を表すことを思い出
したら、通常は‘d’と入力するだけです。ただし、この「プレフィックスのプレ
フィックス」は、すべてのバインディングを記憶した後でも、Magit以外のバッ
ファからMagitコマンドに簡単にアクセスできるため便利です。グローバルバイ
ンディングは‘C-x M-g’です。

file visitingバッファでは、‘C-c M-g’は、訪問したファイルのみに作用する機
能コマンド群である同様のメニューを表示します(*note Commands for Buffers
Visiting Files::)。

Magit は、コンテキストメニューやその他マウスコマンドも提供します。 *note
Mouse Support:: を参照してください。

今すぐでなくて構いませんが、Magitを使い続ける場合は、次の節も読むことを
強くお勧めします。


File: magit.ja.info,  Node: Interface Concepts,  Next: Inspecting,  Prev: Getting Started,  Up: Top

4 Interface Concepts
********************

* Menu:

* Modes and Buffers::        Modes and Buffers
* Sections::                 Sections
* トランジェントコマンド::  トランジェントコマンド
* Transient Arguments and Buffer Variables::  Transient Arguments and Buffer
                                                Variables
* Completion(補完)とConfirmation(確認)とSelection(選択範囲): Completion Confirmation(確認補完)とSelection(選択範囲).  Completion(補完)とConfirmation(確認)とSelection(選択範囲):
                                                                                                                                           Completion
                                                                                                                                           Confirmation(確認補完)とSelection(選択範囲)
* Mouse Support::            Mouse Support
* Running Git::              Running Git


File: magit.ja.info,  Node: Modes and Buffers,  Next: Sections,  Up: Interface Concepts

4.1 Modes and Buffers
=====================

Magitはいくつかのメジャーモードを提供します。 これらのモードのそれぞれに
ついて、通常、リポジトリごとに1つのバッファのみが存在します。個別のモー
ドとそのためのバッファは、コミット、diff、ログ、およびその他のいくつかの
もののために存在します。

これらの特別な目的のバッファに加えて、*ステータスバッファ*と呼ばれる概要
バッファもあります。ユーザーがGitコマンドを呼び出すか、他のバッファを作
成または訪問するのは、通常、このバッファからです。

このマニュアルでは、「Magitバッファ」についてよく話します。つまり、メジ
ャーモードが‘magit-mode’から派生するバッファを意味します。

‘M-x magit-toggle-buffer-lock’
     このコマンドは、現在のバッファをその値にロックします。バッファがす
     でにロックされている場合は、ロックを解除します。

     バッファをその値にロックすると、別の値を表示するためにバッファが再
     利用されるのを防ぐことができます。ロックされたバッファの名前にはそ
     の値が含まれているため、他のロックされたバッファやロックされていな
     いバッファと区別することができます。

     すべてのMagitバッファをそれらの値にロックできるわけではありません。
     たとえば、ステータスバッファをロックすることは意味がありません。

     リポジトリごとに特定のメジャーモードを使用するロック解除されたバッ
     ファは1つだけです。したがって、バッファがロック解除されていて、その
     モードとリポジトリ用に別のロック解除されたバッファがすでに存在する
     場合、前者のバッファは代わりに削除され、後者がその場所に表示されま
     す。

* Menu:

* バッファの切り替え::  バッファの切り替え
* バッファの名付け::  バッファの名付け
* Quitting Windows::         Quitting Windows
* Automatic Refreshing of Magit Buffers::  Automatic Refreshing of Magit
                                             Buffers
* Automatic Saving of File-Visiting Buffers::  Automatic Saving of
                                                 File-Visiting Buffers
* Automatic Reverting of File-Visiting Buffers::  Automatic Reverting of
                                                    File-Visiting Buffers


File: magit.ja.info,  Node: バッファの切り替え,  Next: バッファの名付け,  Up: Modes and Buffers

4.1.1 バッファの切り替え
------------------------

 -- Function: magit-display-buffer buffer &optional display-function
     この関数は‘display-buffer’のラッパーであり、Magitバッファを表示する
     ために使用されます。一部のウィンドウにBUFFERを表示し、
     ‘display-buffer’とは異なり、‘magit-display-buffer-noselect’が
     ‘nil’の場合、そのウィンドウも選択します。また、以下に説明するフック
     を実行します。

     オプションのDISPLAY-FUNCTIONがnil以外の場合、それはバッファを表示す
     るために使用されます。通常、これは‘nil’であり、
     ‘magit-display-buffer-function’で指定された関数が使用されます。

 -- Variable: magit-display-buffer-noselect
     これがnil以外の場合、‘magit-display-buffer’はバッファのみを表示し、
     ウィンドウの選択も行いません。この変数はグローバルに設定しないでく
     ださい。「もう一方のウィンドウ」(the other window)を自動的に更新す
     るコードによって、制限されることのみを目的としています。これは、た
     とえば、ログバッファ内に移動したときにリビジョンバッファが更新され
     るときに使用されます。

 -- User Option: magit-display-buffer-function
     ここで指定された関数は、‘magit-display-buffer’によって呼び出され、
     1つの引数、つまりバッファを使用して、そのバッファを実際に表示します
     。この関数は、最初にそのバッファを使用し、2番目の引数として表示アク
     ションのリストを使用して‘display-buffer’を呼び出す必要があります。

     Magitは、このオプションに適した値である、以下にリストされているいく
     つかの関数を提供します。あなたが別のルールを使用したい場合は、これ
     らの関数の1つのコピーから始めて、あなたの必要に応じて調整(adjust)す
     ることをお勧めします。

     ‘display-buffer’のラッパーを使用する代わりに、その関数自体をここで
     使用できます。その場合、代わりに‘display-buffer-alist’に追加して表
     示アクションを指定する必要があります。

     表示アクションについてはこちらを参照して下さい(*note
     (elisp)Choosing Window::)。

 -- Function: magit-display-buffer-traditional buffer
     この関数は、オプション‘magit-display-buffer-function’の現在のデフォ
     ルト値です。そのオプションとこの関数が追加される前は、動作はコード
     ベース全体の多くの場所でハードコーディングされていましたが、現在は
     すべてのルールがこの1つの関数に含まれています(上記の「noselect」特
     殊ケースを除く)。

 -- Function: magit-display-buffer-same-window-except-diff-v1
     この関数は、現在選択されているウィンドウにほとんどのバッファを表示
     します。バッファのモードが‘magit-diff-mode’または
     ‘magit-process-mode’から派生している場合、別のウィンドウに表示され
     ます。

 -- Function: magit-display-buffer-fullframe-status-v1
     この関数は、ステータスバッファを表示するときにフレーム全体を埋めま
     す(fill)。それ以外の場合は、‘magit-display-buffer-traditional’のよ
     うに動作します。

 -- Function: magit-display-buffer-fullframe-status-topleft-v1
     この関数は、ステータスバッファを表示するときにフレーム全体を埋めま
     す(fill)。‘magit-display-buffer-fullframe-status-v1’と同じように動
     作しますが、‘magit-diff-mode’または‘magit-process-mode’から派生した
     バッファが、現在のバッファの下部または右側ではなく、上部または左側
     に表示される点が異なります。その結果、Magitバッファは、
     ‘magit-display-buffer-traditional’が使用されている場合と同じ側にポ
     ップアップする傾向があります。

 -- Function: magit-display-buffer-fullcolumn-most-v1
     この関数は、ほとんどのバッファを表示して、フレームの高さ全体を埋め
     る(fill)ようにします。 ただし、(1)バッファのモードが
     ‘magit-process-mode’から派生している場合、または(2)バッファのモード
     が‘magit-diff-mode’から派生している場合、現在のバッファのモードが
     ‘magit-log-mode’または‘magit-cherry-mode’から派生している場合、バッ
     ファは別のウィンドウに表示されます。

 -- User Option: magit-pre-display-buffer-hook
     このフックは、バッファを表示する前に‘magit-display-buffer’によって
     実行されます。

 -- Function: magit-save-window-configuration
     この関数は、現在のウィンドウ構成を保存します。後でバッファが隠され
     る(bury)と、‘magit-restore-window-configuration’によって復元される
     可能性があります。

 -- User Option: magit-post-display-buffer-hook
     このフックは、バッファを表示した後、‘magit-display-buffer’によって
     実行されます。

 -- Function: magit-maybe-set-dedicated
     この関数は、バッファを表示するために新しいウィンドウを作成する必要
     があるかどうか、または既存のウィンドウが再利用されたかどうかを記憶
     しています。 この情報は、後で‘magit-mode-quit-window’によって使用さ
     れ、最後のMagitバッファが隠された(bury)ときにウィンドウを削除する必
     要があるかどうかを判断します。


File: magit.ja.info,  Node: バッファの名付け,  Next: Quitting Windows,  Prev: バッファの切り替え,  Up: Modes and Buffers

4.1.2 バッファの名付け
----------------------

 -- User Option: magit-generate-buffer-name-function
     Magitバッファの名前を生成するために使用される関数。

     このような関数は、オプション‘magit-uniquify-buffer-names’と
     ‘magit-buffer-name-format’を考慮に入れる必要があります。そうでない
     場合は、doc-stringに明確に記載する必要があります。また、オプション
     ‘magit-buffer-name-format’のdoc-stringに記載されている以外の
     %-sequencesをサポートしている場合は、独自のdoc-stringで追加を説明す
     る必要があります。

 -- Function: magit-generate-buffer-name-default-function mode
     この関数は、メジャーモードが「mode」であり、かつ、
     ‘default-directory’が配置されているリポジトリに関する情報を表示する
     バッファに適したバッファ名を返します。

     この関数は‘magit-buffer-name-format’を使用し、そのオプションの文書
     に記載されているすべての %シーケンス をサポートします。また、オプシ
     ョン‘magit-uniquify-buffer-names’も尊重します。

 -- User Option: magit-buffer-name-format
     Magitバッファに名前を付けるために使用されるフォーマット文字列。

     少なくとも以下の%シーケンスがサポートされています:

        • ‘%m’

          メジャーモードの名前ですが、‘-mode’接尾辞部分が削除されていま
          す。

        • ‘%M’

          ‘%m’に似ていますが、‘magit-status-mode’を‘magit’と省略します。

        • ‘%v’

          バッファがロックされている時のカッコ内の値。またはバッファが値
          にロックされていない場合は空文字列。

        • ‘%V’

          ‘%v’と同様ですが、空文字列でない限り、文字列の前にスペースが付
          きます。

        • ‘%t’

          リポジトリの作業ツリーの最上位ディレクトリ、または
          ‘magit-uniquify-buffer-names’がnil以外の場合はその省略形。

        • ‘%x’

          ‘magit-uniquify-buffer-names’がnilの場合"*"、それ以外の場合は
          空の文字列。‘uniquify’パッケージの制限により、バッファ名はパス
          で終わる必要があります。

        • ‘%T’

          廃止されました。代わりに"%t%x"を使用してください。‘%t’と同様で
          すが、‘magit-uniquify-buffer-names’がnilの場合にのみ、アスタリ
          スクを追加します。

     値には、常に、‘%m’または‘%M’と、‘%v’または‘%V’と、‘%t’(または廃止さ
     れた‘%T’)が含まれているべきです。‘magit-uniquify-buffer-names’が
     nil以外の場合、値は ‘%t’または‘%t%x’(または廃止された‘%T’)で終わる
     必要があります。issue #2841 を参照してください。

 -- User Option: magit-uniquify-buffer-names
     このオプションは、Magitバッファ達の名前を一意化(uniquify)するかどう
     かを制御します。名前が一意化されていない場合は、対応するリポジトリ
     の作業ツリーの最上位のフルパスが含まれます。一意化されている場合は
     、最上位のベース名で終了します。それが他のバッファに使用されている
     名前と競合する場合は、競合しなくなるまで、これらすべてのバッファの
     名前が調整されます。

     これは、‘uniquify’パッケージを使用して行われます。そのオプションを
     カスタマイズして、バッファ名の一意化(uniquify)方法を制御します。


File: magit.ja.info,  Node: Quitting Windows,  Next: Automatic Refreshing of Magit Buffers,  Prev: バッファの名付け,  Up: Modes and Buffers

4.1.3 Quitting Windows
----------------------

‘q’ (‘magit-mode-bury-buffer’)
     このコマンドは現在のMagitバッファを隠し(bury)ます。

     プレフィックス引数を付けると、代わりにバッファを強制終了します。プ
     レフィックス引数を2つ付けると、現在のプロジェクトに関連付けられてい
     る他のすべてのMagitバッファも強制終了します。

 -- User Option: magit-bury-buffer-function
     現在のバッファを実際に隠す(bury)かまたは強制終了(kill)するために使
     用される関数。

     ‘magit-mode-bury-buffer’は、この関数を1つの引数で呼び出します。引数
     がnil以外の場合、関数は現在のバッファを強制終了(kill)する必要があり
     ます。そうでなければ、それは生きたまま隠さなければなりません。現在
     のデフォルト値は‘magit-restore-window-configuration’です。

 -- Function: magit-restore-window-configuration kill-buffer
     ‘quit-window’を使用して現在のバッファを隠す(bury)か、強制終了
     (kill)します。これは、最初にKILL-BUFFERを使用し、2番目の引数として
     選択したウィンドウを使用して呼び出されます。

     それから、選択したフレームに現在のバッファが表示される直前に存在し
     ていたウィンドウ構成を復元します。残念ながら、それはまた、選択した
     フレームに表示されているすべてのバッファでポイントが調整されること
     を意味します。

 -- Function: magit-mode-quit-window kill-buffer
     ‘quit-window’を使用して現在のバッファを隠す(bury)か、強制終了
     (kill)します。これは、最初にKILL-BUFFERを使用し、2番目の引数として
     選択したウィンドウを使用して呼び出されます。

     それから、ウィンドウが元々Magitバッファを表示するために作成され、隠
     されていた(buried)バッファがウィンドウに表示された最後の残りの
     Magitバッファであった場合、それは削除されます。


File: magit.ja.info,  Node: Automatic Refreshing of Magit Buffers,  Next: Automatic Saving of File-Visiting Buffers,  Prev: Quitting Windows,  Up: Modes and Buffers

4.1.4 Automatic Refreshing of Magit Buffers
-------------------------------------------

現在のリポジトリの状態を変更する可能性のあるコマンドを実行した後で、現在
のMagitバッファと対応するステータスバッファがリフレッシュされます。ステ
ータスバッファは、以下のようにフックを追加することで、バッファがそれぞれ
のリポジトリ内のファイルに保存されるたびに自動的にリフレッシュできます:

     (with-eval-after-load 'magit-mode
       (add-hook 'after-save-hook 'magit-after-save-refresh-status t))

Magitバッファ達を自動的にリフレッシュすると、表示される情報はほとんどの
場合最新であることが保証されますが、大きなリポジトリで顕著な遅延が発生す
る可能性があります。他のMagitバッファ達は、遅延を最小限に抑えるためにリ
フレッシュされません。また、リフレッシュすることが望ましくない場合がある
ためです。

バッファは明示的にリフレッシュすることもできます。これは、Magitの外部で
リポジトリに変更が加えられた後、まだリフレッシュされてない、最新ではなか
ったバッファで役立ちます。

‘g’ (‘magit-refresh’)
     このコマンドは、メジャーモードが‘magit-mode’および対応するステータ
     スバッファから派生している場合、現在のバッファをリフレッシュします
     。

     オプション‘magit-revert-buffers’がそれを要求する場合、現在のリポジ
     トリで追跡されているファイルを訪問するすべての変更されていないバッ
     ファもrvertします。

‘G’ (‘magit-refresh-all’)
     このコマンドは、現在のリポジトリに属するすべてのMagitバッファをリフ
     レッシュし、現在のリポジトリで追跡されているファイルに訪問するすべ
     ての変更されていないバッファをrevertします。

     ‘magit-revert-buffers’がnilの場合でも、file-visitingバッファは常に
     revertされます。

 -- User Option: magit-refresh-buffer-hook
     このフックは、現在リフレッシュ中にリフレッシュされた各Magitバッファ
     (通常は現在のバッファとステータスバッファ)で実行されます。

 -- User Option: magit-refresh-status-buffer
     このオプションがnil以外の場合、現在のMagitバッファに加えて、副作用
     としてgitを実行した後、ステータスバッファが自動的にリフレッシュされ
     ます。これは、常に自動的にリフレッシュされます。

     パフォーマンスを向上させるために他のすべてのオプションを使い果たし
     た後でのみ、これをnilに設定してください。

 -- Function: magit-after-save-refresh-status
     この関数は、‘after-save-hook’に追加することを目的としています。その
     後、リポジトリ内のファイルにバッファが保存されるたびに、対応するス
     テータスバッファがリフレッシュされます。

     Magitバッファのリフレッシュは、その内容を最初から再作成することによ
     って行われることに注意してください。これは、大規模なリポジトリでは
     遅くなる可能性があります。あなたがMagitのパフォーマンスに満足できな
     い場合、明らかにこの関数をそのフックに追加すべきではありません。


File: magit.ja.info,  Node: Automatic Saving of File-Visiting Buffers,  Next: Automatic Reverting of File-Visiting Buffers,  Prev: Automatic Refreshing of Magit Buffers,  Up: Modes and Buffers

4.1.5 Automatic Saving of File-Visiting Buffers
-----------------------------------------------

file-visitingバッファは、デフォルトで特定の時点で保存されます。これは、
Magitバッファが常に最新であることを保証するものではありませんが、Emacsで
のみファイルを編集し、かつ、Magitのみを使用してGitと対話する場合には、か
なり自信があります。それが疑わしい場合や外部での変更後は、
‘g’(‘magit-refresh’)と入力して、明示的に保存およびリフレッシュします。

 -- User Option: magit-save-repository-buffers
     このオプションは、特定のイベントの前にfile-visitingバッファを保存す
     るかどうかを制御します。

     これがnil以外の場合、現在のリポジトリに属するすべての変更された
     file-visitingバッファは、コマンドを実行する前、新しいMagitバッファ
     を作成する前、およびそのようなバッファを明示的にリフレッシュする前
     に保存できます。これが‘dontask’の場合、これはユーザーの介入なしに実
     行されます。‘t’の場合、ユーザーは各保存を確認する必要があります。


File: magit.ja.info,  Node: Automatic Reverting of File-Visiting Buffers,  Prev: Automatic Saving of File-Visiting Buffers,  Up: Modes and Buffers

4.1.6 Automatic Reverting of File-Visiting Buffers
--------------------------------------------------

デフォルトでは、Magitは、Gitリポジトリで追跡されているファイルがディスク
上で変更された後、それらを訪問しているバッファを自動的にrevertします。
Magitを使用する場合、Gitを実行してディスク上のファイルを変更することがよ
くあります。つまり、それは「Emacsの外部」であるため、バッファを自動的に
revertするのはかなり重要な機能です。

たとえば、ステータスバッファの変更を破棄する場合、‘git apply --reverse
...’を実行することでそれが行われ、Emacsはファイルが「ディスク上で変更さ
れた」と見なします。 Magitがバッファを自動的にrevertしなかった場合は、変
更を続行する前に、訪問中のバッファに‘M-x revert-buffer RET RET’と入力す
る必要があります。

 -- User Option: magit-auto-revert-mode
     このモードを有効にすると、追跡中のファイル(tracked files)を訪問した
     バッファは、訪問したファイルがディスク上で変更された後、自動的に
     revertされます。

 -- User Option: global-auto-revert-mode
     このモードを有効にすると、訪問したファイル(visited file)がディスク
     上で変更された後、file-visitingバッファが自動的にrevertされます。

     追跡中のファイル(tracked files)を訪問するバッファを自動的にrevertす
     る場合は、追跡中のファイルを訪問するバッファだけでなく、任意のバッ
     ファをrevertすることもできます。その場合は、
     ‘magit-auto-revert-mode’の_代わり_にこのモードを有効にしてください
     。

 -- User Option: magit-auto-revert-immediately
     このオプションは、Magitがバッファをすぐにrevertするかどうかを制御し
     ます。

     これがnil以外で、‘global-auto-revert-mode’または
     ‘magit-auto-revert-mode’のいずれかが有効になっている場合、Magitは、
     副作用のためにGitを実行した後、‘auto-revert-buffers’を明示的に呼び
     出すことにより、すぐにバッファをrevertします。

     ‘auto-revert-use-notify’がnil以外の場合(およびファイル通知が実際に
     サポートされている場合)、復帰はとにかくすぐに行われるため、
     ‘magit-auto-revert-immediately’をnil以外にする必要はありません。

     ‘magit-auto-revert-immediately’と‘auto-revert-use-notify’が両方とも
     ‘nil’の場合、ユーザーが非アクティブになってから
     ‘auto-revert-interval’秒後にrevertが発生します。それは望ましくあり
     ません。

 -- User Option: auto-revert-use-notify
     このオプションは、ファイル通知機能を使用するかどうかを制御します。
     残念ながら、ファイル通知を使用できないシステムでも、この変数のデフ
     ォルトは‘t’であることに注意してください。

 -- User Option: magit-auto-revert-tracked-only
     このオプションは、‘magit-auto-revert-mode’が追跡されているファイル
     (tracked files)のみをrevertするか、追跡されていないファイル
     (untracked files)やGitの制御ディレクトリ内にあるファイルを含むGitリ
     ポジトリ内にあるすべてのファイルをrevertするかを制御します。

 -- User Option: auto-revert-mode
     グローバルモード‘magit-auto-revert-mode’は、適切なバッファでこのロ
     ーカルモードをオンにすることで機能します(ただし、
     ‘global-auto-revert-mode’の実装は異なります)。手動でオンまたはオフ
     にすることもできます。これは、以前は追跡されてなかったファイルが今
     現在追跡されていることにMagitが気付かない場合、またはその逆の場合に
     必要になることがあります。

 -- User Option: auto-revert-stop-on-user-input
     このオプションは、ユーザーが入力するまで‘auto-revert-interval’秒間
     、自動revertを一時停止(suspend)するかどうかを制御します。

 -- User Option: auto-revert-interval
     このオプションは、一時停止された自動revertを再開する前にEmacsが待機
     する秒数を制御します。

 -- User Option: auto-revert-buffer-list-filter
     このオプションは、‘auto-revert-buffers’がバッファをrevertするかどう
     かを決定するために使用する追加のフィルターを指定します。

     このオプションはMagitによって提供され、‘auto-revert-buffers’にもそ
     れを尊重するようにアドバイスします。ローカルモード
     ‘auto-revert-mode’を自分でオンにしないMagitユーザーは、値を
     ‘magit-auto-revert-repository-buffer-p’に設定するのが最適です。

     ただし、ローカルモードを直接使用するユーザーの邪魔にならないように
     、デフォルトはnilです。Magitコマンドの実行中に遅延が発生した場合は
     、Magitが提供する述語(predicate)の1つを使用することを検討する必要が
     あります。特に、Trampも使用している場合はそうです。

     Magitがオンにしないバッファで‘auto-revert-mode’をオンにするユーザー
     は、フィルターを使用しないでください。‘global-auto-revert-mode’をオ
     ンにするユーザーは、グローバルモードが有効になっている場合は無視さ
     れるため、このオプションについて心配する必要はありません。

 -- User Option: auto-revert-verbose
     このオプションは、バッファがrevertされたときにEmacsがレポートするか
     どうかを制御します。

‘auto-revert-’接頭辞が付いたオプションは、‘auto-revert’という名前のカス
タムグループにあります。他のMagit固有のオプションは、‘magit’グループにあ
ります。

* Menu:

* Risk of Reverting Automatically::  Risk of Reverting Automatically


File: magit.ja.info,  Node: Risk of Reverting Automatically,  Up: Automatic Reverting of File-Visiting Buffers

Risk of Reverting Automatically
...............................

大多数のユーザーにとって、ディスク上で変更された後にfile-visitingバッフ
ァを自動的revertすることは無害です。

バッファが変更された場合(つまり、まだ保存されていない変更が含まれている
場合)、Emacsは自動的にバッファをrevertすることを拒否します。以前に変更さ
れたバッファを保存すると、Gitはコミットされていない変更と見なします。そ
の後、Gitは、これらの変更が失われる原因となるコマンドの実行を拒否します
。言い換えれば、失われる可能性のあるものがある場合、GitまたはEmacsのいず
れかが変更の破棄を拒否します。

ただし、あなたがfile-visitingバッファを一種その場しのぎ(ad hoc)の「ステ
ージ領域」として使用する場合、自動revertによってデータが失われる可能性が
あります。 これまでのところ、このようなワークフローを使用しているユーザ
ーは私が知っている限りでは1人だけです。

例：あなたはバッファ内のファイルを訪問して編集し、変更を保存します。それ
から、Emacsの外部で(または少なくともMagitを使用しないか、バッファを保存
することにより)、ディスク上のファイルを再度変更します。この時点で、バッ
ファは中間バージョンがまだ存在する唯一の場所です。変更をディスクに保存し
ましたが、それ以降は上書きされています。一方、Emacsはバッファが変更され
ていないと見なし(最後に訪問したファイルに保存してから変更を加えていない
ため)、自動的にrevertされることに異議を唱えません。この時点で、自動
revertモードが開始されます。バッファが変更されているかどうかがチェックさ
れ、変更されていないため、バッファがrevertされます。中間バージョンは失わ
れます。(実際には、いまだ、‘undo’コマンドを使用して元に戻る(get it
back)ことができます。)

あなたのワークフローがバッファに中間バージョンを保持するEmacsに依存して
いる場合は、すべての自動revertモードを無効にする必要があります。ただし、
このようなワークフローは、自動revertモードを使用しなくても危険であるため
、回避する必要があることを考慮してください。Emacsがクラッシュしたり、誤
ってEmacsを終了したりすると、バッファの内容も失われます。中間バージョン
がまだ含まれている自動保存ファイルはなく(バッファを保存したときに削除さ
れたため)、バッファを保存するかどうかを尋ねられることはありません(変更さ
れていないため)。


File: magit.ja.info,  Node: Sections,  Next: トランジェントコマンド,  Prev: Modes and Buffers,  Up: Interface Concepts

4.2 Sections
============

Magitバッファはネストされたセクションに編成され、Orgモードでセクションが
処理されるのと同様に、折りたたんだり展開したりできます。各セクションにも
タイプがあり、一部のセクションにも値があります。セクションタイプごとに、
そのタイプのすべてのセクションで共有されるローカルキーマップを作成するこ
ともできます。

セクションの値とタイプを利用して、多くのコマンドが現在のセクションで動作
します。または、リージョンがアクティブで同じタイプのセクションを選択する
と、選択されたすべてのセクションが操作されます。(タイプの違いのみよって
動作が異なるだけではなく)特定のセクションタイプに対してのみ意味のあるコ
マンドは、通常、セクションタイプのキーマップにバインドされます。

* Menu:

* Section Movement::         Section Movement
* Section Visibility::       Section Visibility
* Section Hooks::            Section Hooks
* Section Types and Values::  Section Types and Values
* Section Options::          Section Options


File: magit.ja.info,  Node: Section Movement,  Next: Section Visibility,  Up: Sections

4.2.1 Section Movement
----------------------

セクション内を移動するには、グローバルバインディングが隠蔽されていない通
常のキー(‘C-p’, ‘C-n’, ‘C-b’, ‘C-f’ 等)を使用します。 別のセクションに移
動するには、以下のコマンドを使用します。

‘p’ (‘magit-section-backward’)
     セクションの先頭じゃない場合は、現在のセクションの先頭に移動します
     。セクションの先頭では、前の表示セクションの先頭に移動します。

‘n’ (‘magit-section-forward’)
     次の表示セクションの先頭に移動します。

‘M-p’ (‘magit-section-backward-siblings’)
     前の兄弟セクションの先頭に移動します。 前の兄弟セクションがない場合
     は、代わりに親セクションに移動します。

‘M-n’ (‘magit-section-forward-siblings’)
     次の兄弟セクションの先頭に移動します。 次の兄弟セクションがない場合
     は、代わりに親セクションに移動します。

‘^’ (‘magit-section-up’)
     現在のセクションの親の先頭に移動します。

上記のコマンドはすべて、フック‘magit-section-movement-hook’を呼び出しま
す。以下にリストされている関数のいずれかをこのフックのメンバーとして使用
できます。

あなたは、Magitが‘add-hook’を使用して追加する関数のいくつかを削除したい
と思うかもしれません。その際は、まだ追加されていない関数を削除しようとし
ないようにする必要があります。以下に例を示します。

     (with-eval-after-load 'magit-diff
       (remove-hook 'magit-section-movement-hook
                    'magit-hunk-set-window-start))

 -- Variable: magit-section-movement-hook
     このフックは、上記のすべての移動コマンドににおいて、目的地に到着し
     た後に実行されます。

 -- Function: magit-hunk-set-window-start
     このフック関数は、‘hunk’セクションであれば、現在のセクションの先頭
     が表示されるようにします。それ以外の場合は何もしません。

     ‘magit-diff’をロードすると、この関数がフックに追加されます。

 -- Function: magit-section-set-window-start
     このフック機能により、セクションのタイプに関係なく、現在のセクショ
     ンの先頭が表示されます。これを‘magit-section-movement-hook’に追加す
     る場合は、ハンクのみのバリエーション(hunk-only variant)を順番に削除
     する必要があります。

 -- Function: magit-log-maybe-show-more-commits
     このフック関数はログバッファでのみ効果があり、そして‘point’は"show
     more"(もっと見る)セクションにあります。その場合は、表示されているコ
     ミットの数が2倍になります。

     ‘magit-log’をロードすると、この関数がフックに追加されます。

 -- Function: magit-log-maybe-update-revision-buffer
     ログバッファ内を移動する場合、同じフレームの別のウィンドウにすでに
     表示されている場合、この関数はリビジョンバッファを更新します。

     ‘magit-log’をロードすると、この関数がフックに追加されます。

 -- Function: magit-log-maybe-update-blob-buffer
     ログバッファ内を移動し、同じフレームの別のウィンドウにblobバッファ
     が表示される場合、この関数は代わりに、そのウィンドウ内のポイントで
     のコミットのblobバッファを表示します。

 -- Function: magit-status-maybe-update-revision-buffer
     ステータスバッファ内を移動するとき、同じフレームの別のウィンドウに
     すでに表示されている場合、この関数はリビジョンバッファを更新します
     。

 -- Function: magit-status-maybe-update-stash-buffer
     ステータスバッファ内を移動するとき、同じフレームの別のウィンドウに
     すでに表示されている場合、この関数はスタッシュバッファを更新します
     。

 -- Function: magit-status-maybe-update-blob-buffer
     ステータスバッファ内を移動し、同じフレームの別のウィンドウにblobバ
     ッファが表示される場合、この関数は代わりに、そのウィンドウ内のポイ
     ントでのコミットのblobバッファを表示します。

 -- Function: magit-stashes-maybe-update-stash-buffer
     スタッシュを一覧表示するバッファ内を移動する場合、同じフレームの別
     のウィンドウにすでに表示されている場合、この関数はスタッシュバッフ
     ァを更新します。

 -- User Option: magit-update-other-window-delay
     他のウィンドウを自動的に更新する前に遅延します。

     特定のバッファ内を移動する場合、別のウィンドウに表示されている特定
     の他のバッファをオプションで更新して、その時点のセクションに関する
     情報を表示することができます。

     キーを押したままにして複数のセクションを移動すると、途中でセクショ
     ンごとにそのバッファが更新されます。これを防ぐために、リビジョンバ
     ッファの更新は遅延され、このオプションはそれがどのくらいの長さかを
     制御します。最適なエクスペリエンスを得るには、この遅延やキーボード
     の繰り返し速度、およびグラフィカル環境やオペレーティングシステムの
     遅延を調整する必要がある場合があります。


File: magit.ja.info,  Node: Section Visibility,  Next: Section Hooks,  Prev: Section Movement,  Up: Sections

4.2.2 Section Visibility
------------------------

Magitには、セクションの表示を変更するための多くのコマンドが用意されてい
ますが、開始するために必要なのは次の2つだけです。

‘<TAB>’ (‘magit-section-toggle’)
     現在のセクションの本体の表示を切り替えます。

‘C-<tab>’ (‘magit-section-cycle’)
     現在のセクションとその子の表示を循環させます。

‘M-<tab>’ (‘magit-section-cycle-diffs’)
     現在のバッファ内のdiff-relatedセクションの表示を循環させます。

‘S-<tab>’ (‘magit-section-cycle-global’)
     現在のバッファ内のすべてのセクションの表示を循環させます。

‘1’ (‘magit-section-show-level-1’)
‘2’ (‘magit-section-show-level-2’)
‘3’ (‘magit-section-show-level-3’)
‘4’ (‘magit-section-show-level-4’)
     レベルNまでの現在のセクションを囲むセクションを表示します。

‘M-1’ (‘magit-section-show-level-1-all’)
‘M-2’ (‘magit-section-show-level-2-all’)
‘M-3’ (‘magit-section-show-level-3-all’)
‘M-4’ (‘magit-section-show-level-4-all’)
     レベルNまでのすべてのセクションを表示します。

上記のコマンドを実装するために使用される一部の関数は、コマンド自体として
も公開されます。デフォルトでは、これらのコマンドに結び付けられているキー
はありません。これらのコマンドは、一般的にあまり役に立たないと認識されて
いるためです。しかし、あなたにとっては有益かもしれません。

 -- Command: magit-section-show
     現在のセクションのボディを表示します。

 -- Command: magit-section-hide
     現在のセクションのボディを非表示にします。

 -- Command: magit-section-show-headings
     現在のセクションの子の見出しを再帰的に表示します。見出しのみを表示
     します。以前に表示されたテキストのみのボディは非表示になります。

 -- Command: magit-section-show-children
     現在のセクションの子の体を再帰的に表示します。プレフィックス引数を
     使用すると、現在のセクションのレベルまで子を表示し、より深い子を非
     表示にします。

 -- Command: magit-section-hide-children
     現在のセクションの子のボディを再帰的に非表示にします。

 -- Command: magit-section-toggle-children
     現在のセクションの子のボディの可視性を切り替えます(toggle)。

バッファが最初に作成されると、一部のセクションは展開されて表示されますが
、他のセクションは展開されません。これはハードコーディングされています。
バッファがリフレッシュされると、以前の可視性が保持されます。特定のセクシ
ョンの初期可視性は、フック‘magit-section-set-visibility-hook’を使用して
上書きすることもできます。

 -- User Option: magit-section-initial-visibility-alist
     このオプションを使用して、セクションの初期可視性をオーバーライドで
     きます。将来的には、デフォルトの定義にも使用されますが、現在、セク
     ションのデフォルトはハードコーディングされています。

     値は単一のalistです。各要素は、セクションタイプまたは系統
     (lineage)をそのようなセクションの初期可視状態にマップします。状態は
     、‘show’または‘hide’のいずれか、またはこれらのシンボルの1つを返す関
     数である必要があります。セクションを唯一の引数として関数が呼び出さ
     れます。

     コマンド‘magit-describe-section-briefly’を使用して、セクションの系
     統(lineage)またはタイプを判別します。出力のベクター(vector)はセクシ
     ョン系統(section lineage)であり、タイプはそのベクター(vector)の最初
     の要素です。ワイルドカードを使用できます。‘magit-section-match’を参
     照してください。

 -- User Option: magit-section-cache-visibility
     このオプションは、セクションが消えて後で再び表示された場合に、以前
     の可視性状態を復元するセクションを制御します。値はブール値またはセ
     クションタイプのリストです。tの場合、すべてのセクションの可視性がキ
     ャッシュされます。それ以外の場合、これは、タイプがリストされたタイ
     プの1つと一致するセクションに対してのみ実行されます。

     これには、関数‘magit-section-cached-visibility’が
     ‘magit-section-set-visibility-hook’のメンバーである必要があります。

 -- Variable: magit-section-set-visibility-hook
     このフックは、最初にバッファを作成するとき、および既存のバッファを
     リフレッシュするときに実行され、現在挿入されているセクションの可視
     性を判別するために使用されます。

     各関数は1つの引数で呼び出され、セクションが挿入されます。‘hide’また
     は‘show’を返すか、可視性を未定義の‘nil’のままにする必要があります。
     可視性を決定する関数がなく、バッファがリフレッシュされている場合、
     可視性は保持されます。 または、バッファが作成されている場合は、ハー
     ドコードされたデフォルトが使用されます。

     通常、これは初期の可視性を設定するためにのみ使用する必要があり、リ
     フレッシュ中は使用しないでください。
     ‘magit-insert-section--oldroot’がnil以外の場合、バッファはリフレッ
     シュ済で、これらの関数はすぐに‘nil’を返す必要があります。

 -- User Option: magit-section-visibility-indicator
     このオプションは、セクションを展開/折りたたむことができるかどうか、
     および表示(indicate)方法を制御します。

     nilの場合、可視性インジケータは表示されません。それ以外の場合、値は
     以下の2つの形式のいずれかである必要があります:

        • ‘(EXPANDABLE-BITMAP . COLLAPSIBLE-BITMAP)’

          両方の値は、値がフリンジビットマップ(fringe bitmaps)である変数
          である必要があります。この場合、展開または折りたたむことができ
          るすべてのセクションは、左フリンジ(left fringe)にインジケータ
          ーを取得します。

          インジケーターの周囲に追加のパディングを提供するには、
          ‘magit-mode-hook’で‘left-fringe-width’を設定します。例:

               (add-hook 'magit-mode-hook (lambda ()
                                            (setq left-fringe-width 20)))

        • ‘(STRING . BOOLEAN)’

          この場合、折りたたまれたすべてのセクションの見出しの最後に
          STRING(通常は省略記号)が表示されます。展開されたセクションには
          インジケーターが表示されません。cdrは、これらの省略記号の外観
          がセクションの強調表示を考慮に入れるかどうかを制御します。そう
          しないとパフォーマンスに影響を与える可能性がありますが、そうし
          ないと少し醜いです。


File: magit.ja.info,  Node: Section Hooks,  Next: Section Types and Values,  Prev: Section Visibility,  Up: Sections

4.2.3 Section Hooks
-------------------

どのセクションが特定のバッファーに挿入されるかは、フックで制御されます。
これには、ステータス(status)と参照(refs)バッファが含まれます。他のバッフ
ァの場合、例えば logおよびdiffバッファ、これは不可能です。コマンド
‘magit-describe-section’を使用して、ポイントにセクションを挿入する原因と
なったフック(存在する場合)を確認できます。

ユーザーがセクションをカスタマイズできるバッファの場合、
‘magit-TYPE-sections-hook’というフック変数が存在します。このフックは、
‘magit-add-section-hook’を使用して変更する必要があります。‘add-hooks’ま
たはカスタムインターフェイス(Custom interface)の使用は避けてください。

使用可能なさまざまなセクションフック変数については、このマニュアルの後半
で、適切なセクションインサーター関数とともに説明します。

 -- Function: magit-add-section-hook hook function &optional at append
          local
     セクションフックFOOKの値に関数FUNCTIONを追加します。

     オプションのAPPENDがnil以外の場合を除き、フックリストの最初に
     FUNCTIONを追加します。APPENDがnil以外の場合、最後にFUNCTIONを追加し
     ます。 FUNCTIONがすでにメンバーである場合は、それを新しい場所に移動
     します。

     オプションのATがnil以外で、フックリストのメンバーである場合は、代わ
     りにその脇にFUNCTIONを追加します。 APPENDに応じて、ATの前または後に
     追加するか、ATをFUNCTIONに置き換えます。APPENDがシンボル‘replace’の
     場合、ATをFUNCTIONに置き換えます。APPENDがその他のゼロ以外の値の場
     合は、ATの直後にFUNCTIONを配置します。nilの場合は、ATの直前に
     FUNCTIONを配置します。FUNCTIONがすでにリストのメンバーであるが、
     ATがメンバーでない場合は、FUNCTIONを既に存在する場所に残します。

     オプションのLOCALがnil以外の場合は、フックのグローバル値ではなく、
     バッファローカル値を変更します。 これにより、デフォルト値をコピーし
     てフックがローカルになります。次に、そのコピーが変更されます。

     HOOKはシンボルであるべきです。HOOKが無効の場合、最初にnilに設定され
     ます。HOOKの値は単一のフック関数であってはなりません。FUNCTIONは、
     引数をとらず、ポイントに1つまたは複数のセクションを挿入して、ポイン
     トを前方に移動する関数である必要があります。FUNCTIONは、そうする意
     味がない場合に、セクションを挿入しないことを選択する場合があります
     。それは他の副作用のために乱用されるべきではありません。

セクションフックから関数を削除するには、‘remove-hook’を使用します。


File: magit.ja.info,  Node: Section Types and Values,  Next: Section Options,  Prev: Section Hooks,  Up: Sections

4.2.4 Section Types and Values
------------------------------

各セクションには、例えば‘hunk’、‘file’、‘commit’などのタイプがあります。
特定のセクションタイプのインスタンスにも値があります。たとえば、タイプ
‘file’のセクションの値は、ファイル名です。

ユーザーは通常、セクションのタイプと値について心配する必要はありませんが
、それらを知っていると便利な場合があります。

‘H’ (‘magit-describe-section’)
     このコマンドは、別のバッファ内のポイントのセクションに関する情報を
     表示します。

 -- Command: magit-describe-section-briefly
     このコマンドは、エコー領域のポイントのセクションに関する情報を
     ‘#<magit-section VALUE [TYPE PARENT-TYPE...] BEGINNING-END>’として
     表示します。

多くのコマンドは、ポイントのある場所でのセクションのタイプに応じて異なる
動作をしたり、何らかの形でそのセクションの値を消費したりします。しかし、
それは、現在のセクションに応じて、同じキーが異なることを行う可能性がある
理由の1つにすぎません。

さらに、セクションタイプごとに、‘magit-TYPE-section-map’という名前のキー
マップを定義できます。そのキーマップは、それぞれのタイプの任意のセクショ
ンに属するすべてのテキストのテキストプロパティキーマップとして使用されま
す。そのようなマップが特定のタイプに存在しない場合、あなたが自分で定義す
ることができ、そしてそれが自動的に使用されます。


File: magit.ja.info,  Node: Section Options,  Prev: Section Types and Values,  Up: Sections

4.2.5 Section Options
---------------------

このセクションでは、特定のタイプのセクション以外にも影響を与えるオプショ
ンについて説明します。以下ご覧のとおり、そんなに多くはありません。

 -- User Option: magit-section-show-child-count
     セクションの見出しに子の数を追加するかどうか。これは、この情報の恩
     恵を受ける可能性のあるセクションにのみ影響します。


File: magit.ja.info,  Node: トランジェントコマンド,  Next: Transient Arguments and Buffer Variables,  Prev: Sections,  Up: Interface Concepts

4.3 トランジェントコマンド
==========================

多くのMagitコマンドは、*トランジェント*(一時的)コマンドとして実装されて
います。 最初に、ユーザーが*プレフィックス*(接頭辞)コマンドを呼び出すと
、*インフィックス*(中置)引数達と*サフィックス*(後置)コマンド達がエコー領
域に表示されます。次に、ユーザーはオプションでいくつかのインフィックス
(中置)引数を設定し、最後にサフィックス(接尾辞)コマンドのどれか1つを呼び
出します。

これは、ライブラリ‘transient’で実装されています。 以前のMagitリリースで
は、パッケージ‘magit-popup’、さらに以前のバージョンではライブラリ
‘magit-key-mode’を使用していました。

transientの文書はこちらを参照して下さい(*note (transient)Top::)。

‘C-c C-c’ (‘magit-dispatch’)
     このトランジェント(一時的)プレフィックス(接頭辞)コマンドは、Magitの
     他のプレフィックスコマンドのほとんどをサフィックス(後置)コマンドと
     して結び付け、そのうちの1つが呼び出されるまで一時バッファ(temporary
     buffer)に表示します。このようなサブプレフィックスを呼び出すと、
     ‘magit-dispatch’のではなく、そのコマンドのサフィックスコマンドが結
     び付けられて表示されます。

このコマンドは、Magitバッファの外部でも特に便利なので、グローバル・バイ
ンディングを設定すべきです:

     (global-set-key (kbd "C-x M-g") 'magit-dispatch)


File: magit.ja.info,  Node: Transient Arguments and Buffer Variables,  Next: Completion Confirmation(確認補完)とSelection(選択範囲),  Prev: トランジェントコマンド,  Up: Interface Concepts

4.4 Transient Arguments and Buffer Variables
============================================

Magitのトランジェント(一時的)プレフィックス(接頭辞)コマンドコマンドの多
くのインフィックス(中置)引数は、それらのインフィックス引数で呼び出した
‘git’コマンドから帰って来ると、効果がなくなります。コミットを作成するコ
マンドは、この良い例です。ユーザーがインフィックス引数を変更した場合、そ
れはそれに続くサフィックス(接尾辞)コマンドの呼び出しにのみ影響します。同
じトランジェントプレフィックスコマンドが後で再度呼び出された場合、インフ
ィックス引数は最初にデフォルト値にリセットされます。このデフォルト値は、
現在のEmacsセッションに設定することも、永続的に保存することもできます
(*note (transient)Saving Values::)。 ‘C-M-p’と‘C-M-n’を使用して、以前に
使用した引数のセットを循環させることもできます(*note (transient)Using
History::)。

ただし、他の多くのトランジェントコマンドのインフィックス引数は、それらの
インフィックス引数で呼び出した‘git’コマンドから帰った後でも引き続き有効
です。このようなコマンドで最も重要なのは、専用のバッファにdiffやログを表
示したりするコマンドです。それぞれのdiffまたはログが表示されている限り、
それらの引数は明らかに効果を持ち続けます。さらに、使用された引数は、将来
の参照のためにバッファローカル変数に格納されます。

後者の場合、トランジェントコマンドが再度呼び出されたときに、それらの引数
をグローバル値にリセットすることが常に望ましいとは限りません。

上記のように、トランジェントなポップアップが表示されている間に、以前に使
用された引数のセットを循環させることができます。つまり、既存のバッファで
アクティブになっている引数のセットは‘C-M-p’の数個しか離れていないため、
インフィックス(中置)引数を常にデフォルトにリセットできます。Magitはその
ように動作するように構成できますが、ほとんどのユーザーにとってはそれほど
便利ではないと思うので、デフォルトではありません。

また、‘D’と‘L’でそれぞれの"refresh"トランジェントプレフィックスコマンド
を使用して、現在のバッファ(diffセクションとlogセクションの両方を含むステ
ータスバッファを含む)で使用されるdiff引数とlog引数を変更できることにも注
意してください。(一方、‘d’と‘l’は、diffまたはログの表示方法を変更するこ
とを*目的*としています。diffまたはログの*表示方法*を同時に変更することも
できますが、後者のみを実行する場合は、refreshのバリエーションを使用する
必要があります。）これらのセカンダリdiffおよびlogトランジェントプレフィ
ックスコマンドは、現在のバッファで使用される引数の*変更*に関するものであ
るため、常に、そのバッファで現在有効な引数のセットから開始します。

一部のコマンドは、トランジェントプレフィックスコマンドのサフィックスコマ
ンドとして呼び出すこともできますが、通常は直接呼び出されます。その典型は
‘magit-show-commit’で、通常、ポイントがログのコミット中に‘RET’と入力する
ことで呼び出されますが、‘magit-diff’トランジェントプレフィックスコマンド
から呼び出すこともできます。

このようなコマンドを直接呼び出す場合は、デフォルトの引数を使用するのでは
なく、それぞれのバッファローカル値で指定された引数を再利用することが重要
です。 logで‘RET’を押して別のバッファ内のポイントでcommitを表示し、次に
‘D’を使用してそのバッファでのdiffの表示方法を変更するとします。次に、別
のcommitで‘RET’を押して、代わりにdiff引数がデフォルトにリセットされるこ
とを示します。クールじゃありません。したがって、Magitはデフォルトではそ
れを行いません。

 -- User Option: magit-prefix-use-buffer-arguments
     このオプションは、特定のトランジェントプレフィックスコマンドで最初
     に表示されるインフィックス引数が、サフィックスコマンドが更新するバ
     ッファで現在有効な引数に基づいているかどうかを制御します。

     ‘magit-diff’および‘magit-log’のトランジェントプレフィックスコマンド
     は、このオプションの影響を受けます。

 -- User Option: magit-direct-use-buffer-arguments
     このオプションは、特定のコマンドが直接呼び出されたときに(つまり、ト
     ランジェントプレフィックスコマンドのサフィックスコマンドとしてでは
     なく)、更新しようとしているバッファで現在アクティブな引数を使用する
     かどうかを制御します。代替手段は、これらの引数にデフォルト値を使用
     することで、これにより、バッファで使用される引数が変更される可能性
     があります。

上記の両方のオプションの有効な値は以下のとおりです:

   • ‘always’: もちろんバッファが存在する場合は、それぞれのバッファで現
     在アクティブな引数のセットを常に使用します。
   • ‘selected’または‘t’: それぞれのバッファからの引数のセットを使用しま
     すが、それが現在のフレームのウィンドウに表示されている場合に限りま
     す。これは、両方の変数のデフォルトです。
   • ‘current’: それぞれのバッファからの引数のセットを使用しますが、それ
     が現在のバッファ(current buffer)である場合に限ります。
   • ‘never’: それぞれのバッファーからの引数のセットを使用しないでくださ
     い。

私はそれがさらに複雑になるのではないかと心配しています:

   • グローバルのdiffおよびlog引数は、サポートされているモードごとに個別
     に設定されます。たとえば、diff引数は、‘magit-diff-mode’、
     ‘magit-revision-mode’、‘magit-merge-preview-mode’および
     ‘magit-status-mode’バッファで異なる値を持ちます。あるモードの値を設
     定または保存しても、他のモードの値は変更されません。ただし、履歴は
     共有されます。

   • ‘magit-show-commit’がログバッファから直接呼び出されると、ファイルフ
     ィルターは、リビジョンバッファやモードのグローバルdiff引数からでは
     なく、そのバッファから取得されます。

   • これらはdiff用トランジェントプレフィックスコマンドに従うサフィック
     スコマンドですが、‘magit-show-commit’と‘magit-stash-show’は、diffコ
     マンドで使用されるdiffバッファを使用せず、代わりに専用のリビジョン
     バッファとstashバッファを使用します。

     diff用トランジェントプレフィックスコマンドを呼び出すとき、どのサフ
     ィックスコマンドを呼び出すかはMagitにはわかりません。確かではありま
     せんが、多くの場合、ユーザーはdiffバッファを使用するコマンドのいず
     れかを呼び出すため、最初のインフィックス引数はそのバッファで使用さ
     れるものです。ただし、これらのコマンドの1つを直接呼び出すと、
     Magitはリビジョンのそれぞれのスタッシュバッファからの引数を使用する
     必要があることを認識します。

   • ログ用トランジェントプレフィックスコマンドにはreflogコマンドもあり
     ますが、これらのコマンドはログ引数を使用しません。

   • ‘magit-show-refs’が‘magit-refs-mode’バッファから呼び出された場合、
     それはrefreshトランジェントプレフィックスコマンドとして機能するため
     、バッファの引数を初期引数として無条件に使用します。プレフィックス
     引数を使用して他の場所で呼び出された場合は通常のプレフィックスとし
     て機能するため、‘magit-prefix-use-buffer-arguments’を尊重します。プ
     レフィックス引数なしで他の場所で呼び出された場合、直接コマンドとし
     て機能するため、‘magit-direct-use-buffer-arguments’を尊重します。


File: magit.ja.info,  Node: Completion Confirmation(確認補完)とSelection(選択範囲),  Next: Mouse Support,  Prev: Transient Arguments and Buffer Variables,  Up: Interface Concepts

4.5 Completion(補完)とConfirmation(確認)とSelection(選択範囲)
=============================================================

* Menu:

* アクションの確認::  アクションの確認
* 補完と確認::          補完と確認
* 選択範囲::             選択範囲
* ハンク内部リージョン::  ハンク内部リージョン
* 補完フレームワークのサポート::  補完フレームワークのサポート
* 追加の補完オプション::  追加の補完オプション


File: magit.ja.info,  Node: アクションの確認,  Next: 補完と確認,  Up: Completion Confirmation(確認補完)とSelection(選択範囲)

4.5.1 アクションの確認
----------------------

デフォルトでは、データ損失につながる可能性のある多くのアクションを確認す
る必要があります。これには多くの非常に一般的なアクションが含まれるため、
これはすぐに煩わしくなります。これらのアクションの多くは元に戻す(undo)こ
とができるので、あなたが特定の間違いを元に戻す方法を考えている場合は、そ
れぞれのアクションの確認を無効にしても安全です。

オプション‘magit-no-confirm’を使用すると、ユーザーが確認しなくても特定の
アクションを実行するようにMagitに指示できます。このオプションは特定のア
クションセットの確認を無効にするためにのみ使用できますが、次節では、
Magitに質問を少なくするように指示する別の方法について説明します。

 -- User Option: magit-no-confirm
     このオプションの値はシンボルのリストであり、実行する前にユーザーが
     確認する必要のないアクションを表します。

     デフォルトでは、多くの潜在的に危険なコマンドがユーザーに確認を求め
     ます。以下の各シンボルは、意図せずに、または結果を完全に認識せずに
     呼び出された場合に、涙を流す可能性のあるアクションを表しています。
     多くの場合、特定のアクションのバリエーションを実行するコマンドがい
     くつかあるため、コマンド名ではなく、より一般的なシンボルを使用しま
     す。

        • 変更の適用(applying changes):

             • ‘discard’ 1つ以上の変更(つまり、ファイルのハンクまたは完
               全なdiff)を破棄すると、明らかにその変更が失われます。

             • ‘reverse’ 1つ以上の変更をrevertするには、通常、
               reversionのrevertによって元通り(undo)にすることができます
               。

             • ‘stage-all-changes’, ‘unstage-all-changes’ ステージされた
               変更とステージされていない変更の両方がある場合、すべての
               ステージを解除/ステージすると、その区別が失われます。もち
               ろん、これは単一の変更をステージ解除/ステージする場合にも
               当てはまりますが、失われるものは少なく、頻繁に行うため、
               毎回確認する必要はありません。

        • ファイル(files):

             • ‘delete’ Gitによってまだ追跡されていないファイルが削除さ
               れると、最後の変更だけでなく、全てが完全に失われます。大
               変危険です。

             • ‘trash’ ファイルを削除する代わりに、システムのゴミ箱に移
               動することもできます。明らかに、それを削除するよりもはる
               かに危険が少ないです。

               オプション‘magit-delete-by-moving-to-trash’もご覧ください
               。

             • ‘resurrect’ 削除されたファイルは、最初に同じファイルを削
               除するために使用されたのと同じコマンドを使用して実行され
               る削除を「削除」することにより、簡単に復活させることがで
               きます。

             • ‘untrack’ ファイルの追跡解除(untracking)は、ファイルを再
               度追跡(tracking)することで元に戻す(undo)ことができます。

             • ‘rename’ ファイルの名前変更は簡単に元に戻す(undo)ことがで
               きます。

        • 一連の処理(sequences):

             • ‘reset-bisect’ bisect操作を中止(abort)すると(Gitでは「リ
               セット」と呼ばれます)、これまでに収集されたすべての情報が
               失われます。

             • ‘abort-rebase’ リベースを中止(abort)すると、すでに変更さ
               れたすべてのコミットが破棄されますが、reflogからそれらを
               復元することは可能です。

             • ‘abort-merge’ マージを中止(abort)すると、ユーザーがすでに
               実行したすべての競合解決(conflict resolution)が破棄されま
               す。

             • ‘merge-dirty’ ダーティなワークツリーとマージすると、マー
               ジが開始される前の状態に戻るのが難しくなる可能性がありま
               す。

        • 参照(refernces):

             • ‘delete-unmerged-branch’ ブランチが削除されると、Gitが提
               供する低レベルのリカバリツールを使用してのみ復元できます
               。そしてそれでもreflogはなくなってしまいます。ユーザーは
               常にデフォルトの選択を受け入れる(または別のブランチを選択
               する)ことによってブランチの削除を確認する必要がありますが
               、ブランチがまだマージされていない場合は、ユーザーがそれ
               を認識していることも確認してください。

             • ‘delete-pr-remote’ プルリクエストから作成されたブランチを
               削除するときに、そのリモートに他のブランチがまだ存在しな
               い場合、‘magit-branch-delete’はリモートも削除するように提
               案します。これは、リモート名前空間(remotes namespace)に他
               の参照が存在しない場合にのみ発生し、必要に応じてリモート
               を再作成できるため、安全であるはずです。

             • ‘drop-stashes’ Gitはスタッシュをreflogに保存するため、ス
               タッシュを削除するのは危険です。スタッシュが削除されると
               、Gitが提供する低レベルのリカバリツールを使用せずに戻すこ
               とはできません。単一のスタッシュがドロップされた場合、ユ
               ーザーは常にデフォルトを受け入れる(または別のスタッシュを
               選択する)ことによって確認する必要があります。このアクショ
               ンは、一度に複数のスタッシュを削除する場合のみ関係します
               。

        • 公開(publishing):

             • ‘set-and-push’ アップストリームまたはプッシュリモートにプ
               ッシュし、それが実際にはまだ構成されていない場合、ユーザ
               ーは最初にターゲットを設定できます。デフォルトの確認が速
               すぎると、間違ったブランチにプッシュしてしまう可能性があ
               り、リモートリポジトリがそのような間違いの修正を許可しな
               いように構成されている場合、それは非常にどぎまぎして胸糞
               悪いことになる可能性があります。

        • 公開の歴史を編集(edit published history):

          ここにこれらのシンボルを追加しないと、
          ‘magit-published-branches’にリストされているブランチの1つにす
          でにプッシュされているコミットを編集する前に警告が表示されます
          。

             • ‘amend-published’「HEAD」を修正するほとんどのコマンドに影
               響します。

             • ‘rebase-published’ 対話的なリベースを実行するコマンドに影
               響します。これには、「HEAD」以外のコミットを変更する、つ
               まみぐいコミット(commit transient)なコミットからのコマン
               ド、つまりさまざまなfixupとsquashのバリエーションが含まれ
               ます。

             • ‘edit-published’ コマンド‘magit-edit-line-commit’および
               ‘magit-diff-edit-hunk-commit’に影響します。これらの2つの
               コマンドを使用すると、公開されたコミット(published
               commit)を誤って編集することが非常に簡単になるため、確認を
               求めないように構成する前に、よく考えておく必要があります
               。

          確認を完全に無効にするには、ここに3つのシンボルすべてを追加す
          るか、‘magit-published-branches’を‘nil’に設定します。

        • その他(various):

             • ‘kill-process’ プロセスを強制終了する理由はめったにありま
               せん。

        • グローバル設定(global settings):

          このオプションの値に上記のすべてのシンボルを追加する代わりに、
          アトム‘t’に設定することもできます。これは、上記のすべてのシン
          ボルを追加するのと同じ効果があります。特に他のシンボルが将来追
          加される可能性があるため、これを行うことは間違いなく悪い考えで
          す。したがって、これらのアクションのいずれについても確認を求め
          られたくない場合でも、それぞれのシンボルをすべて個別に追加する
          ことをお勧めします。

          ‘magit-wip-before-change-mode’が有効になっている場合、
          ‘discard’と‘reverse’と‘stage-all-changes’と
          ‘unstage-all-changes’アクションはかなり簡単に元に戻すことがで
          きます。このモードが有効になっている場合にのみ、
          ‘safe-with-wip’はこれらのシンボルをすべて個別に追加するのと同
          じ効果があります。


File: magit.ja.info,  Node: 補完と確認,  Next: 選択範囲,  Prev: アクションの確認,  Up: Completion Confirmation(確認補完)とSelection(選択範囲)

4.5.2 補完と確認
----------------

多くのMagitコマンドは、ユーザーに、実行可能なもののリストから選択するよ
うに求めますが、デフォルトとして最も可能性の高い選択肢を提供します。これ
らのコマンドの多くでは、実際に実行することできるという条件のものが提供さ
れ、デフォルトはその時点でのものです。ブランチに作用する多くのコマンドで
は、ポイントにブランチがない場合、現在のブランチがデフォルトになります。

これらのコマンドは、確認(confirm)を求めることと、アクションを実行するタ
ーゲットを求めることを組み合わせて1つのアクションにします。ユーザーは、
‘RET’を使用してデフォルトのターゲットを確認するか、‘C-g’を使用して中止
(abort)することができます。これは‘y-or-n-p’プロンプトに似ていますが、確
認(confirm)または中止(abort)するためのキーが異なります。

同時に、ユーザーには別のターゲットを選択する機会も与えられます。これは、
コマンドや状況によっては、ターゲットに移動して選択する前にアクションを選
択したい場合があるため便利です。

けれども、一部のコマンドでは、デフォルトのターゲットがあればそれを常に使
用したい場合や、確認をまったく必要とせずにコマンドをデフォルトで動作させ
たい場合もあります。オプション‘magit-dwim-selection’を使用して、その効果
をもたらす特定のコマンドを構成できます。

リージョンがアクティブな場合、多くの場合、確認を求めた後、リージョンに基
づくメカニズムを使用して選択されたものに多くのコマンド達が作用することに
注意してください。このリージョンベースのメカニズムは「selection」(選択状
態)と呼ばれ、次節で詳しく説明します。呼び出されたコマンドに有効な
selectionが存在する場合、そのコマンドは他の何かに作用することを提案する
ことはなく、確認を求めるかどうかはこのオプションによって制御されません。

また、Magitは、補完(completion)(または選択状態(selection))と結び付けられ
ていない特定のアクションの確認を要求することにも注意してください。前節で
説明したように、このようなダイアログもこのオプションの影響を受けません。

 -- User Option: magit-dwim-selection
このオプションを使用すると、確認の有無にかかわらず、アクションを実行する
候補をユーザーに選択する代わりに、特定のコマンドにそのポイントでそれを使
用するように指示できます。

値の形式は‘((COMMAND nil|PROMPT DEFAULT)...)’です。

   • COMMANDは、選択を求めるプロンプトを表示してはならないコマンドです。
     効果を得るには、コマンドで関数‘magit-completing-read’を使用するか、
     ユーティリティ関数を使用してその関数を使用する必要があります。

   • コマンドが‘magit-completing-read’を複数回使用する場合、PROMPTは、こ
     れらの使用の1つにのみ影響を与えるために使用できます。PROMPTは、
     nil以外の場合、‘magit-completing-read’に渡されるPROMPT引数と照合す
     るために使用される正規表現です。

   • DEFAULTは、デフォルトの使用方法を指定します。‘t’の場合、
     ‘magit-completing-read’に渡されたDEFAULT引数が確認なしで使用されま
     す。‘ask’の場合、ユーザーは中止する機会が与えられます。DEFAULTは
     ‘nil’にすることもできます。この場合、エントリは効果がありません。


File: magit.ja.info,  Node: 選択範囲,  Next: ハンク内部リージョン,  Prev: 補完と確認,  Up: Completion Confirmation(確認補完)とSelection(選択範囲)

4.5.3 選択範囲
--------------

リージョンがアクティブな場合、多くのMagitコマンドは、単一のものではなく
、リージョンに基づくメカニズムを使用して選択されたもの達に作用します。リ
ージョンがアクティブでない場合、これらのコマンドはそのポイントでモノに作
用するか、作用する単一のモノを読み取ります。これについては前節で説明しま
した。この節では、複数のものを選択する方法、それを視覚化する方法、および
その場合の特定のコマンドの動作についてのみ説明します。

複数のもの、またはこれらを表すセクションを選択するためのMagitのメカニズ
ムは、Emacsリージョンに基づいていますが、Magitが選択したと見なす領域は通
常、リージョンよりも大きく、追加の制限が適用されます。

Magitは、有効なMagit選択範囲(selection)を形成する資格があるリージョンと
そうでないリージョンを区別します。リージョンが適格でない場合は、他の
Emacsバッファと同じように表示されます。リージョンがMagitの選択範囲として
適格である場合、その選択範囲は常に視覚化されますが、リージョン自体は、同
じ行で開始および終了する場合にのみ視覚化されます。

リージョンがMagitの選択範囲(selection)として適格であるためには、そのリー
ジョンは1つのセクションの見出しで始まり、兄弟セクションの見出しで終わる
必要があります。リージョンの終わりがセクション見出しの最初(つまり、行の
最初の桁位置)にある場合、そのセクションは選択範囲の「内側」と見なされる
ことに注意してください。

これは、リージョンがEmacsで通常どのように扱われるかと一致していません。
Emacsリージョンが行の先頭で終了する場合、その行はEmacsリージョンの外側に
あります。Magitが選択範囲を視覚化する方法により、この違いが存在すること
は明らかです。

すべてのコマンドがすべての有効な選択範囲に作用するわけではありません。一
部のコマンドはポイントの位置さえ考慮しません。他のコマンドはポイントでセ
クションに作用しますが、選択範囲に作用することをサポートしません。もちろ
ん、選択範囲をサポートするコマンドでさえ、作用できるものを選択する場合に
のみそうします。

これが、選択範囲にポイントのセクションを含める必要がある主な理由です。選
択範囲が存在する場合でも、呼び出されたコマンドはそれを無視する場合があり
ます。その場合、現在のセクションにのみ作用する可能性があります。選択した
セクションの「代わりに」現在のセクションに作用するよりも、現在のセクショ
ンにのみ作用し、他の選択したセクションには作用しない方がはるかに安全です
。後者の方がはるかに驚くべきことであり、現在のセクションが常に選択範囲の
一部である場合、それは起こり得ません。

 -- Variable: magit-keep-region-overlay
     この変数は、有効なMagit選択範囲またはハンク内部リージョンが存在する
     場合でも、リージョンを通常どおりに視覚化するかどうかを制御します。
     詳細については、doc-stringを参照してください。


File: magit.ja.info,  Node: ハンク内部リージョン,  Next: 補完フレームワークのサポート,  Prev: 選択範囲,  Up: Completion Confirmation(確認補完)とSelection(選択範囲)

4.5.4 ハンク内部リージョン
--------------------------

前節で説明したMagitの選択範囲にいくらか関連しているのは、ハンク内部リー
ジョンです。

選択範囲と同様に、ハンク内部リージョンはEmacsリージョンに基づいています
が、そのリージョンは他のEmacsバッファの場合のように視覚化されず、そして
、そのリージョンの行の最初で終了しても、そのリージョンにはその行の終わり
までが含まれます。

1つのセクションの見出しで始まり、兄弟セクションのセクションで終わるリー
ジョンに基づく選択状態とは異なり、ハンク内部リージョンは、ハンクセクショ
ンの「ボディ」内で始まり、そのセクションのボディ内で終わる必要があります
。

ハンク内部リージョンは、"apply"コマンドによって尊重されます。このコマン
ドは、他のターゲットの中でも、ハンクに作用することができます。 ハンク内
部リージョンがアクティブな場合、そのようなコマンドは、ハンク全体ではなく
、ハンク中のマークされた部分にのみ作用します。


File: magit.ja.info,  Node: 補完フレームワークのサポート,  Next: 追加の補完オプション,  Prev: ハンク内部リージョン,  Up: Completion Confirmation(確認補完)とSelection(選択範囲)

4.5.5 補完フレームワークのサポート
----------------------------------

組み込みオプション‘completing-read-function’は、‘completing-read’がユー
ザーに選択肢のリストから選択するように求めるために使用する低レベル関数を
指定します。デフォルト値は‘completing-read-default’です。代替の補完フレ
ームワークは通常、独自の実装で置き換えることによってそれ自体をアクティブ
にします。

主に歴史的な理由から、Magitは‘magit-completing-read-function’という名前
の同様のオプションを提供します。これは、‘magit-completing-read’によって
使用される低レベル関数のみを制御します。このオプションを使用すると、
Magitで他のEmacsとは異なる補完メカニズムを使用することもできますが、これ
を行うことはお勧めしません。

ほとんどの場合、代替の補完フレームワークを使用するためにmagit固有のオプ
ションをカスタマイズする必要はありません。 たとえば、‘ivy-mode’を有効に
すると、Magitはそれを尊重し、‘helm-mode’を有効にすると、それも補完します
。

ただし、Idoを使用する場合は、‘ido-mode’ではうまくいきません。
‘ido-completing-read+’パッケージもインストールしなければなりません。そし
て‘magit-ido-completing-read’を‘magit-completing-read-function’として使
用する必要があります。

 -- User Option: magit-completing-read-function
     この変数の値は、(組み込みの‘completing-read’ではなく)
     ‘magit-completing-read’を使用するコードによる補完を実行するために使
     用される低レベル関数です。

     デフォルト値の‘magit-builtin-completing-read’は、少なくとも標準の補
     完メカニズムである‘ivy-mode’と‘helm-mode’に適しています。

     組み込みの‘completing-read’と‘completing-read-default’は、ここでの
     使用には「適していません」。‘magit-builtin-completing-read’はいくつ
     かの追加作業を実行し、その場所で使用される関数はすべて同じことを実
     行する必要があります。

 -- Function: magit-builtin-completing-read prompt choices &optional
          predicate require-match initial-input hist def
     この関数は、組み込みの‘completing-read’を使用して補完を実行し、
     magit固有の追加の作業を実行します。

 -- Function: magit-ido-completing-read prompt choices &optional
          predicate require-match initial-input hist def
     この関数は、(明示的にインストールする必要がある)同じ名前のパッケー
     ジから‘ido-completing-read+’を使用して補完を実行し、さらにいくつか
     のmagit固有の作業を実行します。

     Ido自体に付属している‘ido-completing-read’の代わりに
     ‘ido-completing-read+’を使用する必要があります。後者は、drop-in代替
     として意図されていますが、その目的を果たすことができないためです。
     それは暗黙の規則の多くに違反しています。

 -- Function: magit-completing-read prompt choices &optional predicate
          require-match initial-input hist def fallback
     これは、Magitコマンドが、ユーザーが操作するものを1つ選択する必要が
     ある場合に使用する機能です。引数の意味は、‘completing-read’の場合と
     同じですが、FALLBACKはこの関数に固有ですので以下で説明します。

     この関数は、可能な候補のリストから選択するようにユーザーに求める代
     わりに、ユーザーの確認を必要とするかどうかに関係なく、DEFで指定され
     たデフォルトを返すだけの場合があります。それが当てはまるかどうかは
     、PROMPTと‘this-command’と‘magit-dwim-selection’によって異なります
     。 詳細については後述します。

     ミニバッファの値を読み取る場合、この関数は‘completing-read’と同様に
     機能しますが、以下の点が異なります:

        • COLLECTIONは選択肢のリストでなければなりません。関数はサポート
          されていません。

        • REQUIRE-MATCHが‘nil’であり、ユーザーが選択せずに終了した場合、
          空文字列の代わりに‘nil’が返されます。

        • REQUIRE-MATCHがnil以外で、ユーザーが選択せずに終了した場合、ユ
          ーザーエラー(user-error)が発生(raise)します。

        • FALLBACKは、一次デフォルトDEFが‘nil’の場合にのみ使用される二次
          デフォルトを指定します。 二次デフォルトは
          ‘magit-dwim-selection’の対象ではありません。DEFが‘nil’であるが
          、FALLBACKがそうでない場合、この関数は、両方のデフォルトが
          ‘nil’であるかのように、常にユーザーに候補を選択するように求め
          ます。

        • ": " がPROMPTに追加されます。

        • PROMPTは、\" (default DEF|FALLBACK): \"で終わるように変更され
          ます。ただし、DEFまたはFALLBACKがnil以外であり、‘ivy-mode’も
          ‘helm-mode’も有効になっていない場合、
          ‘magit-completing-read-function’は、デフォルト値の
          ‘magit-builtin-completing-read’に設定されています。


File: magit.ja.info,  Node: 追加の補完オプション,  Prev: 補完フレームワークのサポート,  Up: Completion Confirmation(確認補完)とSelection(選択範囲)

4.5.6 追加の補完オプション
--------------------------

 -- User Option: magit-list-refs-sortby
     ユーザーから1つまたは複数の参照(ref)を読み取る多くのコマンドでは、
     このオプションの値を使用して、参照(refs)の順序を制御できます。有効
     な値には、‘git for-each-ref’の‘--sort’フラグで受け入れられるすべて
     のキーが含まれます。デフォルトでは、参照(ref)はフルネームのアルファ
     ベット順に並べ替えられます(例: "refs/heads/master")。


File: magit.ja.info,  Node: Mouse Support,  Next: Running Git,  Prev: Completion Confirmation(確認補完)とSelection(選択範囲),  Up: Interface Concepts

4.6 Mouse Support
=================

セクションの見出しをダブルクリックすると、その本文の可視性が切り替えられ
ます (存在する場合)。 同様に、左フリンジをクリックすると、適切なセクショ
ンの表示に切り替わります。

コンテキスト メニューが提供されますが、明示的に有効にする必要があります
。 Emacs 28 以降で、グローバル モード ‘context-menu-mode’ を有効にします
。 古い Emacs リリースを使用している場合は、
‘magit-section-show-context-menu-for-emacs<28’ を設定します。


File: magit.ja.info,  Node: Running Git,  Prev: Mouse Support,  Up: Interface Concepts

4.7 Running Git
===============

* Menu:

* Viewing Git Output::       Viewing Git Output
* Git Process Status::       Git Process Status
* Gitを手動で実行::    Gitを手動で実行
* Git実行ファイル::    Git実行ファイル
* Global Git Arguments::     Global Git Arguments


File: magit.ja.info,  Node: Viewing Git Output,  Next: Git Process Status,  Up: Running Git

4.7.1 Viewing Git Output
------------------------

Magitは、副作用(プッシュ時など)または何らかの値(現在のブランチの名前など
)を得るためにGitを実行します。

副作用のためにGitを実行すると、プロセス出力はリポジトリごとのログバッフ
ァに記録されます。これが期待どおりに進まない場合には‘magit-process’コマ
ンドを使用して参照できます。

最大‘magit-process-log-max’個のGitコマンドの 出力/エラー が保持されます
。

‘$’ (‘magit-process’)
     このコマンドは、現在のリポジトリのプロセスバッファを表示します。

そのバッファ内では、セクションをナビゲートおよび表示するための通常のキー
バインディングが利用可能です。これらに追加のコマンドが1つあります。

‘k’ (‘magit-process-kill’)
     このコマンドは、ポイントしているセクションで表されるプロセスを強制
     終了します。

 -- Variable: magit-git-debug
     このオプションは、gitエラーの追加レポートを有効にするかどうかを制御
     します。

     Magitは基本的に次の2つの理由のいずれかでgitを呼び出します: 副作用の
     ため、または標準出力を使って何かをするためです。

     gitが副作用のために実行されると、エラーメッセージを含むその出力は、
     ‘$’を使用したときに表示されるプロセスバッファに送られます。

     gitの出力が何らかの方法で消費されると、それもこのバッファに挿入する
     にはコストがかかりすぎますが、このオプションがnil以外で、gitがゼロ
     以外の終了ステータスで返される場合、少なくともこのバッファにその標
     準エラーが挿入されます。

     これは、デバッグのみを目的としています。これを永続的に有効にしない
     でください。パフォーマンスに悪影響を及ぼします。

     これは、デバッグのみを目的としています。 これを永続的に有効にしない
     でください。パフォーマンスに悪影響を及ぼす可能性があります。 また、
     git がゼロ以外の終了ステータスで終了し、エラーメッセージを出力する
     からといって、それがこと Magit に関してはエラーであるとは限らないこ
     とに注意してください。これが、通常、これらのエラーメッセージを非表
     示にするもう 1 つの理由です。 エラーメッセージが予期しない動作に関
     連しているかどうかは、ケースバイケースで判断する必要があります。

     コマンド ‘magit-toggle-git-debug’ は、この変数の値を変更します。

 -- Variable: magit-process-extreme-logging
     このオプションは、‘magit-process-file’が‘*Messages*’バッファにロギ
     ングするかどうかを制御します。

     Magitが舞台裏でGitをどのように使用しているかを理解しようとするとき
     に、一時的に使用することのみを目的としています。通常magit-processバ
     ッファに送られる出力は、引き続きそこに送られます。なお、すべての出
     力がこれら2つのバッファのいずれかに送られるわけではありません。


File: magit.ja.info,  Node: Git Process Status,  Next: Gitを手動で実行,  Prev: Viewing Git Output,  Up: Running Git

4.7.2 Git Process Status
------------------------

副作用のためにGitプロセスが実行されている場合、Magitは
‘magit-mode-line-process’ faceを使用して、モード行にインジケーターを表示
します。

Gitプロセスが正常に終了すると、プロセスインジケーターはモードラインから
直ちに削除されます。

Gitエラーの場合、プロセスインジケーターは削除されませんが、代わりに
‘magit-mode-line-process-error’ faceで強調表示され、プロセスバッファーか
らのエラーの詳細がマウスユーザーのためにツールチップとして提供されます。
このエラーインジケータは、次のmagitバッファリフレッシュまでモード行に表
示されます。

モード行にプロセスエラーを表示したくない場合は、
‘magit-process-display-mode-line-error’ユーザーオプションをカスタマイズ
します。

プロセスエラーは、ステータスバッファの先頭に追加で示されます。


File: magit.ja.info,  Node: Gitを手動で実行,  Next: Git実行ファイル,  Prev: Git Process Status,  Up: Running Git

4.7.3 Gitを手動で実行
---------------------

MagitはGitと対話するための多くのEmacsコマンドを提供しますが、すべてを網
羅しているわけではありません。そのような場合、既存のGitの知識が役立ちま
す。Magitは、シェルに切り替える代わりに、ミニバッファーに入力することで
任意のGitコマンドを実行するためのいくつかのコマンドを提供します。

‘!’ (‘magit-run’)
     このトランジェント(一時的)プレフィックス(接頭辞)コマンドは、それに
     従うサフィックス(接尾辞)コマンド群を結びつけ、そのサフィックスコマ
     ンドのどれかを選ぶまでの間、サフィックス(接尾辞)コマンド群を一時バ
     ッファ(temporary buffer)に表示します。

‘! !’ (‘magit-git-command-topdir’)
     このコマンドは、ユーザーからコマンドを読み取り、現在の作業ツリーの
     最上位ディレクトリで実行します。

     文字列「git」は、ユーザーにコマンドの入力を求めるときの初期入力とし
     て使用されます。別のコマンドを実行するために削除できます。

‘:’ (‘magit-git-command’)
‘! p’
     このコマンドは、ユーザーからコマンドを読み取り、
     ‘default-directory’で実行します。プレフィックス引数を使用すると、コ
     マンドは‘default-directory’の代わりに現在の作業ツリーの最上位ディレ
     クトリで実行されます。

     文字列「git」は、ユーザーにコマンドの入力を求めるときの初期入力とし
     て使用されます。別のコマンドを実行するために削除できます。

‘! s’ (‘magit-shell-command-topdir’)
     このコマンドは、ユーザーからコマンドを読み取り、現在の作業ツリーの
     最上位ディレクトリで実行します。

‘! S’ (‘magit-shell-command’)
     このコマンドは、ユーザーからコマンドを読み取り、
     ‘default-directory’で実行します。プレフィックス引数を使用すると、コ
     マンドは‘default-directory’の代わりに現在の作業ツリーの最上位ディレ
     クトリで実行されます。

 -- User Option: magit-shell-command-verbose-prompt
     シェルコマンドを読み取るときに上記のコマンドで使用されるプロンプト
     が、それが実行されるディレクトリを表示しているかどうか。

以下のサフィックスコマンドは、外部GUIツールを起動します。

‘! k’ (‘magit-run-gitk’)
     このコマンドは、現在のリポジトリで‘gitk’を実行します。

‘! a’ (‘magit-run-gitk-all’)
     このコマンドは、現在のリポジトリで‘gitk --all’を実行します。

‘! b’ (‘magit-run-gitk-branches’)
     このコマンドは、現在のリポジトリで‘gitk --branches’を実行します。

‘! g’ (‘magit-run-git-gui’)
     このコマンドは、現在のリポジトリで‘git gui’を実行します。

‘! m’ (‘magit-git-mergetool’)
     このコマンドは、現在のリポジトリで ‘git mergetool --gui’ を実行しま
     す。

     前置引数を使用すると、これは一時的な前置コマンドとして機能し、ユー
     ザーが mergetool を選択して一部の設定を変更できるようにします。


File: magit.ja.info,  Node: Git実行ファイル,  Next: Global Git Arguments,  Prev: Gitを手動で実行,  Up: Running Git

4.7.4 Git実行ファイル
---------------------

MagitがGitを呼び出すときは、‘git’実行可能ファイルへの絶対パスを使用する
か、その名前だけを使用して呼び出すことができます。

‘git’をローカルで実行し、かつ、‘system-type’が‘windows-nt’(任意の
Windowsバージョン)または‘darwin’(macOS)の場合、‘magit-git-executable’は
Magitがロードされるときに絶対パスに設定されます。

Windowsでは、絶対パスを使用する必要があります。Gitには実際の‘git’バイナ
リ用のラッパースクリプトがいくつか付属していて、これらも‘$PATH’に配置さ
れており、バイナリの代わりにこれらのラッパーの1つを使用すると、パフォー
マンスがひどく低下します。一部のmacOSユーザーの場合、実行可能ファイルの
名前だけを使用するとパフォーマンスが低下するため、そのプラットフォームで
もそういう実行を回避します。他のプラットフォームでは、名前だけを使用して
も問題なく機能するようです。

Trampを介してリモートマシンで‘git’を実行するときに絶対パスを使用すると、
ローカルマシンに適した絶対パスを使用するのが問題になるため、リモートマシ
ンで使用される名前またはパスを制御するために別のオプションが使用されます
。

 -- User Option: magit-git-executable
     ローカルホスト上のMagitによって使用される‘git’実行可能ファイル。こ
     れは、実行可能ファイルへの絶対パス、またはEmacsがそのようなことを行
     うための標準メカニズムを使用して実行可能ファイル自体を見つけられる
     ようにする文字列"git"のいずれかである必要があります。

 -- User Option: magit-remote-git-executable
     Trampを介してリモートマシン上のMagitによって使用される‘git’実行可能
     ファイル。通常、これは文字列"git"である必要があります。このオプショ
     ンの代わりに‘tramp-remote-path’をカスタマイズすることを検討してくだ
     さい。

Emacsが正しい実行可能ファイルを見つけられない場合は、これら2つのオプショ
ンのいずれかの値を明示的に設定することで回避できます。それを行うことは、
応急修理と見なされるべきです。‘exec-path’または‘tramp-remote-path’の順序
が正しいことを確認することをお勧めします。

‘exec-path’は、Emacsの起動時に有効な‘PATH’環境変数の値に基づいて設定され
ることに注意してください。あなたのシェルのinitファイルで‘PATH’を設定した
場合、そのシェルから開始した場合にのみEmacsに影響します(プロセスの環境は
子プロセスにのみ渡され、他の任意のプロセスには渡されないため)。それが
Emacsの起動方法ではない場合は、‘exec-path-from-shell’パッケージが役立ち
ます。正直なところ、私もそれを応急修理だと思います。

コマンド‘magit-debug-git-executable’は、Emacsが‘git’を検索している場所を
見つけるのに役立ちます。

‘M-x magit-debug-git-executable’
     このコマンドは、‘magit-git-executable’および
     ‘magit-remote-git-executable’に関する情報を含むバッファを表示します
     。

‘M-x magit-version’
     このコマンドは、現在使用されているMagit、Git、およびEmacsのバージョ
     ンをエコー領域に表示します。非インタラクティブでは、これは単に
     Magitバージョンを返すだけです。


File: magit.ja.info,  Node: Global Git Arguments,  Prev: Git実行ファイル,  Up: Running Git

4.7.5 Global Git Arguments
--------------------------

 -- User Option: magit-git-global-arguments
     ここで設定された引数は、git実行可能ファイルがサブプロセスとして実行
     されるたびに使用されます。これらは、実行可能ファイル自体の直後で、
     gitコマンドの前に配置されます。‘git HERE... COMMAND REST’のように。
     有効な引数については→ *note (gitman)git::

     特にTrampを使用して古いGitバージョンのサーバーに接続している場合は
     、ここに何を追加するかに注意してください。自分が何をしているかを本
     当に理解していない限り、デフォルト値の一部であるものは絶対に削除し
     ないでください。そして、何かを追加する前に、非常によく考えてくださ
     い。それはMagitがどんな目的であれGitを実行するたびに使用されます。


File: magit.ja.info,  Node: Inspecting,  Next: Manipulating,  Prev: Interface Concepts,  Up: Top

5 Inspecting
************

Magitが提供する機能は、既存のデータの検査、既存のデータの操作または新し
いデータの追加、データの転送の3つのグループに大別できます。もちろん、そ
れはかなり大雑把な区別であり、しばしば不十分ですが、まったく区別しないよ
りも便利です。この節はデータの検査に関係し、次の2つはデータの操作と転送
に関係します。次に、この区別に簡単に当てはまらないその他の機能に関する節
が続きます。

もちろん、他の区別も意味があります。Gitでの磁器コマンドと配管コマンドの
区別です。これは、ほとんどの場合、Emacsでのインタラクティブコマンドと非
インタラクティブ機能の区別に相当します。前述のすべての節は、主に磁器に関
係しています。Magitの配管コマンドレイヤーについては後で説明します。

* Menu:

* Status Buffer::            Status Buffer
* Repository List::          Repository List
* Logging::                  Logging
* Diffing::                  Diffing
* Ediffing::                 Ediffing
* References Buffer::        References Buffer
* Bisecting::                Bisecting
* Visiting Files and Blobs::  Visiting Files and Blobs
* Blaming::                  Blaming


File: magit.ja.info,  Node: Status Buffer,  Next: Repository List,  Up: Inspecting

5.1 Status Buffer
=================

他のMagitバッファ達では、例えば、1つの特定のdiffまたは1つの特定のログや
、ステータスバッファならばステージされた変更とステージされていない変更の
diff、プッシュされていないコミットとプルされていないコミットのログ、スタ
ッシュと追跡されていないファイル(untracked files)のリスト、および現在の
ブランチに関連する情報が含まれます。

特定の不完全な操作の途中(たとえば、マージによって競合が発生した場合)、操
作の続行または中止に役立つ追加情報が表示されます。

コマンド‘magit-status’は、現在のリポジトリに属するステータスバッファを別
のウィンドウに表示します。このコマンドは頻繁に使用されるため、グローバル
にバインドすべきです。我々は‘C-x g’をお勧めします:

     (global-set-key (kbd "C-x g") 'magit-status)

‘C-x g’ (‘magit-status’)
     既存のGitリポジトリ内から呼び出されると、このコマンドはバッファ内の
     そのリポジトリのステータスを表示します。

     現在のディレクトリがGitリポジトリ内にない場合、このコマンドは、オプ
     ション‘magit-repository-directories’に応じて、代わりに既存のリポジ
     トリまたは任意のディレクトリの入力を求め、選択したリポジトリのステ
     ータスを表示します。

        • そのオプションで既存のリポジトリ達が指定されている場合、ユーザ
          ーはそれらの1つを選択するように求められます。

        • それ以外の場合、ユーザーは通常のファイル名補完を使用して任意の
          ディレクトリを選択するように求められます。選択したディレクトリ
          が既存の作業ツリーの最上位ディレクトリである場合、そのステータ
          スバッファが表示されます。

        • それ以外の場合、ユーザーは選択したディレクトリを新しいリポジト
          リとして初期化するように提案されます。リポジトリを作成すると、
          そのステータスバッファが表示されます。

     これらのフォールバック動作は、1つ以上のプレフィックス引数を使用して
     強制することもできます。

        • 2ストロークのプレフィックス引数(より正確には16以上の数値プレフ
          ィックス値)を使用して、任意のディレクトリが読み取られ、上記の
          ように処理されます。コマンド‘magit-init’を使用して同じことを実
          行できます。

        • 1ストロークのプレフィックス引数を使用すると、既存のリポジトリ
          がユーザーから読み取られます。または、
          ‘magit-repository-directories’の値に基づいてリポジトリが見つか
          らない場合、動作は2ストロークのプレフィックス引数の場合と同じ
          です。

 -- User Option: magit-repository-directories
     Gitリポジトリであるか、Gitリポジトリを含むディレクトリのリスト。

     各要素の形式は‘(DIRECTORY . DEPTH)’です。DIRECTORYは、ディレクトリ
     またはディレクトリファイル名で文字列である必要があります。DEPTHは整
     数でGitリポジトリを検索する最大の深さを指定します。DEPTHが0の場合は
     、DIRECTORY自体のみを追加します。

     このオプションは、‘magit-list-repositories’によってリストされるリポ
     ジトリを制御します。また、‘magit-status’(を参照)にも驚くべき方法で
     影響を及ぼします(上記を参照)。

 -- Command: magit-status-quick
     このコマンドは、‘magit-status’の代替になり、通常はステータスバッフ
     ァのリフレッシュを回避します。

     現在のGitリポジトリのステータスバッファが存在するが、選択したフレー
     ムに表示されていない場合は、リフレッシュされずに表示されます。

     選択したフレームにステータスバッファが表示されている場合、このコマ
     ンドはステータスバッファをリフレッシュします。

     プレフィックス引数は‘magit-status’の場合と同じ意味を持ち、さらにバ
     ッファをリフレッシュします。

     このコマンドを使用するには、以下をinitファイルに追加します:

          (global-set-key (kbd "C-x g") 'magit-status-quick).

     これを行った後、バッファを再表示してすぐにリフレッシュする場合は、
     ‘C-x g’に続けて‘g’と入力します。

     可能な代替コマンドは‘magit-display-repository-buffer’です。ステータ
     スバッファだけでなく、現在のリポジトリに属する既存のMagitバッファの
     表示をサポートします。

 -- Command: ido-enter-magit-status
     ファイルを開くために使用されるIdoプロンプトから、代わりに
     ‘magit-status’にドロップ(drop)します。これは
     ‘ido-magic-delete-char’に似ており、その名前にもかかわらず、通常は
     Diredバッファが作成されます。

     このコマンドを使用可能にするには、以下のようなものを使用します:

          (add-hook 'ido-setup-hook
                    (lambda ()
                      (define-key ido-completion-map
                        (kbd \"C-x g\") 'ido-enter-magit-status)))

     Emacs 25.1以降、IdoキーマップはIdoが呼び出されるたびではなく、一度
     だけ定義されるため、他のほとんどすべてのキーマップと同じように変更
     できるようになりました。

          (define-key ido-common-completion-map
            (kbd \"C-x g\") 'ido-enter-magit-status)

* Menu:

* Status Sections::          Status Sections
* Status Header Sections::   Status Header Sections
* Status Module Sections::   Status Module Sections
* Status Options::           Status Options


File: magit.ja.info,  Node: Status Sections,  Next: Status Header Sections,  Up: Status Buffer

5.1.1 Status Sections
---------------------

ステータスバッファの内容は、フック‘magit-status-sections-hook’を使用して
制御されます。このようなフックとそれらをカスタマイズする方法についてはこ
ちらを参照して下さい(*note Section Hooks::)。

 -- User Option: magit-status-sections-hook
     フックを実行して、セクションをステータスバッファに挿入します。

デフォルトでは、そのフックの最初の関数は‘magit-insert-status-headers’で
す。次節で説明します。デフォルトでは、以下の関数もそのフックのメンバーで
す。

 -- Function: magit-insert-merge-log
     進行中のマージのセクションを挿入します。マージされているヘッド達を
     表示します。マージが進行中でない場合は、何もしません。

 -- Function: magit-insert-rebase-sequence
     進行中のリベースシーケンスのセクションを挿入します。そのようなシー
     ケンスが進行中でない場合は、何もしません。

 -- Function: magit-insert-am-sequence
     進行中のパッチ適用シーケンスのセクションを挿入します。そのようなシ
     ーケンスが進行中でない場合は、何もしません。

 -- Function: magit-insert-sequencer-sequence
     進行中のチェリーピックまたはrevertシーケンスのセクションを挿入しま
     す。そのようなシーケンスが進行中でない場合は、何もしません。

 -- Function: magit-insert-bisect-output
     bisectしている間、‘git bisect’からの出力を含むセクションを挿入しま
     す。

 -- Function: magit-insert-bisect-rest
     bisectしている間、bisect態を視覚化するセクションを挿入します。

 -- Function: magit-insert-bisect-log
     bisectしている間、bisectの進行状況をlogするセクションを挿入します。

 -- Function: magit-insert-untracked-files
     たぶん、追跡されていないファイル(untracked file)のリストまたはツリ
     ーを挿入します。

     ‘status.showUntrackedFiles’の値に応じてこれを行います。値が‘all’で
     あっても、Magitは最初はディレクトリのみを表示することに注意してくだ
     さい。ただし、ディレクトリセクションは‘TAB’を使用して展開できます。

 -- Function: magit-insert-unstaged-changes
     ステージされていない変更(unstaged changes)を示すセクションを挿入し
     ます。

 -- Function: magit-insert-staged-changes
     ステージされた変更(staged changes)を表すセクションを挿入します。

 -- Function: magit-insert-stashes &optional ref heading
     "refs/stash"のreflogを示す‘stashes’セクションを挿入します。オプショ
     ンのREFがnil以外の場合は、代わりにそのためのreflogを表示します。オ
     プションのHEADINGがnil以外の場合は、"Stashes:"の代わりにセクション
     見出しとして使用します。

 -- Function: magit-insert-unpulled-from-upstream
     アップストリームブランチからまだプルされていないコミットを示すセク
     ションを挿入します。

 -- Function: magit-insert-unpulled-from-pushremote
     プッシュリモートブランチからまだプルされていないコミットを示すセク
     ションを挿入します。

 -- Function: magit-insert-unpushed-to-upstream
     まだアップストリームにプッシュされていないコミットを示すセクション
     を挿入します。

 -- Function: magit-insert-unpushed-to-pushremote
     まだプッシュリモートにプッシュされていないコミットを示すセクション
     を挿入します。

以下の関数を上記のフックに追加することもできます:

 -- Function: magit-insert-tracked-files
     追跡中のファイル(tracked files)のツリーを挿入します。

 -- Function: magit-insert-ignored-files
     無視されたファイル(ignored files)のツリーを挿入します。‘D = f
     <DIRECTORY> RET g’を使用して、現在のバッファ内のログを特定のディレ
     クトリに制限することができます。これを行うと、このコマンドにも影響
     します。

     ログフィルターの使用により、対象ファイル達を絞り込めます。その場合
     、この関数は最初のファイルのみを尊重し、それがディレクトリである場
     合に限ります。

 -- Function: magit-insert-skip-worktree-files
     スキップワークツリーファイル(skip-worktree files)のツリーを挿入しま
     す。‘magit-buffer-diff-files’の最初の要素がディレクトリである場合は
     、リストをその下のファイル達だけに制限します。その変数の値は、‘D --
     DIRECTORY RET g’を使用して設定できます。

 -- Function: magit-insert-assumed-unchanged-files
     変更されていないと想定されるファイルのツリーを挿入します。
     ‘magit-buffer-diff-files’の最初の要素がディレクトリである場合は、リ
     ストをその下のファイル達に制限します。その変数の値は、‘D --
     DIRECTORY RET g’を使用して設定できます。

 -- Function: magit-insert-unpulled-or-recent-commits
     プルされていないコミットまたは最近のコミットを示すセクションを挿入
     します。アップストリームが現在のブランチ用に構成されていて、それが
     現在のブランチよりも進んでいる場合は、欠落しているコミットを表示し
     ます。それ以外の場合は、最後の‘magit-log-section-commit-count’コミ
     ットを表示します。

 -- Function: magit-insert-recent-commits
     最後の‘magit-log-section-commit-count’コミットを示すセクションを挿
     入します。

 -- User Option: magit-log-section-commit-count
     (プルされていないコミットがない場合、)
     ‘magit-insert-recent-commits’および
     ‘magit-insert-unpulled-or-recent-commits’の最近のコミット数が表示さ
     れます。

 -- Function: magit-insert-unpulled-cherries
     プルされていないコミットを示すセクションを挿入します。
     ‘magit-insert-unpulled-commits’と同様ですが、まだ適用されていない各
     コミット(つまり、ローカルコミットと共有されていないパッチ
     ID(patch-id)を持つコミット)の前に"+"を付け、他のすべてのコミットに
     は"-"を付けます。

 -- Function: magit-insert-unpushed-cherries
     プッシュされていないコミットを示すセクションを挿入します。
     ‘magit-insert-unpushed-commits’と同様ですが、アップストリームにまだ
     適用されていない各コミット(つまり、パッチID(patch-id)のあるコミット
     はアップストリームコミットと共有されていません)の前に"+"を付け、他
     のすべてのコミットには"-"を付けます。

ここで使用できるその他のセクションインサーターについてはこちらを参照して
下さい(*note References Buffer::)。


File: magit.ja.info,  Node: Status Header Sections,  Next: Status Module Sections,  Prev: Status Sections,  Up: Status Buffer

5.1.2 Status Header Sections
----------------------------

ステータスバッファの内容は、フック‘magit-status-sections-hook’を使用して
制御されます(see *note Status Sections::)。

デフォルトでは、‘magit-insert-status-headers’がそのフック変数の最初のメ
ンバーです。

 -- Function: magit-insert-status-headers
     ‘magit-status-mode’バッファに適したヘッダーセクションを挿入します。
     セクションは、フック‘magit-status-headers-hook’で関数達を実行するこ
     とによって挿入されます。

 -- User Option: magit-status-headers-hook
     フックを実行して、ヘッダーセクションをステータスバッファーに挿入し
     ます。

     このフックは‘magit-insert-status-headers’によって実行され、それらの
     関数は‘magit-status-sections-hook’のメンバーである必要があります。

デフォルトでは、以下の関数が上記フックのメンバーです:

 -- Function: magit-insert-error-header
     たった今発生したGitエラーに関するメッセージを示すヘッダー行を挿入し
     ます。

     この関数は、副作用のためにGitが実行されたときに発生した最後のエラー
     のみを認識します。たとえば、diffの生成中にエラーが発生した場合、そ
     のエラーは挿入されません。ステータスバッファをリフレッシュすると、
     このセクションは再び表示されなくなります。

 -- Function: magit-insert-diff-filter-header
     有効なdiffフィルター達を示すヘッダー行を挿入します。

 -- Function: magit-insert-head-branch-header
     現在のブランチまたはdetachされた‘HEAD’に関するヘッダー行を挿入しま
     す。

 -- Function: magit-insert-upstream-branch-header
     通常は現在のブランチにプル(pull into)されるブランチに関するヘッダー
     行を挿入します。

 -- Function: magit-insert-push-branch-header
     現在のブランチが通常プッシュされるブランチに関するヘッダー行を挿入
     します。

 -- Function: magit-insert-tags-header
     タグと‘HEAD’の間のコミット数とともに、現在または次のタグ、あるいは
     その両方に関するヘッダー行を挿入します。

以下の関数を上記のフックに追加することもできます:

 -- Function: magit-insert-repo-header
     リポジトリのトップレベルへのパスを表すヘッダー行を挿入します。

 -- Function: magit-insert-remote-header
     現在のブランチのリモートに関するヘッダー行を挿入します。

     現在のブランチにリモートが構成されていない場合は、フォールバックし
     て"origin"リモートを表示します。存在しない場合は、アルファベット順
     に最初のリモートを表示します。

 -- Function: magit-insert-user-header
     現在のユーザーに関するヘッダー行を挿入します。


File: magit.ja.info,  Node: Status Module Sections,  Next: Status Options,  Prev: Status Header Sections,  Up: Status Buffer

5.1.3 Status Module Sections
----------------------------

ステータスバッファの内容は、フック‘magit-status-sections-hook’を使用して
制御されます(see *note Status Sections::)。

デフォルトでは、‘magit-insert-modules’はそのフック変数のメンバーでは「あ
りません」。

 -- Function: magit-insert-modules
     サブモジュールセクションを挿入します。

     フック‘magit-module-sections-hook’は、挿入されるモジュールセクショ
     ンを制御し、オプション‘magit-module-sections-nested’は、それらを追
     加のセクションでラップ(wrap)するかどうかを制御します。

 -- User Option: magit-module-sections-hook
     ‘magit-insert-modules’によって実行されるフック。

 -- User Option: magit-module-sections-nested
     このオプションは、‘magit-insert-modules’が挿入されたセクションを追
     加のセクションでラップ(wrap)するかどうかを制御します。

     これがnil以外の場合、単一のトップレベルセクションのみが挿入されます
     。nilの場合、‘magit-module-sections-hook’にリストされているすべての
     セクションがトップレベルのセクションになります。

 -- Function: magit-insert-modules-overview
     すべてのサブモジュールのセクションを挿入します。セクションごとに、
     パスとブランチと、‘git describe --tags’の出力を挿入します。それがで
     きない場合は、省略されたHEADコミットハッシュを挿入します。

     このようなサブモジュールセクションで‘RET’を押すと、独自のステータス
     バッファが表示されます。"Modules"セクションで‘RET’を押すと、別のバ
     ッファにあるサブモジュールのリストが表示されます。これは、スーパー
     リポジトリ(super-repository)のステータスバッファに表示されない追加
     情報を表しています。

 -- Function: magit-insert-modules-unpulled-from-upstream
     まだアップストリームからプルされていないモジュールのセクションを挿
     入します。これらのセクションを展開して、それぞれのコミットを表示で
     きます。

 -- Function: magit-insert-modules-unpulled-from-pushremote
     プッシュリモートからまだプルされていないモジュールのセクションを挿
     入します。これらのセクションを展開して、それぞれのコミットを表示で
     きます。

 -- Function: magit-insert-modules-unpushed-to-upstream
     まだアップストリームにプッシュされていないモジュールのセクションを
     挿入します。これらのセクションを展開して、それぞれのコミットを表示
     できます。

 -- Function: magit-insert-modules-unpushed-to-pushremote
     まだプッシュリモートにプッシュされていないモジュールのセクションを
     挿入します。これらのセクションを展開して、それぞれのコミットを表示
     できます。


File: magit.ja.info,  Node: Status Options,  Prev: Status Module Sections,  Up: Status Buffer

5.1.4 Status Options
--------------------

 -- User Option: magit-status-refresh-hook
     ステータスバッファがリフレッシュされた後、フックが実行されます。

 -- User Option: magit-status-margin
     このオプションは、欄外(margin)が最初にMagit-Statusモードのバッファ
     に表示されるかどうか、およびそのフォーマット方法を指定します。

     値の形式は‘(INIT STYLE WIDTH AUTHOR AUTHOR-WIDTH)’です。

        • INITがnil以外の場合、欄外(margin)が最初に表示されます。
        • STYLEは、作成者(author)またはコミッター(committer)の日付をフォ
          ーマットする方法を制御します。‘age’(コミットの経過時間を示す
          )または‘age-abbreviated’(時間単位を文字に短縮する)または実際の
          日付を表す文字列(‘format-time-string’に適しています)のいずれか
          になります。オプション‘magit-log-margin-show-committer-date’は
          、表示される日付を制御します。
        • WIDTHは、欄外(margin)の幅を制御します。これは上位互換性のため
          に存在し、現在値を変更すべきではありません。
        • AUTHORは、作成者の名前もデフォルトで表示されるかどうかを制御し
          ます。
        • AUTHOR-WIDTHは整数である必要があります。作成者の名前が表示され
          ている場合、これはそのために使用されるスペース(空き)の量を指定
          します。

ステータスバッファに関するその他のオプションについては、前節も参照してく
ださい。


File: magit.ja.info,  Node: Repository List,  Next: Logging,  Prev: Status Buffer,  Up: Inspecting

5.2 Repository List
===================

 -- Command: magit-list-repositories
     このコマンドは、別のバッファにあるリポジトリのリストを表示します。

     オプション‘magit-repository-directories’および
     ‘magit-repository-directories-depth’は、表示されるリポジトリを制御
     します。

 -- User Option: magit-repolist-columns
     このオプションは、コマンド‘magit-list-repositories’によって表示され
     る列(columns)とその表示方法を制御します。

     各要素の形式は‘(HEADER WIDTH FORMAT PROPS)’です。

     HEADERは、ヘッダーに表示される文字列です。WIDTHは、列の幅です。
     FORMATは、1つの引数とリポジトリID(通常はそのベース名)と作業ツリーの
     最上位に結び付けられたされた‘default-directory’を使用して呼び出され
     る関数です。挿入する文字列またはnilを返す必要があります。PROPSは、
     キー‘:right-align’と‘:pad-right’と‘:sort’をサポートするalistです。

     ‘:sort’ 関数は、 ‘tabulated-list--get-sort’ の docstring に記述され
     ている奇妙なインターフェースを持っています。 あるいは ‘<’ や
     ‘magit-repolist-version<’ を使用できます。これらの関数は、インター
     フェイスを満たす関数に自動的に置き換えられます。 ‘:sort’ を ‘nil’ に
     設定してソートを禁止します。 指定しない場合、列はデフォルトのソータ
     ーを使用してソート可能です。

     あなたは列ごとに1文字だけを使用し、列間にパディングなしで数値列の範
     囲を表示したい場合があるかもしれません。その場合は、適切なHEADERを
     使用し、WIDTHを1に設定し、‘:pad-right’を9に設定する必要があります。
     ‘+’は、9より大きい数値に置き換えられます。

上記のオプションに以下の関数を追加できます:

 -- Function: magit-repolist-column-ident
     この関数は、リポジトリのIDを挿入します。 通常、これは単なるベース名
     です。

 -- Function: magit-repolist-column-path
     この関数は、リポジトリの絶対パスを挿入します。

 -- Function: magit-repolist-column-version
     この関数は、リポジトリの‘HEAD’リビジョンの説明を挿入します。

 -- Function: magit-repolist-column-branch
     この関数は、現在のブランチの名前を挿入します。

 -- Function: magit-repolist-column-upstream
     この関数は、現在のブランチのアップストリームブランチの名前を挿入し
     ます。

 -- Function: magit-repolist-column-branches
     この関数は、ブランチの数を挿入します。

 -- Function: magit-repolist-column-stashes
     この関数は、スタッシュの数を挿入します。

 -- Function: magit-repolist-column-flag
     この関数は、‘magit-repolist-column-flag-alist’で指定されたフラグ
     (flag)を挿入します。

     デフォルトでは、コミットされていない変更(uncommitted changes)がある
     かどうかを示します。

        • ‘N’ならば、追跡されていないファイル(untracked file)が少なくと
          も1つある。
        • ‘U’ならばステージされていないファイル(unstaged file)が少なくと
          も1つある。
        • ‘S’ならばステージされたファイル(staged file)が少なくとも1つあ
          る。

     これら適用するもののうち、最初の１つだけが表示されます。

 -- Function: magit-repolist-column-unpulled-from-upstream
     この関数は、現在のブランチにないアップストリームコミットの数を挿入
     します。

 -- Function: magit-repolist-column-unpulled-from-pushremote
     この関数は、現在のブランチではなく、プッシュブランチにコミット数を
     挿入します。

 -- Function: magit-repolist-column-unpushed-to-upstream
     この関数は、現在のブランチにコミット数を挿入しますが、そのアップス
     トリームには挿入しません。

 -- Function: magit-repolist-column-unpushed-to-pushremote
     この関数は、現在のブランチにコミット数を挿入しますが、プッシュブラ
     ンチには挿入しません。

以下のコマンドが repolist バッファーで使用できます:

‘<RET>’ (‘magit-repolist-status’)
     このコマンドは、ポイントでの定義のログを表示します。

‘m’ (‘magit-repolist-mark’)
     このコマンドは、ポイントでのリポジトリをマークします。

‘u’ (‘magit-repolist-unmark’)
     このコマンドは、ポイントでのリポジトリのマークを解除します。

‘f’ (‘magit-repolist-fetch’)
     このコマンドは、マークされたすべてのリポジトリを取得します。 リポジ
     トリがマークされていない場合は、表示されているすべてのリポジトリを
     取得するよう提案されます。

‘5’ (‘magit-repolist-find-file-other-frame’)
     このコマンドは、相対ファイル名を (補完なしで) 読み取り、マークされ
     た各リポジトリのそれぞれのファイルを新しいフレームで開きます。 リポ
     ジトリがマークされていない場合は、表示されているすべてのリポジトリ
     に対してこれを行うことを提案します。


File: magit.ja.info,  Node: Logging,  Next: Diffing,  Prev: Repository List,  Up: Inspecting

5.3 Logging
===========

ステータスバッファには、プッシュされていないコミットとプルされていないコ
ミットのログが含まれていますが、それだけでは明らかに不十分です。‘l’のト
ランジェントプレフィックスコマンド‘magit-log’には、個別のログバッファに
特定のログを表示するいくつかのサフィックスコマンドがあります。

他のトランジェントプレフィックスコマンドと同様に、‘magit-log’にも、サフ
ィックスコマンドの1つを呼び出す前に変更できるいくつかのインフィックス引
数達があります。ただし、ログ用トランジェントコマンドの場合、これらの引数
は、‘magit-prefix-use-buffer-arguments’の値に応じて、現在のリポジトリの
ログバッファで現在使用されている引数から取得される場合があります(*note
Transient Arguments and Buffer Variables::)。

さまざまな引数の情報ついては→ *note (gitman)git-log::

スイッチ‘++order=VALUE’は、‘git log’に渡される前に、
‘--author-date-order’または‘--date-order’または‘--topo-order’のいずれか
に変換されます。

ログ用トランジェントコマンドには、いくつかのreflogコマンドもあります。こ
ちらを参照して下さい(*note Reflog::)。

‘l’ (‘magit-log’)
     このトランジェント(一時的)なプレフィックス(接頭辞)コマンドは、それ
     に従うサフィックス(接尾辞)コマンドを適切なインフィックス(中置)引数
     とともに結び付け、いずれかのサフィックスコマンドを選択するまでの間
     、そのインフィックス引数達とサフィックスコマンド達を一時バッファ
     (temporary buffer)に表示します。

‘l l’ (‘magit-log-current’)
     現在のブランチのログを表示します。‘HEAD’が切り離されている
     (detached)か、プレフィックス引数が付いている場合、ミニバッファから
     読み取られた1つ以上のリビジョン(rev)のログを表示します。

‘l h’ (‘magit-log-head’)
     ‘HEAD’のログを表示します。

‘l u’ (‘magit-log-related’)
     現在のブランチと、そのアップストリームと、プッシュターゲットのログ
     を表示します。 アップストリームがローカルブランチの場合は、独自のア
     ップストリームも表示します。 ‘HEAD’ がデタッチされていると、そのロ
     グと、以前にチェックアウトされたブランチと、その上流およびプッシュ
     ターゲットが表示されます。

‘l o’ (‘magit-log-other’)
     ミニバッファから読み取られた1つ以上のリビジョン(rev)のログを表示し
     ます。ユーザーは、スペースまたは範囲で区切られた1つまたは複数のリビ
     ジョンを入力できますが、完了候補として使用できるのは、ブランチ、タ
     グ、およびポイントでのコミットの表現のみです。

‘l L’ (‘magit-log-branches’)
     すべてのローカルブランチと‘HEAD’のログを表示します。

‘l b’ (‘magit-log-all-branches’)
     すべてのローカルブランチとリモートブランチと‘HEAD’のログを表示しま
     す。

‘l a’ (‘magit-log-all’)
     すべての参照(reference)と‘HEAD’のログを表示します。

現在のバッファが訪問しているファイルまたはblobのログを表示する2つの追加
コマンドが存在します(*note Commands for Buffers Visiting Files::)。コマ
ンド‘magit-cherry’もログを表示します(*note Cherries::)。

* Menu:

* Refreshing Logs::          Refreshing Logs
* Log Buffer::               Log Buffer
* Log Margin::               Log Margin
* Select from Log::          Select from Log
* Reflog::                   Reflog
* Cherries::                 Cherries


File: magit.ja.info,  Node: Refreshing Logs,  Next: Log Buffer,  Up: Logging

5.3.1 Refreshing Logs
---------------------

‘L’のトランジェントプレフィックスコマンド‘magit-log-refresh’を使用すると
、表示されるログを変更せずに、現在のバッファで使用されているログ引数を変
更できます。これは専用のログバッファで機能しますが、ステータスバッファで
も機能します。

‘L’ (‘magit-log-refresh’)
     このトランジェント(一時的)なプレフィックス(接頭辞)コマンドは、それ
     に従うサフィックス(接尾辞)コマンドを適切なインフィックス(中置)引数
     とともに結び付け、いずれかのサフィックスコマンドを選択するまでの間
     、そのインフィックス引数達とサフィックスコマンド達を一時バッファ
     (temporary buffer)に表示します。

‘L g’ (‘magit-log-refresh’)
     このサフィックスコマンドは、現在のバッファのローカルログ引数を設定
     します。

‘L s’ (‘magit-log-set-default-arguments’)
     このサフィックスコマンドは、現在のバッファと同じタイプのバッファの
     デフォルトのログ引数を設定します。 同じタイプの他の既存のバッファは
     、ローカル値がすでに初期化されているため、影響を受けません。

‘L w’ (‘magit-log-save-default-arguments’)
     このサフィックスコマンドは、現在のバッファと同じタイプのバッファの
     デフォルトのログ引数を設定し、将来のセッションのために値を保存しま
     す。 同じタイプの他の既存のバッファは、ローカル値がすでに初期化され
     ているため、影響を受けません。

‘L t’ (‘magit-toggle-margin’)
     欄外(margin)を表示または非表示にします。


File: magit.ja.info,  Node: Log Buffer,  Next: Log Margin,  Prev: Refreshing Logs,  Up: Logging

5.3.2 Log Buffer
----------------

‘L’ (‘magit-log-refresh’)
     このトランジェント(一時的)なプレフィックス(接頭辞)コマンドは、それ
     に従うサフィックス(接尾辞)コマンドを適切なインフィックス(中置)引数
     とともに結び付け、いずれかのサフィックスコマンドを選択するまでの間
     、そのインフィックス引数達とサフィックスコマンド達を一時バッファ
     (temporary buffer)に表示します。

     参照(*note Refreshing Logs::)

‘q’ (‘magit-log-bury-buffer’)
     現在のバッファまたはリビジョンバッファを同じフレームに隠し(bury)ま
     す。‘magit-mode-bury-buffer’(を参照)と同様ですが、現在のフレームに
     表示されている場合は、代わりにマイナスのプレフィックス引数を使用し
     てリビジョンバッファを隠します。

‘C-c C-b’ (‘magit-go-backward’)
     現在のバッファの履歴を逆方向に移動します。

‘C-c C-f’ (‘magit-go-forward’)
     現在のバッファの履歴を順方向に進めます。

‘C-c C-n’ (‘magit-log-move-to-parent’)
     現在のコミットの親に移動します。デフォルトでは、これは最初の親です
     が、数値の接頭辞を使用して別の親を指定できます。

‘j’ (‘magit-log-move-to-revision’)
     リビジョンを読み取り、現在のログバッファでそのリビジョンに移動しま
     す。

     選択したreferenceまたはリビジョンが現在のログバッファに表示されてい
     ない場合は、そのことをユーザーに通知し、他に何もしません。

     ログバッファの外部で呼び出された場合は、最初に現在のリポジトリのロ
     グバッファを表示します。 必要に応じて作成します。

‘<SPC>’ (‘magit-diff-show-or-scroll-up’)
     ポイントしているモノのcommitまたはdiffバッファを更新します。

     適切なバッファ内のポイントでコミットまたはスタッシュを表示するか、
     そのバッファが現在のフレームにすでに表示されていて、そのコミットま
     たはスタッシュに関する情報が含まれている場合は、代わりにバッファを
     上にスクロールします。ポイントにコミットまたはスタッシュがない場合
     は、コミットのプロンプトを表示します。

‘<DEL>’ (‘magit-diff-show-or-scroll-down’)
     ポイントしているモノのcommitまたはdiffバッファを更新します。

     適切なバッファ内のポイントでコミットまたはスタッシュを表示するか、
     そのバッファが現在のフレームにすでに表示されていて、そのコミットま
     たはスタッシュに関する情報が含まれている場合は、代わりにバッファを
     下にスクロールします。ポイントにコミットまたはスタッシュがない場合
     は、コミットのプロンプトを表示します。

‘=’ (‘magit-log-toggle-commit-limit’)
     現在のログバッファで表示制限されているコミットの数を切り替えます。
     コミットの数が現在表示制限されている場合は、その制限を削除します。
     それ以外の場合は256に設定します。

‘+’ (‘magit-log-double-commit-limit’)
     現在のログバッファで表示制限されているコミット数を2倍に拡張します。

‘-’ (‘magit-log-half-commit-limit’)
     現在のログバッファのコミット数表示制限数を半分に狭めます。

 -- User Option: magit-log-auto-more
     最後のエントリを超えて移動すると、さらにログエントリが自動的に挿入
     されます。‘magit-goto-*-section’コマンドを使用して最後のエントリを
     通過する場合にのみ考慮されます。

 -- User Option: magit-log-show-refname-after-summary
     コミットの要約の後にrefnameを表示するかどうか。これは、あなたが非常
     に長いブランチ名を使用する場合に役立ちます。

Magitは、Gitの表示方法とは少し異なる方法でreferenceをログに表示します。

ローカルブランチは青色で、リモートブランチは緑色です。 もちろん、他の種
類のreferenceに使用される色と同様に、使用するテーマによって異なります。
現在のブランチは、それぞれのリモートの‘HEAD’ブランチであるリモートブラン
チと同様に、枠で囲まれています。

ローカルブランチとそのプッシュターゲットポイントが同じコミットにある場合
、スペースを保持し、その関係を表示するために、それらの名前が組み合わされ
ます。 例えば:

     origin/feature
     [green][blue-]

     は、下記の代わりです

     feature origin/feature
     [blue-] [green-------]

また、トランジェントコマンドには‘--show-signature’引数がありますが、
Magitはデフォルトではコミットごとに1行しか使用しないため、有効にすると実
際には使用されないことに注意してください。代わりに、
‘magit-signature-*’という名前のface達を使用して、署名された(signed)コミ
ットオブジェクトの有効性を色分けして示します。各‘magit-signature-*’を参
照して下さい。

‘magit-log-margin’の説明についてはこちらを参照して下さい(*note Log
Margin::)。


File: magit.ja.info,  Node: Log Margin,  Next: Select from Log,  Prev: Log Buffer,  Up: Logging

5.3.3 Log Margin
----------------

1つ以上のログを表示するバッファーでは、欄外(margin)内に各コミットに関す
る追加情報を表示することができます。欄外の構成に使用されるオプションの名
前は‘magit-INFIX-margin’です。ここで、INFIX(訳注:INFIX:インフィックス;中
置引数)はそれぞれのメジャーモード‘magit-INFIX-mode’と同じです。通常のロ
グバッファでは、‘magit-log-margin’になります。

 -- User Option: magit-log-margin
     このオプションは、欄外(margin)が最初にMagit-Logモードのバッファに表
     示されるかどうか、およびそのフォーマット方法を指定します。

     値の形式は‘(INIT STYLE WIDTH AUTHOR AUTHOR-WIDTH)’です。

        • INITがnil以外の場合、欄外(margin)が最初に表示されます。
        • STYLEは、作成者(author)またはコミッター(committer)の日付をフォ
          ーマットする方法を制御します。‘age’(コミットの経過時間を示す
          )または‘age-abbreviated’(時間単位を文字に短縮する)または実際の
          日付を表す文字列(‘format-time-string’に適しています)のいずれか
          になります。オプション‘magit-log-margin-show-committer-date’は
          、表示される日付を制御します。
        • WIDTHは、欄外(margin)の幅を制御します。これは上位互換性のため
          に存在し、現在値を変更すべきではありません。
        • AUTHORは、作成者の名前もデフォルトで表示されるかどうかを制御し
          ます。
        • AUTHOR-WIDTHは整数である必要があります。作成者の名前が表示され
          ている場合、これはそのために使用されるスペース(空き)の量を指定
          します。

‘magit’がロードされる「前」に‘magit-log-margin’をカスタマイズすることで
、すべての‘magit-INFIX-margin’オプションのSTYLEとAUTHOR-WIDTHを同じ値に
変更できます。これを行うと、他のオプションのそれぞれの値は、デフォルトで
その変数に設定した値になります。同様に、‘magit-log-margin’のINITを
‘nil’に設定すると、それが他のすべてのオプションのデフォルトで使用されま
す。ただし、‘t’に設定する、つまりそのオプションのデフォルトを再適用して
も、他のオプションには適用されません。

 -- User Option: magit-log-margin-show-committer-date
     このオプションは、欄外(margin)にコミッターの日付を表示するかどうか
     を指定します。 このオプションは、作成者の日付の代わりにコミッターの
     日付を表示するかどうかのみを制御します。欄外に日付を表示するかどう
     か、および欄外を表示するかどうかは、他のオプションによって制御され
     ます。

‘L’ (‘magit-margin-settings’)
     このトランジェントプレフィックスコマンドは、それに従うサフィックス
     コマンドを結び付けます。各コマンドは、何らかの方法で欄外(margin)の
     外観を変更します。

欄外(margin)をサポートする一部のバッファでは、‘L’は代わりに
‘magit-log-refresh’に結び付けられますが、そのトランジェントコマンドには
同じコマンドと、他のいくつかの無関係なコマンドがあります。

‘L L’ (‘magit-toggle-margin’)
     このコマンドは、欄外(margin)を表示または非表示にします。

‘L l’ (‘magit-cycle-margin-style’)
     このコマンドは、欄外(margin)に使用されるスタイルを循環させます。

‘L d’ (‘magit-toggle-margin-details’)
     このコマンドは、欄外(margin)の詳細を表示または非表示にします。


File: magit.ja.info,  Node: Select from Log,  Next: Reflog,  Prev: Log Margin,  Up: Logging

5.3.4 Select from Log
---------------------

ユーザーが‘HEAD’から到達可能な最近のコミットを選択する必要がある場合、通
常の補完を使用するのは不便です(ほとんどの人間は、少なくともダブルチェッ
クなしではハッシュとかまたは"HEAD~5"とかを覚えていないため)。代わりに、
ログバッファを使用してコミットを選択します。これには、コミットが順番にコ
ミットメッセージとともに表示されるという利点があります。

このような選択用ログは、リベースの開始を選択するとき、およびsquashコミッ
トを選択するときに使用されます。

すべてのログバッファで使用可能なキーバインディングに加えて、以下の追加の
キーバインディングが選択用ログバッファで使用できます:

‘C-c C-c’ (‘magit-log-select-pick’)
     ポイントでコミットを選択し、それに基づいて行動します。 選択したコミ
     ットを引数として‘magit-log-select-pick-function’を呼び出します。

‘C-c C-k’ (‘magit-log-select-quit’)
     コミットの選択を中止(abort)し、どのコミットに基づいて行動することも
     しません。

 -- User Option: magit-log-select-margin
     このオプションは、欄外(margin)が最初にMagit-Log-Selectモードのバッ
     ファに表示されるかどうか、およびそのフォーマット方法を指定します。

     値の形式は‘(INIT STYLE WIDTH AUTHOR AUTHOR-WIDTH)’です。

        • INITがnil以外の場合、欄外(margin)が最初に表示されます。
        • STYLEは、作成者(author)またはコミッター(committer)の日付をフォ
          ーマットする方法を制御します。‘age’(コミットの経過時間を示す
          )または‘age-abbreviated’(時間単位を文字に短縮する)または実際の
          日付を表す文字列(‘format-time-string’に適しています)のいずれか
          になります。オプション‘magit-log-margin-show-committer-date’は
          、表示される日付を制御します。
        • WIDTHは、欄外(margin)の幅を制御します。これは上位互換性のため
          に存在し、現在値を変更すべきではありません。
        • AUTHORは、作成者の名前もデフォルトで表示されるかどうかを制御し
          ます。
        • AUTHOR-WIDTHは整数である必要があります。作成者の名前が表示され
          ている場合、これはそのために使用されるスペース(空き)の量を指定
          します。


File: magit.ja.info,  Node: Reflog,  Next: Cherries,  Prev: Select from Log,  Up: Logging

5.3.5 Reflog
------------

こちらもご覧下さい *note (gitman)git-reflog::

これらのreflogコマンドは、ログ用トランジェントコマンドから使用できます。
こちらを参照して下さい(*note Logging::)。

‘l r’ (‘magit-reflog-current’)
     現在のブランチのreflogを表示します。

‘l O’ (‘magit-reflog-other’)
     ブランチまたは別のrefのreflogを表示します。

‘l H’ (‘magit-reflog-head’)
     ‘HEAD’のreflogを表示します。

 -- User Option: magit-reflog-margin
     このオプションは、欄外(margin)が最初にMagit-Reflogモードのバッファ
     に表示されるかどうか、およびそのフォーマット方法を指定します。

     値の形式は‘(INIT STYLE WIDTH AUTHOR AUTHOR-WIDTH)’です。

        • INITがnil以外の場合、欄外(margin)が最初に表示されます。
        • STYLEは、作成者(author)またはコミッター(committer)の日付をフォ
          ーマットする方法を制御します。‘age’(コミットの経過時間を示す
          )または‘age-abbreviated’(時間単位を文字に短縮する)または実際の
          日付を表す文字列(‘format-time-string’に適しています)のいずれか
          になります。オプション‘magit-log-margin-show-committer-date’は
          、表示される日付を制御します。
        • WIDTHは、欄外(margin)の幅を制御します。これは上位互換性のため
          に存在し、現在値を変更すべきではありません。
        • AUTHORは、作成者の名前もデフォルトで表示されるかどうかを制御し
          ます。
        • AUTHOR-WIDTHは整数である必要があります。作成者の名前が表示され
          ている場合、これはそのために使用されるスペース(空き)の量を指定
          します。


File: magit.ja.info,  Node: Cherries,  Prev: Reflog,  Up: Logging

5.3.6 Cherries
--------------

チェリー(cherry)は(まだ)アップストリームに適用されていないコミットであり
、通常はログを使用して視覚化されます。各コミットには、アップストリームに
同等のものがある場合は‘-’が接頭辞として付けられ、そうでない場合、つまり
チェリー(cherry)の場合は‘+’が接頭辞として付けられます。

コマンド‘magit-cherry’は、単一のブランチのチェリー(cherry)を表示しますが
、参照バッファ(*note References Buffer::)は、一度に複数の「アップストリ
ーム」のチェリー達を表示できます。

こちらもご覧下さい *note (gitman)git-reflog::

‘Y’ (‘magit-cherry’)
     特定のブランチにあるが、アップストリームブランチにマージされていな
     いコミットを表示します。

 -- User Option: magit-cherry-margin
     このオプションは、欄外(margin)が最初にMagit-Cherryモードのバッファ
     に表示されるかどうか、およびそのフォーマット方法を指定します。

     値の形式は‘(INIT STYLE WIDTH AUTHOR AUTHOR-WIDTH)’です。

        • INITがnil以外の場合、欄外(margin)が最初に表示されます。
        • STYLEは、作成者(author)またはコミッター(committer)の日付をフォ
          ーマットする方法を制御します。‘age’(コミットの経過時間を示す
          )または‘age-abbreviated’(時間単位を文字に短縮する)または実際の
          日付を表す文字列(‘format-time-string’に適しています)のいずれか
          になります。オプション‘magit-log-margin-show-committer-date’は
          、表示される日付を制御します。
        • WIDTHは、欄外(margin)の幅を制御します。これは上位互換性のため
          に存在し、現在値を変更すべきではありません。
        • AUTHORは、作成者の名前もデフォルトで表示されるかどうかを制御し
          ます。
        • AUTHOR-WIDTHは整数である必要があります。作成者の名前が表示され
          ている場合、これはそのために使用されるスペース(空き)の量を指定
          します。


File: magit.ja.info,  Node: Diffing,  Next: Ediffing,  Prev: Logging,  Up: Inspecting

5.4 Diffing
===========

ステータスバッファには、ステージされたコミットとステージされていないコミ
ットのdiffが含まれていますが、それだけでは明らかに不十分です。‘d’のトラ
ンジェントプレフィックスコマンド‘magit-diff’は、個別のdiffバッファに特定
のdiffを表示するいくつかのサフィックスコマンドがあります。

他のトランジェントプレフィックスコマンドと同様に、‘magit-diff’も、サフィ
ックスコマンドの1つを呼び出す前に変更できるいくつかのインフィックス引数
達があります。ただし、diff用トランジェントコマンドの場合、これらの引数は
、‘magit-prefix-use-buffer-arguments’の値に応じて、現在のリポジトリの
diffバッファで現在使用されている引数から取得される場合があります(*note
Transient Arguments and Buffer Variables::)。

こちらもご覧下さい (*note (gitman)git-diff::)

‘d’ (‘magit-diff’)
     このトランジェント(一時的)なプレフィックス(接頭辞)コマンドは、それ
     に従うサフィックス(接尾辞)コマンドを適切なインフィックス(中置)引数
     とともに結び付け、いずれかのサフィックスコマンドを選択するまでの間
     、そのインフィックス引数達とサフィックスコマンド達を一時バッファ
     (temporary buffer)に表示します。

‘d d’ (‘magit-diff-dwim’)
     そのポイントでの変更を表示します。

‘d r’ (‘magit-diff-range’)
     2つのコミット間の違いを表示します。

     RANGEは範囲(A..B or A...B)である必要がありますが、単一のコミットに
     することもできます。範囲の片側を省略すると、デフォルトで‘HEAD’にな
     ります。コミットのみが指定された場合、そのコミットに関連する作業ツ
     リーの変更が表示されます。

     リージョンがアクティブな場合は、リージョンの最初と最後の行のリビジ
     ョンを使用します。プレフィックス引数を使用して、リビジョンを比較す
     る代わりに、両方のリビジョンの共通の祖先から開始して、変更を表示す
     るリビジョンを選択します(つまり、"..."の範囲を使用します)。

‘d w’ (‘magit-diff-working-tree’)
     現在の作業ツリーと‘HEAD’コミットの間の変更を表示します。プレフィッ
     クス引数を使用して、作業ツリーとミニバッファから読み取られたコミッ
     ト間の変更を表示します。

‘d s’ (‘magit-diff-staged’)
     インデックスと‘HEAD’コミットの間の変更を表示します。プレフィックス
     引数を使用して、インデックスとミニバッファから読み取られたコミット
     間の変更を表示します。

‘d u’ (‘magit-diff-unstaged’)
     作業ツリーとインデックスの間の変更を表示します。

‘d p’ (‘magit-diff-paths’)
     ディスク上の任意の2つのファイル間の変更を表示します。

上記のすべてのサフィックスコマンドは、リポジトリのdiffバッファを更新しま
す。diff用トランジェントコマンドには、別のバッファとの違いを表す2つのコ
マンドもあります。

‘d c’ (‘magit-show-commit’)
     ポイントでコミットを表示します。ポイントにコミットがない場合、また
     はプレフィックス引数がある場合は、コミットのプロンプトを表示します
     。

‘d t’ (‘magit-stash-show’)
     バッファ内のスタッシュのすべてのdiffを表示します。

現在のバッファで訪問しているファイルまたはblobのdiffを表示する2つの追加
コマンドが存在します。こちらを参照して下さい(*note Commands for Buffers
Visiting Files::)。

* Menu:

* Refreshing Diffs::         Refreshing Diffs
* Commands Available in Diffs::  Commands Available in Diffs
* Diff Options::             Diff Options
* Revision Buffer::          Revision Buffer


File: magit.ja.info,  Node: Refreshing Diffs,  Next: Commands Available in Diffs,  Up: Diffing

5.4.1 Refreshing Diffs
----------------------

‘D’のトランジェントプレフィックスコマンド‘magit-diff-refresh’を使用する
と、表示されるdiffを変更せずに、現在のバッファで使用されているdiff引数を
変更できます。これは専用のdiffバッファで機能しますが、ステータスバッファ
でも機能します。

‘D’ (‘magit-diff-refresh’)
     このトランジェント(一時的)なプレフィックス(接頭辞)コマンドは、それ
     に従うサフィックス(接尾辞)コマンドを適切なインフィックス(中置)引数
     とともに結び付け、いずれかのサフィックスコマンドを選択するまでの間
     、そのインフィックス引数達とサフィックスコマンド達を一時バッファ
     (temporary buffer)に表示します。

‘D g’ (‘magit-diff-refresh’)
     このサフィックスコマンドは、現在のバッファのローカルdiff引数を設定
     します。

‘D s’ (‘magit-diff-set-default-arguments’)
     このサフィックスコマンドは、現在のバッファと同じタイプのバッファの
     デフォルトのdiff引数を設定します。同じタイプの他の既存のバッファは
     、ローカル値がすでに初期化されているため、影響を受けません。

‘D w’ (‘magit-diff-save-default-arguments’)
     このサフィックスコマンドは、現在のバッファと同じタイプのバッファの
     デフォルトのdiff引数を設定し、将来のセッションのために値を保存しま
     す。同じタイプの他の既存のバッファは、ローカル値がすでに初期化され
     ているため、影響を受けません。

‘D t’ (‘magit-diff-toggle-refine-hunk’)
     このコマンドは、ハンクの絞り込みのオンとオフを切り替えます。

‘D r’ (‘magit-diff-switch-range-type’)
     このコマンドは、diff範囲タイプを"revA..revB"から"revB...revA"に、ま
     たはその逆に変換します。

‘D f’ (‘magit-diff-flip-revs’)
     このコマンドは、diff範囲のリビジョンを"revA..revB"から
     "revB..revA"に、またはその逆に交換します。

‘D F’ (‘magit-diff-toggle-file-filter’)
     このコマンドは、現在のバッファ内のdiffのファイル制限を切り替え、コ
     ミット内のすべての変更の表示と制限されたサブセットの表示をすばやく
     切り替えることができるようにします。特別な場合として、このコマンド
     がログバッファから呼び出されると、リポジトリのリビジョンバッファ内
     のファイル制限が切り替わります。これは、1つまたは複数のファイルに制
     限されているログバッファからリビジョンを表示する場合に役立ちます。

サポートされている引数のいずれかを変更できる上記のトランジェントコマンド
に加えて、特定の引数のみを変更するコマンドもいくつか存在します。

‘-’ (‘magit-diff-less-context’)
     このコマンドは、diffハンクのコンテキスト(the context)をCOUNT行ずつ
     減らします。

‘+’ (‘magit-diff-more-context’)
     このコマンドは、diffハンクのコンテキスト(the context)をCOUNT行増や
     します。

‘0’ (‘magit-diff-default-context’)
     このコマンドは、diffハンクのコンテキスト(the context)をデフォルトの
     行数にリセットします。

以下のコマンドは、diff用トランジェントコマンドのいずれも使用せずに、表示
されているdiffをすばやく変更します。

‘C-c C-d’ (‘magit-diff-while-committing’)
     コミット中、このコマンドはコミットされようとしている変更を表示しま
     す。修正中にコマンドを再度呼び出すと、新しい変更のみを表示するか、
     コミットされるすべての変更を表示するかが切り替わります。

     このキーバインドは、diffバッファとcommitメッセージバッファで使用で
     きます。

‘C-c C-b’ (‘magit-go-backward’)
     このコマンドは、現在のバッファの履歴を逆方向に移動します。

‘C-c C-f’ (‘magit-go-forward’)
     このコマンドは、現在のバッファーの履歴を順方向に進めます。


File: magit.ja.info,  Node: Commands Available in Diffs,  Next: Diff Options,  Prev: Refreshing Diffs,  Up: Diffing

5.4.2 Commands Available in Diffs
---------------------------------

一部のコマンドは、ポイントがdiff内にある場合にのみ使用できます。

‘magit-diff-visit-file’および関連するコマンドは、その時点でのdiffが含ま
れているファイルの適切なバージョンを訪問します。 同様に、
‘magit-diff-visit-worktree-file’および関連するコマンドは、その時点での
diffが含まれているファイルのワークツリーバージョンを訪問します。詳細とキ
ーバインディングについてはこちらを参照して下さい(*note Visiting Files
and Blobs from a Diff::)。

‘C-c C-t’ (‘magit-diff-trace-definition’)
     このコマンドは、ポイントでの定義(the definition)のログを表示します
     。

 -- User Option: magit-log-trace-definition-function
     このオプションで指定された関数は、‘magit-log-trace-definition’によ
     って使用され、ポイントでの機能を決定します。特別なニーズがあるメジ
     ャーモードの場合、モードのフックを使用してローカル値を設定できます
     。

‘C-c C-e’ (‘magit-diff-edit-hunk-commit’)
     このコマンドは、ハンクからそれぞれのコミットを編集し、ファイルを訪
     問します。

     まず、‘magit-diff-visit-file’を使用して、ハンクによって正しい場所で
     変更されているファイルを訪問します。これは実際にblobを訪問します。
     ポイントが個々のハンク内ではなくdiffヘッダー上にある場合、これは最
     初のハンクが存在するblobを訪問します。

     次に‘magit-edit-line-commit’を呼び出し、‘HEAD’からそのコミットを直
     接チェックチェックアウトすることで到達することは不可能な、インタラ
     クティブなリベースを使用してコミットを編集可能にし、これにより実際
     の作業ツリーのファイルも訪問できます。

     リベースの終了時に、blobもファイルバッファも強制終了(kill)されませ
     ん。それが望ましくない場合は、このコマンドの代わりに
     ‘magit-rebase-edit-command’を使用する方がよい場合があります。

‘j’ (‘magit-jump-to-diffstat-or-diff’)
     このコマンドは、diffstatまたはdiffにジャンプします。ポイントが
     diffstatセクション内のファイル上にある場合は、それぞれのdiffセクシ
     ョンにジャンプします。 それ以外の場合は、diffstatセクションまたはそ
     の子にジャンプします。

以下の2つのコマンドは、Magit-Diffモード(または、さらに言えばMagitバッフ
ァ)に固有のものではありませんが、ここでも使用できることを指摘しておく価
値があります。

‘<SPC>’ (‘scroll-up’)
     このコマンドは、テキストを上にスクロールします。

‘<DEL>’ (‘scroll-down’)
     このコマンドは、テキストを下にスクロールします。


File: magit.ja.info,  Node: Diff Options,  Next: Revision Buffer,  Prev: Commands Available in Diffs,  Up: Diffing

5.4.3 Diff Options
------------------

 -- User Option: magit-diff-refine-hunk
     diffハンク内で単語の粒度(word-granularity)のdiffを表示するかどうか
     。

        • ‘nil’ 細かい違いを表示しないでください。
        • ‘t’ 現在のdiffハンクのみの細かい違いを表示します。
        • ‘all’ 表示されているすべてのdiffハンクの細かい違いを表示します
          。

 -- User Option: magit-diff-refine-ignore-whitespace
     単語の粒度(word-granularity)の違いにおける空白の変更を無視するかど
     うか。

 -- User Option: magit-diff-adjust-tab-width
     diffでタブの幅を調整するかどうか。

     大きなファイルや多数のファイルを開く必要がある場合、正しい幅を決定
     するのはコストがかかる可能性があるため、幅は変数
     ‘magit-diff--tab-width-cache’にキャッシュされます。キャッシュを無効
     にするには、これをnilに設定します。

        • ‘nil’ タブ幅は調整しません。代わりに、Magitバッファ自体の
          ‘tab-width’の値を使います。

        • ‘t’ 対応するfile-visitingバッファが存在する場合は、そのバッフ
          ァの‘tab-width’の値を使用します。これを行うのは安価であるため
          、対応するキャッシュエントリが存在する場合でも、この値が使用さ
          れます。

        • ‘always’ そのようなバッファがない場合は、一時的(temporarily)に
          ファイルを訪問して値を決定します。

        • NUMBER ‘always’と同様ですが、NUMBERバイトより大きいファイルを
          訪問しないでください。

 -- User Option: magit-diff-paint-whitespace
     空白エラー達を強調表示(highlight)する場所を指定します。

     ‘magit-diff-highlight-trailing’、
     ‘magit-diff-highlight-indentation’を参照してください。 シンボル
     ‘t’はすべてのdiffを意味し、‘status’はステータスバッファ内のみを意味
     し、nilはどこにも存在しないことを意味します。

        • ‘nil’ 空白エラーを強調表示(highlight)しません。
        • ‘t’ どこでも空白エラーを強調表示(highlight)します。
        • ‘uncommitted’ コミットされていない変更を示すdiff達の空白エラー
          のみを強調表示(highlight)します。下位互換性のために、
          ‘status’は同義語として扱われます。

 -- User Option: magit-diff-paint-whitespace-lines
     空白エラーを強調表示(highlight)する行の種類(kind of lines)を指定し
     ます。

        • ‘t’ 追加された行でのみ強調表示(highlight)します。
        • ‘both’ 追加および削除された行を強調表示(highlight)します。
        • ‘all’ 追加、削除、およびコンテキスト行で強調表示(highlight)し
          ます。

 -- User Option: magit-diff-highlight-trailing
     diff達の行末の空白を強調表示するかどうか。
     ‘magit-diff-paint-whitespace’がnil以外の場合にのみ使用されます。

 -- User Option: magit-diff-highlight-indentation
     このオプションは、「間違った」インデントスタイルを使用した場合にイ
     ンデントを強調表示(highlight)するかどうかを制御します。インデントは
     、‘magit-diff-paint-whitespace’もnil以外の場合にのみ強調表示されま
     す。

     値は、‘((REGEXP . INDENT)...)’の形式のalistです。現在のリポジトリへ
     のパスは、逆の順序で各要素と照合されます。したがって、REGEXPが一致
     する場合、以前の要素は試行されません。

     使用するインデントが‘tabs’の場合は、タブでインデントを強調表示
     (highlight)します。INDENTが整数の場合は、少なくともその数のスペース
     でインデントを強調表示します。それ以外の場合は、どちらも強調表示し
     ません。

 -- User Option: magit-diff-hide-trailing-cr-characters
     diff達の行末の ^M 文字を非表示にするかどうか。

 -- User Option: magit-diff-highlight-hunk-region-functions
     このオプションは、ハンク内部regionを強調表示(highlight)するために使
     用される関数を指定します。

     ‘magit-diff-highlight-hunk-region-dim-outside’は、ハンクの内部選択
     範囲(hunk internal selection)の外側に、追加および削除された行の背景
     色をコンテキスト行と同じにするfaceをオーバーレイします。この関数は
     、このオプションの値から削除すべきではありません。

     ‘magit-diff-highlight-hunk-region-using-overlays’と
     ‘magit-diff-highlight-hunk-region-using-underline’は、前後に区切り
     の水平線を配置することで、regionを強調します。これらの機能には両方
     とも、Emacsのディスプレイエンジンの制限のために修正できない欠陥
     (glitches)があります。詳細についてはこちらを参照して下さい
     <https://github.com/magit/magit/issues/2758> ff

     Instead of, or in addition to, using delimiting horizontal lines,
     to emphasize the boundaries, you may wish to emphasize the text
     itself, using ‘magit-diff-highlight-hunk-region-using-face’.

     ターミナルフレームでは、オーバーレイとアンダーラインのバリエーショ
     ンが通常行うように線を描画することはできないため、代わりにface関数
     の呼び出しにフォールバックします。

 -- User Option: magit-diff-unmarked-lines-keep-foreground
     このオプションは、ハンク内部(hunk-internal)regionの外側に追加および
     削除された線が、明確な背景色のみを失うか、前景色も失うかを制御しま
     す。 領域の外側が暗くなるかどうかは、
     ‘magit-diff-highlight-hunk-region-functions’によって異なります。

 -- User Option: magit-diff-extra-stat-arguments
     このオプションは、‘--stat’と一緒に使用される追加の引数を指定します
     。

     値は、0個以上の引数のリスト、または引数をとらずにそのようなリストを
     返す関数です。一緒に使ってよい引数は‘--stat-width’と
     ‘--stat-name-width’と‘--stat-graph-width’と‘--compact-summary’です
     。こちらもご覧ください (*note (gitman)git-diff::)


File: magit.ja.info,  Node: Revision Buffer,  Prev: Diff Options,  Up: Diffing

5.4.4 Revision Buffer
---------------------

 -- User Option: magit-revision-insert-related-refs
     関連するブランチをリビジョンバッファに表示するかどうか。

        • ‘nil’ 関連するブランチを表示しません。
        • ‘t’ 関連するローカルブランチを表示します。
        • ‘all’ 関連するローカルブランチとリモートブランチを表示します。
        • ‘mixed’ 含まれているすべてのブランチとローカルのマージされたブ
          ランチを表示します。

 -- User Option: magit-revision-show-gravatars
     リビジョンバッファにGravatar画像を表示するかどうか。

     ‘nil’の場合はGravatar画像を挿入しません。‘t’の場合は両方の画像を挿
     入します。‘author’または‘committer’の場合は、それぞれの画像のみを挿
     入します。

     あなたがオプション‘magit-revision-headers-format’をカスタマイズして
     いて、画像を挿入したい場合は、どこに挿入するかも指定する必要があり
     ます。その場合、値は2つの正規表現のコンスセルである必要があります。
     carは、作者の画像を挿入する場所を指定します。画像の上半分は一致した
     テキストの直後に挿入され、下半分は同じ列の次の行に挿入されます。
     cdrは、それに応じてコミッターのイメージを挿入する場所を指定します。
     carかcdrのどちらかがnilかもしれません。

 -- User Option: magit-revision-use-hash-sections
     コミットメッセージ内のハッシュをセクションに変換するかどうか。

     nil以外の場合、コミットメッセージ内のハッシュは‘commit’セクションに
     変換されます。パフォーマンスと信頼性の間にはトレードオフがあります
     。

        • ‘slow’ 確実にすべての単語に対してgitを呼び出します。
        • ‘quick’ 7文字未満の単語をスキップします。
        • ‘quicker’ さらに、数字を含まない単語をスキップします。
        • ‘quickest’ 7文字以上の長さでかつ、1つ以上の数字かつ、1つ以上文
          字を含むすべての単語を使用します。

     nilの場合、ハッシュはセクションに変換されませんが、そのポイントで「
     RET」を使用してコミットを訪問できます。

リビジョンバッファに表示されるdiff達は、変更されたファイルのサブセットに
自動的に制限される場合があります。リビジョンバッファがログバッファから表
示される場合、リビジョンバッファは、そのログバッファと同じファイル制限を
共有します(コマンド‘magit-diff-toggle-file-filter’も参照してください)。

 -- User Option: magit-revision-filter-files-on-follow
     ログ引数に‘--follow’が含まれている場合に、ログバッファからのコミッ
     トを表示するかどうかは、ログのファイルフィルターを尊重します。

     このオプションがnilの場合、ログ引数に‘--follow’が含まれていると、ロ
     グからのコミットの表示はログのファイルフィルターを無視します。そう
     することで、名前変更イベントの前にコミット用のリビジョンバッファに
     空のdiffが表示されないようにします。このような場合、ログ用トランジ
     ェントコマンドの‘--patch’引数を使用して、ファイル制限されたdiff達を
     インラインで表示できます。

     ‘--follow’がログ引数に存在する場合でもログのファイル制限を維持する
     には、このオプションを非nilに設定します。

リビジョンバッファがログバッファから表示されない場合、ファイル制限は通常
どおりに決定されます(*note Transient Arguments and Buffer Variables::)。


File: magit.ja.info,  Node: Ediffing,  Next: References Buffer,  Prev: Diffing,  Up: Inspecting

5.5 Ediffing
============

このセクションでは、MagitバッファからEdiffを入力する方法について説明しま
す。 Ediff自体の使用方法についてはこちらを参照して下さい(*note
(ediff)Top::)。

‘e’ (‘magit-ediff-dwim’)
     Ediffを使用して比較(compare)またはステージ(stage)または解決
     (resolve)します。

     このコマンドは、Ediffを使用して、ユーザーが比較(compare)またはステ
     ージ(stage)または解決(resolve)したいファイルと、コミットまたは範囲
     (range)を推測しようとします。ファイルまたは範囲(range)/コミットのい
     ずれかを推測することしかできない場合があります。その場合、ユーザー
     はもう一方について尋ねられます。常に正しく推測できるとは限りません
     。その場合、適切な‘magit-ediff-*’コマンドを明示的に使用する必要があ
     ります。Magitがユーザーの心をまったく読み取れない場合は、実行するコ
     マンドをユーザーに要求します。

‘E’ (‘magit-ediff’)
     このトランジェント(一時的)プレフィックス(接頭辞)コマンドは、それに
     従うサフィックス(接尾辞)コマンド群を結びつけ、そのサフィックスコマ
     ンドのどれかを選ぶまでの間、サフィックス(接尾辞)コマンド群を一時バ
     ッファ(temporary buffer)に表示します。

‘E r’ (‘magit-ediff-compare’)
     Ediffを使用してファイルの2つのリビジョンを比較します。

     リージョンがアクティブな場合は、リージョンの最初と最後の行のリビジ
     ョンを使用します。プレフィックス引数を使用して、リビジョンを比較す
     る代わりに、両方のリビジョンの共通の祖先から開始して、変更を表示す
     るリビジョンを選択します(つまり、"..."の範囲を使用します)。

‘E m’ (‘magit-ediff-resolve-rest’)
     このコマンドを使用すると、Ediff を使用して、ポイントしているファイ
     ルのファイル内の未解決の競合を解決できます。 ポイントしているファイ
     ルがない場合、またはマージされていない変更がない場合、このコマンド
     はファイルの入力を促します。

     ‘merge.conflictstyle’の値が‘diff3’の場合、Ediff制御バッファで‘/’を
     使用してファイルのマージベースリビジョン(merge-base revision)を表示
     できます。

     AとBと Ancestor(先祖) バッファーは、ワークツリーファイル内の競合マ
     ーカーから構築されます。 あなたや Git が既にいくつかの競合を解決し
     ている可能性があるため、これらのバッファーにはそれぞれのブロブの実
     際のバージョンが含まれていない可能性があります。

‘E m’ (‘magit-ediff-resolve-all’)
     このコマンドを使用すると、あなたは Ediff を使用してその時点でファイ
     ル内のすべての競合を解決できます。 ポイントしているファイルがない場
     合、またはマージされていない変更がない場合、このコマンドはファイル
     の入力を促します。

     ‘merge.conflictstyle’の値が‘diff3’の場合、Ediff制御バッファで‘/’を
     使用してファイルのマージベースリビジョン(merge-base revision)を表示
     できます。

     まず、ワークツリー内のファイルが脇に移動され、サフィックス ‘.ORIG’
     が追加されるため、後でそのバージョンに戻ることができます。 次に、競
     合の 2 つの側面とマージ ベース (利用可能な場合) から再構築されます
     。

     ワークツリーのファイルをそのまま使用できればよいのですが、Ediff は
     それをサポートしていません。 これは、Git が既に解決したすべての競合
     が復元(restore)されることを意味します。 一方、Ediff も競合を解決し
     ようとします。多くの場合、Ediff と Git は同様の結果を生成するはずで
     す。

     ただし、一部の競合を手動で解決済みの場合、それらの変更は破棄されま
     す (ただし、バックアップ ファイルから復元(recover)することはできま
     す)。 そのような場合、 ‘magit-ediff-resolve-rest’ の方が適切かもし
     れません。

     このコマンドが ‘magit-ediff-resolve-rest’ よりも優れている点は、Aと
     Bと Ancestorバッファーがそれぞれのコミットのブロブに対応しているた
     め、コンテキスト内でその側を検査し、バッファ内でそうするための
     Magit コマンドを使用できることです。 Blame コマンドと log コマンド
     は、ここで特に役立ちます。

‘E t’ (‘magit-git-mergetool’)
     このコマンドは、実際には Ediff を使用しません。
     ‘magit-ediff-resolve-rest’ と同じ目的を果たしますが、‘git mergetool
     --gui’ を使用して競合を解決します。

     前置引数を使用すると、これは一時的な前置コマンドとして機能し、ユー
     ザーが mergetool を選択して一部の設定を変更できるようにします。

‘E s’ (‘magit-ediff-stage’)
     Ediffを使用してファイルへの変更をステージ(stage)およびステージ解除
     (unstage)します。デフォルトではそのポイントのファイルを対象にします
     。

‘E u’ (‘magit-ediff-show-unstaged’)
     Ediffを使用して、ファイルへのステージされていない変更(unstaged
     changes)を表示します。

‘E i’ (‘magit-ediff-show-staged’)
     Ediffを使用してファイルのステージされた変更(staged changes)を表示し
     ます。

‘E w’ (‘magit-ediff-show-working-tree’)
     Ediffを使用して、‘HEAD’と作業ツリーの間のファイルの変更を表示します
     。

‘E c’ (‘magit-ediff-show-commit’)
     Ediffを使用したコミットによって導入されたファイル(file introduced)へ
     の変更を表示します。

‘E z’ (‘magit-ediff-show-stash’)
     Ediffを使用してstashによって導入されたファイルへの変更を表示します
     。

 -- User Option: magit-ediff-dwim-resolve-function
     このオプションは、競合を解決するために ‘magit-ediff-dwim’ が使用す
     る関数を制御します。 ‘magit-ediff-resolve-rest’ または
     ‘magit-ediff-resolve-all’ または ‘magit-git-mergetool’ のいずれ一つ
     です。 これらすべてはで説明されています。

 -- User Option: magit-ediff-dwim-show-on-hunks
     このオプションは、ポイントがコミットされていないハンク上にあるとき
     に‘magit-ediff-dwim’が呼び出すコマンドを制御します。nilの場合、常に
     ‘magit-ediff-stage’を実行します。それ以外の場合は、
     ‘magit-ediff-show-staged’と‘magit-ediff-show-unstaged’を使用して、
     それぞれステージされた変更(staged changes)とステージされていない変
     更(unstaged changes)を表示します。

 -- User Option: magit-ediff-show-stash-with-index
     このオプションは、‘magit-ediff-show-stash’にスタッシュが作成された
     ときのインデックス内のファイルの状態を含むバッファを含めるかどうか
     を制御します。 これにより、スタッシュのどの変更がステージ(stage)さ
     れたかを知ることができます。

 -- User Option: magit-ediff-quit-hook
     このフックは、Magitコマンドを使用して作成されたEdiffセッションを終
     了した後に実行されます。フック関数はEdiff制御バッファ内で実行され、
     現在のバッファを変更すべきではありません。

     これは‘ediff-quit-hook’に似ていますが、Magitのニーズを考慮に入れて
     います。通常の‘ediff-quit-hook’は、Magitコマンドを使用して作成され
     たEdiffセッションでは無視されます。


File: magit.ja.info,  Node: References Buffer,  Next: Bisecting,  Prev: Ediffing,  Up: Inspecting

5.6 References Buffer
=====================

‘y’ (‘magit-show-refs’)
     このコマンドは、専用バッファ内のブランチとタグを一覧表示します。

     けれども、このコマンドがこのバッファから再度呼び出された場合、また
     はプレフィックス(接頭辞)引数を指定して呼び出された場合は、トランジ
     ェントプレフィックスコマンドとして機能し、それに従うサフィックスコ
     マンドといくつかのインフィックス引数を結び付けます。

それに従うすべてのサフィックスコマンドは、まったく同じブランチとタグを一
覧表示します。唯一の違いは、‘magit-refs-show-commit-count’の値を変更する
ことで有効にできるオプション機能です(以下を参照)。これらのコマンドは、他
のすべてのreferencesが比較される別のブランチまたはコミットを指定します。

‘y y’ (‘magit-show-refs-head’)
     このコマンドは、専用バッファ内のブランチとタグを一覧表示します。各
     referenceは‘HEAD’と比較されています。

‘y c’ (‘magit-show-refs-current’)
     このコマンドは、専用バッファ内のブランチとタグを一覧表示します。各
     referenceは、現在のブランチまたはdetachされている場合は‘HEAD’と比較
     されます。

‘y o’ (‘magit-show-refs-other’)
     このコマンドは、専用バッファ内のブランチとタグを一覧表示します。各
     referenceは、ユーザーから読み取られたブランチと比較されています。

‘y r’ (‘magit-refs-set-show-commit-count’)
     このコマンドは、コミットカウント(the commit count)が表示される
     refsを変更します。

 -- User Option: magit-refs-show-commit-count
     Magit-Refsモードのバッファでコミット数を表示するかどうか。

        • ‘all’ ブランチとタグのカウントを表示します。
        • ‘branch’ ブランチのカウントのみを表示します。
        • ‘nil’ カウントを表示しません。

     デフォルトは‘nil’です。他のものは非常に重い処理になる可能性があるた
     めです。

 -- User Option: magit-refs-pad-commit-counts
     Magit-Refsモードバッファのすべての脇(side)ですべてのコミットカウン
     トをパディングするかどうか。

     これがnilの場合、一部のコミットカウントは、カウントの横に表示される
     ブランチの1つのすぐ隣に、間にスペースを入れずに表示されます。ブラン
     チ名のfaceが‘magit-dimmed’に似すぎている場合、これは見栄えが悪い可
     能性があります。

     これがnil以外の場合、スペースがすべてのコミットカウントの両側に配置
     されます。

 -- User Option: magit-refs-show-remote-prefix
     リモートブランチのリストにremote prefixを表示するかどうか。

     リモートの名前はそのブランチのリストの前の見出しにすでに表示されて
     いるため、prefixの表示は冗長です。

 -- User Option: magit-refs-primary-column-width
     ‘magit-refs-mode’バッファのprimary列の幅。primary列は、現在の行が含
     まれているブランチの名前を含む列です。

     これが整数の場合、列の幅がその整数になります。それ以外の場合は、2つ
     の整数のコンスセルである必要があります。 1つ目は最小幅を指定し、2つ
     目は最大幅を指定します。その場合、実際の幅は、表示されているローカ
     ルブランチの名前の長さを使用して決定されます。(最適な幅に計算する場
     合、リモートブランチとタグは考慮されません。)

 -- User Option: magit-refs-focus-column-width
     ‘magit-refs-mode’バッファのfocus列の幅。

     focus列は最初の列であり、‘*’または‘@’を使用して、1つのブランチ(通常
     は現在のブランチ)をフォーカスされたブランチとしてマークします。他の
     referenceごとに、このfocus列はオプションで、フォーカスされたブラン
     チと‘<’の前にあるコミットの数を示します。前にない場合は、後ろにある
     コミットと‘>’を示します。前にも後ろにも無い場合は‘=’です。

     この列には、フォーカスされたブランチの‘*’または‘@’のみが表示される
     場合もあります。その場合、このオプションは無視されます。‘L v’を使用
     して、この列の詳細度を変更します。

 -- User Option: magit-refs-margin
     このオプションは、欄外(margin)が最初にMagit-Refsモードのバッファに
     表示されるかどうか、およびそのフォーマット方法を指定します。

     値の形式は‘(INIT STYLE WIDTH AUTHOR AUTHOR-WIDTH)’です。

        • INITがnil以外の場合、欄外(margin)が最初に表示されます。
        • STYLEは、作成者(author)またはコミッター(committer)の日付をフォ
          ーマットする方法を制御します。‘age’(コミットの経過時間を示す
          )または‘age-abbreviated’(時間単位を文字に短縮する)または実際の
          日付を表す文字列(‘format-time-string’に適しています)のいずれか
          になります。オプション‘magit-log-margin-show-committer-date’は
          、表示される日付を制御します。
        • WIDTHは、欄外(margin)の幅を制御します。これは上位互換性のため
          に存在し、現在値を変更すべきではありません。
        • AUTHORは、作成者の名前もデフォルトで表示されるかどうかを制御し
          ます。
        • AUTHOR-WIDTHは整数である必要があります。作成者の名前が表示され
          ている場合、これはそのために使用されるスペース(空き)の量を指定
          します。

 -- User Option: magit-refs-margin-for-tags
     このオプションは、欄外(margin)にタグに関する情報を表示するかどうか
     を指定します。タグが多いと遅いため、デフォルトでは無効になっていま
     す。

以下の変数は、個々のrefsの表示方法を制御します。これらの変数の1つ(特に
"%c"の部分)を変更する場合は、他の変数も変更して、調整を維持する必要があ
ります。以下の%シーケンスがサポートされています:

   • ‘%a’ このrefが比較したコミットを超えるコミットの数。
   • ‘%b’ 比較するrefのコミット数がこれを超えています。
   • ‘%c’ このrefが比較したコミットを超えるコミットの数。他のすべての
     refが比較されるrefの場合、これは、現在のブランチの場合は代わりに
     "@"、それ以外の場合は"#"になります。
   • ‘%C’ 他のすべてのrefが比較されるrefの場合、これは現在のブランチの場
     合は"@"、それ以外の場合は"#"です。 他のすべての参照は" "です。
   • ‘%h’ このrefのtipのハッシュ。
   • ‘%m’ このrefのtipの要約をコミットします。
   • ‘%n’ このrefの名前。
   • ‘%u’ このローカルブランチのupstream。
   • ‘%U’ このローカルブランチのアップストリームおよび追加のローカル情報
     とアップストリーム情報。

 -- User Option: magit-refs-filter-alist
     このオプションの目的は、名前に基づいて特定のrefを表示しないようにす
     ることです。特定のタイプのrefを表示したくない場合は、代わりに
     ‘magit-refs-sections-hook’から適切な関数を削除する必要があります。

     このalistは、‘magit-refs-mode’バッファに表示されないようにするタグ
     とブランチを制御します。‘nil’の場合、すべてのrefが表示されます
     (‘magit-refs-sections-hook’に従います)。

     1つが一致するまで、すべてのキーが順番に試行されます。 次に、その値
     が使用され、後続の要素は無視されます。値がnil以外の場合はその
     referenceが表示され、そうでない場合は表示されません。 一致する要素
     がない場合は、そのreferenceが表示されます。

     キーは、refnameが一致する必要のある正規表現、またはrefnameを引数と
     してのみ受け取り、ブール値を返す関数のいずれかです。
     "origin/master"などのリモートブランチは単に"master"として表示されま
     すが、この比較では前者が使用されます。

‘<RET>’ (‘magit-visit-ref’)
     このコマンドは、別のバッファ内のポイントでreferenceまたはリビジョン
     を訪問します。ポイントにリビジョンがない場合、またはプレフィックス
     引数がある場合は、リビジョンの入力を求められます。

     このコマンドは、ポイントが‘magit-refs-mode’バッファ内のreference上
     にある場合を除いて、上記の‘magit-show-commit’と同じように動作します
     。あなたがオプション‘magit-visit-ref-behavior’をカスタマイズした場
     合、動作は異なる可能性があります。

 -- User Option: magit-visit-ref-behavior
     このオプションは、‘magit-visit-ref’が‘magit-refs-mode’バッファでど
     のように動作するかを制御します。

     デフォルトでは、‘magit-visit-ref’は‘magit-refs-mode’バッファを含む
     すべてのバッファで、‘magit-show-commit’のように動作します。ポイント
     あるセクションのタイプが‘commit’の場合、「RET」は
     ‘magit-show-commit’に結び付けられ、タイプが‘branch’または‘tag’の場
     合、‘magit-visit-ref’に結び付けられています。

     「RET」はMagitの最も重要なキーの1つであり、少なくともデフォルトでは
     、Magit全体で一貫して動作する必要があります。特に、ユーザーには非常
     に無害なことをすぐに理解できるようにするためです。別のバッファ内の
     ポイントにあるものに関する詳細情報が表示されます。

     けれども、「RET」は‘magit-refs-mode’バッファで異なる動作をし、驚く
     べきことを実行していました。その中には、「これこれを訪問する」
     (visit this thing)とは実際には説明できないものもあります。この動作
     に慣れている場合は、このオプションの値に以下のシンボルを1つ以上追加
     することで、この動作を復元できます。 ただし、そうすることで不整合が
     発生するだけでなく、一部の機能が失われ、‘M-x magit-show-commit’を使
     用して元に戻す必要がある場合があることに注意してください。

     ‘magit-visit-ref’は、ここで説明されている順序でこれらのシンボルを検
     索します。シンボルの存在が現在の状況に当てはまる場合、後続のシンボ
     ルは結果に影響を与えません。

        • ‘focus-on-ref’

          プレフィックス引数を使用してバッファを更新し、現在のバッファま
          たは‘HEAD’ではなく、そのポイントでのreferenceに関連するコミッ
          ト数とcherry commitのリストを表示します。

          このシンボルを追加する代わりに、"C-u y o RET"を押すことを検討
          してください。

        • ‘create-branch’

          ポイントがリモートブランチ上にある場合は、同じ名前で新しいロー
          カルブランチを作成し、リモートブランチをアップストリームとして
          使用してから、ローカルブランチをチェックアウトします。

          このシンボルを追加する代わりに、他のバッファで行うように、"b c
          RET RET"を押すことを検討してください。

        • ‘checkout-any’

          ポイントでreferenceをチェックアウトします。そのreferenceがタグ
          またはリモートブランチである場合、これにより‘HEAD’がdetachされ
          ます。

          このシンボルを追加する代わりに、他のバッファで行うように、"b b
          RET"を押すことを検討してください。

        • ‘checkout-branch’

          ポイントでローカルブランチをチェックアウトしてください。

          このシンボルを追加する代わりに、他のバッファで行うように、"b b
          RET"を押すことを検討してください。

* Menu:

* References Sections::      References Sections


File: magit.ja.info,  Node: References Sections,  Up: References Buffer

5.6.1 References Sections
-------------------------

参照バッファ(references buffers)の内容は、フック
‘magit-refs-sections-hook’を使用して制御されます。このようなフックとそれ
らをカスタマイズする方法については、こちらを参照して下さい(*note Section
Hooks::)。以下の関数はすべてデフォルト値のメンバーです。注意: このフック
をカスタマイズすることは、ステータスバッファに使用されるそれぞれのフック
よりもはるかに意味がないことに注意してください。

 -- User Option: magit-refs-sections-hook
     フックを実行して、セクションをreferenceバッファに挿入します。

 -- Function: magit-insert-local-branches
     すべてのローカルブランチを表すセクションを挿入します。

 -- Function: magit-insert-remote-branches
     すべてのリモート追跡(remote-tracking)ブランチを表すセクションを挿入
     します。

 -- Function: magit-insert-tags
     すべてのタグを表示するセクションを挿入します。


File: magit.ja.info,  Node: Bisecting,  Next: Visiting Files and Blobs,  Prev: References Buffer,  Up: Inspecting

5.7 Bisecting
=============

こちらもご覧下さい *note (gitman)git-bisect::

‘B’ (‘magit-bisect’)
     このトランジェント(一時的)プレフィックス(接頭辞)コマンドは、それに
     従うサフィックス(接尾辞)コマンド群を結びつけ、そのサフィックスコマ
     ンドのどれかを選ぶまでの間、サフィックス(接尾辞)コマンド群を一時バ
     ッファ(temporary buffer)に表示します。

bisectが進行中でない場合、トランジェントコマンド(transient)にはそれに従
うサフィックスコマンドがあります。

‘B B’ (‘magit-bisect-start’)
     bisectセッションを開始します。

     バグを二分探索(bisect)するということは、バグを引き起こしたコミット
     を見つけることを意味します。このコマンドは、既知の良好なコミットと
     既知の不良コミットを要求することにより、このようなbisectセッション
     を開始します。 あなたがデグレ(regression)ではない変更について二分探
     索する場合は、"bad"と"good"よりも概念的に適切な代替用語を選択できま
     すが、そうするためのインフィックス引数はデフォルトでは無効になって
     います。

‘B s’ (‘magit-bisect-run’)
     各ステップの後にコマンドを実行することにより、自動的にbisectします
     。

進行中のbisectの場合、トランジェントコマンドには代わりのサフィックスコマ
ンドがあります。

‘B b’ (‘magit-bisect-bad’)
     現在のコミットをbadとしてマークします。コミットに問題のバグが含まれ
     ていることを表明します。

‘B g’ (‘magit-bisect-good’)
     現在のコミットをgoodとしてマークします。 コミットに問題のバグが含ま
     れていないことを表明します。

‘B m’ (‘magit-bisect-mark’)
     現在のコミットをbisectの用語の1つでマークします。このコマンドは、
     ‘magit-bisect-bad’および‘magit-bisect-good’の代替を提供し、「bad」
     および「good」以外の用語を使用する場合に役立ちます。このサフィック
     スコマンドはデフォルトでは無効になっています。

‘B k’ (‘magit-bisect-skip’)
     現在のコミットをスキップします。何らかの理由で現在のコミットがテス
     トに適していない場合に役立ちます。このコマンドにより、Gitは別のコミ
     ットを選択できます。

‘B r’ (‘magit-bisect-reset’)
     bisect後、bisect状態をクリーンアップし、元の‘HEAD’に戻します。

デフォルトでは、ステータスバッファには、進行中のbisectセッションに関する
情報が表示されます。

 -- User Option: magit-bisect-show-graph
     このオプションは、まだbisectする必要があるコミットのログのグラフを
     表示するかどうかを制御します。


File: magit.ja.info,  Node: Visiting Files and Blobs,  Next: Blaming,  Prev: Bisecting,  Up: Inspecting

5.8 Visiting Files and Blobs
============================

Magitは、ファイルまたはblob(特定のコミットに保存されているファイルのバー
ジョン)を訪問するいくつかのコマンドを提供します。 実際には、そのようなコ
マンドのいくつかの「グループ」と、各グループ内のいくつかの「バリエーショ
ン」を提供します。

* Menu:

* General-Purpose Visit Commands::  General-Purpose Visit Commands
* Visiting Files and Blobs from a Diff::  Visiting Files and Blobs from a
                                            Diff


File: magit.ja.info,  Node: General-Purpose Visit Commands,  Next: Visiting Files and Blobs from a Diff,  Up: Visiting Files and Blobs

5.8.1 General-Purpose Visit Commands
------------------------------------

これらのコマンドは、任意のblobを開くためにどこでも使用できます。現在、デ
フォルトではこれらのコマンドに結び付けられているキーはありませんが、変更
される可能性はあります。

 -- Command: magit-find-file
     このコマンドは、ユーザーからファイル名とリビジョンを読み取り、バッ
     ファ内でそれぞれのBLOBを訪問します。選択したウィンドウにバッファが
     表示されます。

 -- Command: magit-find-file-other-window
     このコマンドは、ユーザーからファイル名とリビジョンを読み取り、バッ
     ファ内でそれぞれのBLOBを訪問します。バッファは別のウィンドウに表示
     されます。

 -- Command: magit-find-file-other-frame
     このコマンドは、ユーザーからファイル名とリビジョンを読み取り、バッ
     ファ内でそれぞれのBLOBを訪問します。バッファは別のフレームに表示さ
     れます。


File: magit.ja.info,  Node: Visiting Files and Blobs from a Diff,  Prev: General-Purpose Visit Commands,  Up: Visiting Files and Blobs

5.8.2 Visiting Files and Blobs from a Diff
------------------------------------------

以下のコマンドは、ポイントがdiff内にある場合にのみ使用できます。

‘<RET>’ (‘magit-diff-visit-file’)
     このコマンドは、diff内のポイントのところのファイルの適切なバージョ
     ンを訪問します。

     このコマンドは、適切なファイルの作業ツリーバージョンを訪問します。
     diff内のポイントの位置によって、訪問するファイルが決まります。訪問
     したバージョンは、diffがどのような変更であるかによって異なります。

       1. diffにコミットされていない変更(つまり、ステージされた変更
          (staged changes)またはステージされていない変更(unstaged
          changes))が表示される場合は、作業ツリー内のファイル(つまり、
          ‘find-file’が訪問するのと同じ「実際の」ファイル)を訪問します。
          それ以外の場合は、blob(つまり、コミットに保存されているファイ
          ルのバージョン)を訪問します。

       2. ポイントが、削除された行にある場合は、その行を削除したコミット
          の最初の親、つまりその行がまだ存在する最後のコミットのblobを訪
          問します。

       3. ポイントが、追加された行またはコンテキスト行にある場合は、その
          行を追加するblobを訪問します。または、diffが複数のコミットから
          表示される場合は、これらの最後のコミットからblobを訪問します。

     file-visitingバッファでは、このコマンドは、diffでポイントがある行に
     対応する行に移動します。

     選択したウィンドウにバッファが表示されます。プレフィックス引数を使
     用すると、その代わりにバッファが別のウィンドウに表示されます。

 -- User Option: magit-diff-visit-previous-blob
     このオプションは、‘magit-diff-visit-file’が前のblobを訪問できるかど
     うかを制御します。これが‘t’（デフォルト）であり、コミットされた変更
     のdiff内の削除された行にポイントがある場合、
     ‘magit-diff-visit-file’はその行がまだ残っている最後のリビジョンの
     blobを訪問します。

     現在、これはコミットされた変更に対してのみサポートされています。ス
     テージされた変更(staged changes)とステージされていない変更(unstaged
     changes)の場合、‘magit-diff-visit-file’は常に作業ツリー内のファイル
     を訪問します。

‘C-<return>’ (‘magit-diff-visit-file-worktree’)
     このコマンドは、適切なファイルの作業ツリーバージョンを訪問します。
     diff内のポイントの位置によって、訪問されるファイルが決まります。
     ‘magit-diff-visit-file’とは異なり、常に作業ツリー内の「実際の」ファ
     イル、つまりファイルの「現在のバージョン」を訪問します。

     file-visitingバッファでは、このコマンドは、diffでポイントある行に対
     応する行に移動します。作業ツリーで追加または削除された行、インデッ
     クス、およびその間のその他のコミットは、自動的に考慮されます。

     選択したウィンドウにバッファが表示されます。プレフィックス引数を使
     用すると、その代わりにバッファが別のウィンドウに表示されます。

上記の2つのコマンドのバリエーションがあります。それらは上記の代わりに別
のウィンドウまたは別のフレームでファイルを訪問します。このような動作が必
要な場合は、上記のキーバインディングを変更することをお勧めしますが、上記
のコマンドは、プレフィックス引数を指定して呼び出されたときに別のウィンド
ウも使用することに注意してください。

 -- Command: magit-diff-visit-file-other-window
 -- Command: magit-diff-visit-file-other-frame
 -- Command: magit-diff-visit-worktree-file-other-window
 -- Command: magit-diff-visit-worktree-file-other-frame


File: magit.ja.info,  Node: Blaming,  Prev: Visiting Files and Blobs,  Up: Inspecting

5.9 Blaming
===========

こちらもご覧下さい *note (gitman)git-blame::

blameを開始するには、‘C-c M-g’を押して、‘magit-file-dispatch’のトランジ
ェントプレフィックスコマンドを呼び出します。

blameサフィックスコマンドは、ディスパッチトランジェントコマンドから呼び
出すことができます。 ただし、インフィックス引数を設定する場合は、最初に
blameサブトランジェントコマンドを入力する必要があります。

以下に示すキーバインディングは、デフォルトのバインディングを使用してディ
スパッチトランジェントコマンドを入力することを前提としています。

‘C-c M-g B’ (‘magit-blame’)
     このトランジェント(一時的)なプレフィックス(接頭辞)コマンドは、それ
     に従うサフィックス(接尾辞)コマンドを適切なインフィックス(中置)引数
     とともに結び付け、いずれかのサフィックスコマンドを選択するまでの間
     、そのインフィックス引数達とサフィックスコマンド達を一時バッファ
     (temporary buffer)に表示します。

注意: 以下のサフィックスコマンドのすべてが常に使用できるわけではないこと
に注意してください。たとえば、‘magit-blame-mode’が有効になっていない場合
、そのモードをオフにすることを目的としたコマンドは役に立たないため、使用
できません。

‘C-c M-g b’ (‘magit-blame-addition’)
‘C-c M-g B b’
     このコマンドは、現在のfile-visitingまたはblob-visitingバッファ内の
     各行または行のチャンクに、これらの行に最後にアクセス(touch)したコミ
     ットに関する情報を追加します。

     バッファがそのファイルのリビジョンを訪問すると、そのリビジョンまで
     の履歴が考慮されます。それ以外の場合は、コミットされていない変更を
     含む、ファイルの完全な履歴が考慮されます。

     現在のバッファでMagit-Blameモードがすでにオンになっている場合は、
     REVISION:FILEを訪問して(‘magit-find-file’を使用)、再帰的にblameを行
     います。ここで、REVISIONは、現在の行または行のチャンクを追加したリ
     ビジョンの親です。

‘C-c M-g r’ (‘magit-blame-removal’)
‘C-c M-g B r’
     このコマンドは、現在のblob-visitingバッファ内の各行または行のチャン
     クを、それを削除するリビジョンに関する情報で補強します。
     file-visitingバッファでは使用できません。

     ‘magit-blame-addition’と同様に、このコマンドは再帰的に使用できます
     。

‘C-c M-g f’ (‘magit-blame-reverse’)
‘C-c M-g B f’
     このコマンドは、現在のfile-visitingまたはblob-visitingバッファ内の
     各行または行のチャンクに、行がまだ存在していた最後のリビジョンに関
     する情報を追加します。

     ‘magit-blame-addition’と同様に、このコマンドは再帰的に使用できます
     。

‘C-c M-g e’ (‘magit-blame-echo’)
‘C-c M-g B e’
     このコマンドは‘magit-blame-addition’に似ていますが、
     ‘read-only-mode’がオンにならず、最初はオプション
     ‘magit-blame-echo-style’で指定された視覚化スタイルを使用する点が異
     なります。

Magit-Blameモードが有効で、読み取り専用モードが有効になっていない場合は
、以下のキーバインディングを使用できます。これらのコマンドは、他のバッフ
ァでも使用できます。ここでは、blameされているfile-visitingバッファに関連
する動作のみが説明されています。

‘<RET>’ (‘magit-show-commit’)
     このコマンドは、ポイントで行に最後に触れたコミットを表示します。

‘<SPC>’ (‘magit-diff-show-or-scroll-up’)
     このコマンドは、コミットバッファを更新します。

     これは、適切なバッファ内のポイントで最後に行に触れたコミットを示し
     ます。または、そのバッファが現在のフレームに既に表示されていて、そ
     のバッファにそのコミットに関する情報が含まれている場合は、代わりに
     バッファが上にスクロールされます。

‘<DEL>’ (‘magit-diff-show-or-scroll-down’)
     このコマンドは、コミットバッファを更新します。

     これは、適切なバッファ内のポイントで最後に行に触れたコミットを示し
     ます。または、そのバッファが現在のフレームに既に表示されていて、そ
     のバッファにそのコミットに関する情報が含まれている場合は、代わりに
     バッファが下にスクロールされます。

以下のキーバインディングは、Magit-Blameモードと読み取り専用モードの両方
が有効になっている場合に使用できます。

‘b’ (‘magit-blame’)
     上記参照。

‘n’ (‘magit-blame-next-chunk’)
     このコマンドは次のチャンクに移動します。

‘N’ (‘magit-blame-next-chunk-same-commit’)
     このコマンドは、同じコミットから次のチャンクに移動します。

‘p’ (‘magit-blame-previous-chunk’)
     このコマンドは前のチャンクに移動します。

‘P’ (‘magit-blame-previous-chunk-same-commit’)
     このコマンドは、同じコミットから前のチャンクに移動します。

‘q’ (‘magit-blame-quit’)
     このコマンドは、Magit-Blameモードをオフにします。 再帰的なblameの間
     にバッファが作成された場合は、バッファも強制終了します。

‘M-w’ (‘magit-blame-copy-hash’)
     このコマンドは、現在のチャンクのコミットのハッシュをキルリングに保
     存します。

     リージョンがアクティブな場合、コマンドは‘kill-ring-save’のように、
     ハッシュではなくリージョンのコンテンツを保存します。

‘c’ (‘magit-blame-cycle-style’)
     このコマンドは、オプション‘magit-blame-styles’を使用して指定された
     スタイルを循環することにより、現在のバッファでのblame情報の視覚化方
     法を変更します。

blameは、以下のオプションを使用して制御されます。

 -- User Option: magit-blame-styles
     このオプションは、blame情報を視覚化するために使用されるスタイルのリ
     ストを定義します。詳細については、今のところはそのdoc-stringを参照
     してください。

 -- User Option: magit-blame-echo-style
     このオプションは、コマンド‘magit-blame-echo’で使用されるblameの視覚
     化スタイルを指定します。 これは、‘magit-blame-styles’で定義されてい
     るスタイルの1つの識別子として使用されるシンボルである必要があります
     。

 -- User Option: magit-blame-time-format
     このオプションは、blame報を表示するときに時間を表示するために使用さ
     れる書式文字列を指定します。

 -- User Option: magit-blame-read-only
     このオプションは、バッファをblameすることで一時的に読み取り専用にす
     るかどうかを制御します。

 -- User Option: magit-blame-disable-modes
     このオプションは、バッファにblame情報が含まれている場合に一時的に無
     効にする必要がある互換性のないマイナーモードを一覧表示します。バッ
     ファにblame情報が表示されなくなると、これらは再び有効になります。

 -- User Option: magit-blame-goto-chunk-hook
     このフックは、チャンク間を移動するときに実行されます。


File: magit.ja.info,  Node: Manipulating,  Next: Transferring,  Prev: Inspecting,  Up: Top

6 Manipulating
**************

* Menu:

* Creating Repository::      Creating Repository
* Cloning Repository::       Cloning Repository
* Staging and Unstaging::    Staging and Unstaging
* Applying::                 Applying
* Committing::               Committing
* Branching::                Branching
* Merging::                  Merging
* Resolving Conflicts::      Resolving Conflicts
* Rebasing::                 Rebasing
* Cherry Picking::           Cherry Picking
* Resetting::                Resetting
* Stashing::                 Stashing


File: magit.ja.info,  Node: Creating Repository,  Next: Cloning Repository,  Up: Manipulating

6.1 Creating Repository
=======================

‘I’ (‘magit-init’)
     このコマンドは、リポジトリを初期化してから、新しいリポジトリのステ
     ータスバッファを表示します。

     ディレクトリが既存のリポジトリの下にある場合、ユーザーは新しいリポ
     ジトリを内部に作成する必要があることを確認する必要があります。ディ
     レクトリが既存のリポジトリのルートである場合、ユーザーはそれを再初
     期化する必要があることを確認する必要があります。


File: magit.ja.info,  Node: Cloning Repository,  Next: Staging and Unstaging,  Prev: Creating Repository,  Up: Manipulating

6.2 Cloning Repository
======================

リモートまたはローカルリポジトリのクローンを作成するには、コマンド
‘magit-clone’に結び付けられている‘C’を使用します。このコマンドは、いくつ
かのインフィックス引数とサフィックスコマンドを結びつけるするトランジェン
トプレフィックスコマンドとして機能するか、プレフィックス(接頭辞)引数が使
用されているかどうかと‘magit-clone-always-transient’の値に応じて、‘git
clone’を直接呼び出すことができます。

 -- User Option: magit-clone-always-transient
     このオプションは、プレフィックス(接頭辞)引数が使用されているかどう
     かに関係なく、コマンド‘magit-clone’が常にトランジェントプレフィック
     スコマンドとして機能するかどうかを制御します。‘t’の場合、そのコマン
     ドは常にトランジェントプレフィックスコマンドとして機能します。
     ‘nil’の場合、トランジェントコマンドとして機能させるには、プレフィッ
     クス引数を使用する必要があります。

‘C’ (‘magit-clone’)
     このコマンドは、上記のようにトランジェントプレフィックスコマンドと
     して機能するか、以下で説明するように‘transient-clone-regular’と同じ
     ことを行います。

     トランジェントプレフィックスコマンドとして機能する場合は、それに従
     うサフィックスコマンドといくつかのインフィックス引数が結び付けられ
     ます。

‘C C’ (‘magit-clone-regular’)
     このコマンドは、既存のリポジトリの通常のクローンを作成します。 リポ
     ジトリとターゲットディレクトリがユーザーから読み取られます。

‘C s’ (‘magit-clone-shallow’)
     このコマンドは、既存のリポジトリの浅いクローン(shallow clone)を作成
     します。リポジトリとターゲットディレクトリがユーザーから読み取られ
     ます。 デフォルトでは、複製される履歴の深さが1だけのコミットである
     クローンですが、プレフィックス引数を使用すると、その深さはユーザー
     から読み取られます。

‘C >’ (‘magit-clone-sparse’)
     このコマンドは、既存のリポジトリのクローンを作成し、スパースチェッ
     クアウト(sparse checkout;疎なチェックアウト)を初期化して、作業ツリ
     ー全部のチェックアウトを回避します。 さらにディレクトリを追加するに
     は、‘magit-sparse-checkout’ トランジェントを使用します (*note
     Sparse checkouts:: を参照)。

‘C b’ (‘magit-clone-bare’)
     このコマンドは、既存のリポジトリのbareクローンを作成します。リポジ
     トリとターゲットディレクトリがユーザーから読み取られます。

‘C m’ (‘magit-clone-mirror’)
     このコマンドは、既存のリポジトリのミラーを作成します。リポジトリと
     ターゲットディレクトリがユーザーから読み取られます。

以下のサフィックスコマンドはデフォルトで無効になっています。有効にする方
法についてはこちらを参照して下さい(*note (transient)Enabling and
Disabling Suffixes::)。

‘C d’ (‘magit-clone-shallow-since’)
     このコマンドは、既存のリポジトリの浅い(shallow)クローンを作成します
     。ユーザーから読み取られた日付の後にコミットされたコミットのみが複
     製され、リポジトリとターゲットディレクトリもユーザーから読み取られ
     ます。

‘C e’ (‘magit-clone-shallow-exclude’)
     このコマンドは、既存のリポジトリの浅い(shallow)クローンを作成します
     。ユーザーからブランチまたはタグが読み取られます。そのブランチまた
     はタグから到達可能なコミットを除外します。リポジトリとターゲットデ
     ィレクトリもユーザーから読み取られます。

 -- User Option: magit-clone-set-remote-head
     このオプションは、クローン作成によって reference
     ‘refs/remotes/<remote>/HEAD’ がクローンに作成されるかどうかを制御し
     ます。デフォルトでは、‘git clone’を実行した後、referenceを削除しま
     す。これにより、referenceの作成が要求されます。 これは、リモートの
     ‘HEAD’が変更されたときに自動的に更新されないため、referenceが特に有
     用であることが判明していないためです。このオプションを‘t’に設定する
     と、referenceを作成するというGitのデフォルトの動作が維持されます。

 -- User Option: magit-clone-set-remote.pushDefault
     このオプションは、クローン作成後にGit変数‘remote.pushDefault’の値を
     設定するかどうかを制御します。

        • ‘t’の場合、常に問い合わせ無しで設定されます。
        • ‘ask’の場合、ユーザーはリポジトリのクローンを作成するたびに問
          い合わせされます。
        • ‘nil’の場合、設定されません。

 -- User Option: magit-clone-default-directory
     このオプションは、クローン作成操作の宛先(destination)を読み取るとき
     に使用されるデフォルトのディレクトリ名を制御します。

        • ‘nil’（デフォルト）の場合、‘default-directory’の値が使用されま
          す。
        • ディレクトリの場合は、それが使用されます。
        • 関数の場合、それは唯一の引数としてリモートURLを使用して呼び出
          され、その戻り値が使用されます。

 -- User Option: magit-clone-name-alist
     このオプションは、リポジトリ名に一致する正規表現をリポジトリURLにマ
     ップし、ユーザーがリポジトリのクローンを作成するときにURLの代わりに
     短い名前を入力できるようにします。

     各要素の形式は‘(REGEXP HOSTNAME USER)’です。クローン作成コマンドが
     名前またはURLを要求したときにユーザーが名前を入力すると、それがこの
     リストで検索されます。REGEXPが一致する最初の要素が使用されます。

     オプション‘magit-clone-url-format’で指定された形式は、HOSTNAMEとリ
     ポジトリ名を使用して名前をURLに変換するために使用されます。指定され
     た名前にスラッシュが含まれている場合は、それが使用されます。それ以
     外の場合、名前でリポジトリの所有者が省略されている場合は、一致した
     エントリで指定されているデフォルトのユーザーが使用されます。

     USERにドットが含まれている場合、それはGit変数として扱われ、その値が
     ユーザー名として使用されます。それ以外の場合は、USERがユーザー名自
     体として使用されます。

 -- User Option: magit-clone-url-format
     このオプションで指定された形式は、リポジトリ名をURLに変換するときに
     使用されます。‘%h’はホスト名であり、‘%n’は所有者の名前を含むリポジ
     トリ名です。 値は、文字列(単一の静的フォーマットを表す)またはホスト
     名をフォーマットにマッピングする要素 ‘(HOSTNAME . FORMAT)’ を持つ
     alist にすることができます。 alist が使用される場合、‘nil’ キーはデ
     フォルトの形式を表します。

     単一のフォーマット文字列の例:

          (setq magit-clone-url-format
                "git@%h:%n.git")

     ホスト名によるフォーマット文字列の例:

          (setq magit-clone-url-format
                '(("git.example.com" . "git@%h:~%n")
                  (nil . "git@%h:%n.git")))


File: magit.ja.info,  Node: Staging and Unstaging,  Next: Applying,  Prev: Cloning Repository,  Up: Manipulating

6.3 Staging and Unstaging
=========================

もちろん、Gitと同様Magitは、完全なファイルをステージ(stage)およびステー
ジ解除(unstage)できます。Gitとは異なり、ユーザーは個々のハンクやハンクの
一部を適切にステージ/ステージ解除することもできます。Gitを直接使用して個
々のハンクとハンクの一部をステージするには、‘git add --interactive’セッ
ションの、モーダルでかなり不器用なインターフェースを使用する必要がありま
す。

一方、Magitを使用すると、ステータスバッファまたは別のdiffバッファに表示
されているdiff内のそれぞれのセクションにポイントを移動し、‘s’または‘u’と
入力するだけで、個々のハンクのステージを解除(unstage)/ステージ(stage)で
きます。ハンクの一部だけを操作するには、リージョンを使用してステージ/ス
テージ解除する必要のある変更にマークを付けてから、ステージ/ステージ解除
に使用するのと同じキーを押します。複数のファイルまたはハンクを一度にステ
ージするには、そのようなセクションの見出しの内側で始まり、同じタイプの兄
弟セクションの見出しの内側で終わるリージョンを使用します。

ステージ(stage)とステージ解除(unstage)に加えて、Magitは、ファイルや一度
に複数のファイルやハンクや一度に複数のハンクやハンクの一部を操作できる他
のいくつかの「適用バリエーション」(apply variants)も提供します。 これら
の適用バリエーション(apply variants)については、次の節で説明します。

あなたはEdiffを使用してステージ(stage)およびステージ解除(unstage)するこ
ともできます。こちらを参照して下さい(*note Ediffing::)。

‘s’ (‘magit-stage’)
     ポイントでの変更をステージ領域に追加します。

     プレフィックス引数と追跡されていないファイル(untracked file)(または
     複数のファイル)をポイントに指定して、ファイルをステージしますが、そ
     の内容はステージしません。これにより、新しいファイルの変更のサブセ
     ットのみをステージすることが可能になります。

‘S’ (‘magit-stage-modified’)
     ワークツリー内で変更されたファイルへのすべての変更をステージします
     。追跡中のファイル(tracked files)のすべての新しいコンテンツをステー
     ジし、もはや作業ツリーに存在しなくなった追跡中のファイル(訳注:つま
     り、削除されたファイル)をインデックスから削除します。プレフィックス
     引数を使用すると、まだ追跡中でない(ただし無視されない;訳注:つまり
     ‘.gitignore’の対象でない)ファイルもステージされます。

‘u’ (‘magit-unstage’)
     ステージ領域からポイントされた変更(the change)を削除します。

     ステージされた変更のみがステージ解除できます。 ただし、デフォルトで
     は、このコマンドは、コミットされた変更で呼び出されたときに、ステー
     ジ解除にいくらか似たアクションを実行します。インデックスの変更を元
     に戻しますが、作業ツリーでは元に戻しません。

‘U’ (‘magit-unstage-all’)
     ステージ領域からすべての変更を削除します。

 -- User Option: magit-unstage-committed
     このオプションは、‘magit-unstage’が変更をコミットしたかどうかを、作
     業ツリーではなくインデックスで逆にすることによって制御します。別の
     方法は、エラーを発生させることです。

‘M-x magit-reverse-in-index’
     このコマンドは、作業ツリーではなく、インデックス内のポイントでコミ
     ットされた変更を元に戻します。デフォルトでは、このコマンドに直接結
     び付けられたキーはありませんが、コミットされた変更で
     ‘u’(‘magit-unstage’)が押されると、間接的に呼び出されます。

     これにより、‘HEAD’から変更を抽出し、作業ツリーに残しておくことがで
     きるため、後で別のコミットを使用してコミットできます。典型的なワー
     クフローは以下のとおりです:

       1. (オプションで、コミットされていない変更がないことを確認します
          。)
       2. ‘HEAD’コミットを訪問し、そのコミットに含まれるべきではなかった
          変更に移動します。
       3. ‘u’(‘magit-unstage’)と入力して、インデックスで逆にします。これ
          は、‘magit-unstage-committed-changes’がnil以外であることを前提
          としています。
       4. ‘c e’と入力して、‘HEAD’を拡張し、以前に既にステージされた変更
          を含めます。
       5. オプションで、‘s’または‘S’を使用して残りの変更をステージし、‘c
          c’と入力して新しいコミットを作成します。

‘M-x magit-reset-index’
     インデックスをコミットにリセットします(Reset the index to some
     commit)。コミットはユーザーから読み取られ、デフォルトでその時点でコ
     ミットされます。その時点でコミットがない場合、デフォルトで‘HEAD’に
     なります。

* Menu:

* Staging from File-Visiting Buffers::  Staging from File-Visiting Buffers


File: magit.ja.info,  Node: Staging from File-Visiting Buffers,  Up: Staging and Unstaging

6.3.1 Staging from File-Visiting Buffers
----------------------------------------

きめ細かいステージ/ステージ解除は、ステータスまたはdiffバッファから実行
する必要がありますが、現在のバッファで訪問したファイルに加えられたすべて
の変更を、そのバッファ内から直接ステージ/ステージ解除することもできます
。

‘M-x magit-stage-file’
     file-visitingバッファ内で呼び出されると、そのファイルへのすべての変
     更をステージします。Magitバッファで、ファイルがある場合はその時点で
     ステージします。それ以外の場合は、ステージするファイルの入力を求め
     ます。プレフィックス引数を使用すると、file-visitingバッファ内やポイ
     ントにファイルセクションがある場合でも、常にユーザーにファイルの入
     力を求めるプロンプトが表示されます。

‘M-x magit-unstage-file’
     file-visitingバッファ内で呼び出された場合は、そのファイルへのすべて
     の変更をステージ解除します。 Magitバッファで、ある場合はその時点で
     ファイルのステージを解除します。それ以外の場合は、ファイルのステー
     ジを解除するように求められます。プレフィックス引数を使用すると、
     file-visitingバッファ内やポイントにファイルセクションがある場合でも
     、常にユーザーにファイルの入力を求めるプロンプトが表示されます。


File: magit.ja.info,  Node: Applying,  Next: Committing,  Prev: Staging and Unstaging,  Up: Manipulating

6.4 Applying
============

Magitはいくつかの適用バリエーションを提供します。それはステージ(stage)と
ステージ解除(unstage)と破棄(discard)と戻し(reverse)と通常のapply(regular
apply)です。少なくともハンクで操作する場合、それらはすべて‘git apply’を
使用して実装されます。そのため、これらは適用バリエーション("apply
variants")と呼ばれます。

   • ステージ(stage)。作業ツリーからインデックスに変更を適用(apply)しま
     す。変更は作業ツリーにも残ります。

   • ステージ解除(unstage)。インデックスから変更を削除します。 変更は作
     業ツリーに残ります。

   • 破棄(discard)。ステージされた変更(staged change)において、作業ツリ
     ーとインデックスから削除します。ステージされていない変更(unstaged
     change)では、作業ツリーからのみ削除します。

   • 戻し(reverse)。作業ツリーの変更を元に戻します。 コミットされた変更
     とステージされた変更(staged changes)の両方を元に戻すことができます
     。ステージされていない変更(unstaged changes)は元に戻すことはできな
     いので破棄(discard)します。

   • 適用(apply)。作業ツリーに変更を適用します。コミットされた変更とステ
     ージされた変更(staged changes)の両方を適用できます。ステージされて
     いない変更(unstaged changes)は適用できません。なぜならそれはすでに
     適用されているためです。

前節は、ステージコマンドとステージ解除コマンドについて説明しました。以下
は、残りの適用バリエーションを実装するコマンドです。

‘a’ (‘magit-apply’)
     ポイントでの変更を作業ツリーに適用(apply)します。

     プレフィックス引数を使用して、3方向マージにフォールバックします。こ
     れを行うと、変更がインデックスにも適用されます。

‘k’ (‘magit-discard’)
     ポイントでの変更を作業ツリーから削除します。

     競合が解決されていないハンクまたはファイルでは、どちらの側を保持す
     るかを確認します(もう一方を破棄します)。ポイントがそのどちらか側の
     テキスト内にある場合は、プロンプトを表示せずにその側を保持します。

‘v’ (‘magit-reverse’)
     作業ツリーのポイントの変更を元に戻します。

     プレフィックス引数を使用して、3方向マージにフォールバックします。こ
     れを行うと、変更がインデックスにも適用されます。

プレフィックス引数を使用すると、すべてのapplyバリエーションは、適切な場
合（つまり、‘git apply’が内部で使用される場合）に3方向マージを試行します
。


File: magit.ja.info,  Node: Committing,  Next: Branching,  Prev: Applying,  Up: Manipulating

6.5 Committing
==============

ユーザーがコミットを開始すると、Magitは引数なしで‘git commit’を呼び出す
ため、Gitはユーザーからコミットを取得する必要があります。ファイル
‘.git/COMMIT_EDITMSG’を作成し、そのファイルをエディターで開きます。
Magitは、そのエディターがEmacsclientになるように手配します。ユーザーが編
集セッションを終了すると、Emacsclientが終了し、Gitはファイルのコンテンツ
をメッセージとして使用してコミットを作成します。

* Menu:

* コミット開始::       コミット開始
* Editing Commit Messages::  Editing Commit Messages


File: magit.ja.info,  Node: コミット開始,  Next: Editing Commit Messages,  Up: Committing

6.5.1 コミット開始
------------------

こちらもご覧下さい *note (gitman)git-commit::

‘c’ (‘magit-commit’)
     このトランジェント(一時的)なプレフィックス(接頭辞)コマンドは、それ
     に従うサフィックス(接尾辞)コマンドを適切なインフィックス(中置)引数
     とともに結び付け、いずれかのサフィックスコマンドを選択するまでの間
     、そのインフィックス引数達とサフィックスコマンド達を一時バッファ
     (temporary buffer)に表示します。

‘c c’ (‘magit-commit-create’)
     ‘HEAD’に新しいコミットを作成します。プレフィックス引数を伴うと、代
     わりに‘HEAD’でコミットを修正(amend)します。

‘c a’ (‘magit-commit-amend’)
     最後のコミットを修正(amend)。

‘c e’ (‘magit-commit-extend’)
     メッセージを編集せずに、最後のコミットを修正します。プレフィックス
     引数を伴うとコミッターの日付(committer date)を保持します。それ以外
     の場合は変更します。 オプション
     ‘magit-commit-extend-override-date’を使用して、プレフィックス引数の
     意味を逆にすることができます。

     オプションのOVERRIDE-DATE引数を非対話的に尊重し、オプションを無視し
     ます。

‘c w’ (‘magit-commit-reword’)
     ステージされた変更を無視して、最後のコミットをreword(言い換え)しま
     す。 プレフィックス引数を使用してコミッターの日付を保持します。それ
     以外の場合は変更します。オプション
     ‘magit-commit-reword-override-date’を使用して、プレフィックス引数の
     意味を逆にすることができます。

     オプションのOVERRIDE-DATE引数を非対話的に尊重し、オプションを無視し
     ます。

‘c f’ (‘magit-commit-fixup’)
     fixupミットを作成します。

     プレフィックス引数を使用して、ターゲットコミットを確認する必要があ
     ります。 それ以外の場合、オプション‘magit-commit-squash-confirm’の
     値によっては、そのポイントでのコミットが確認なしで使用される可能性
     があります。

‘c F’ (‘magit-commit-instant-fixup’)
     fixupコミットを作成し、即座にリベースします。

‘c s’ (‘magit-commit-squash’)
     squashメッセージを編集せずに、squashコミットを作成します。

     プレフィックス引数を使用して、ターゲットコミットを確認する必要があ
     ります。 それ以外の場合、オプション‘magit-commit-squash-confirm’の
     値によっては、そのポイントでのコミットが確認なしで使用される可能性
     があります。

‘c S’ (‘magit-commit-instant-squash’)
     squashコミットを作成し、即座にリベースします。

‘c A’ (‘magit-commit-augment’)
     squashメッセージを編集して、squashコミットを作成します。

     プレフィックス引数を使用して、ターゲットコミットを確認する必要があ
     ります。 それ以外の場合、オプション‘magit-commit-squash-confirm’の
     値によっては、そのポイントでのコミットが確認なしで使用される可能性
     があります。

 -- User Option: magit-commit-ask-to-stage
     コミット時にステージされていないすべての変更(all unstaged changes)を
     ステージするよう問い合わせるか、あるいは何もステージしないか。

 -- User Option: magit-commit-show-diff
     コミット時に関連するdiffが自動的に表示されるかどうか。

 -- User Option: magit-commit-extend-override-date
     ‘magit-commit-extend’の使用によってコミッターの日付を変更するかどう
     か。

 -- User Option: magit-commit-reword-override-date
     ‘magit-commit-reword’の使用によってコミッターの日付を変更するかどう
     か。

 -- User Option: magit-commit-squash-confirm
     squashとfixupの対象となるコミットを確認する必要があるかどうか。
     nil以外の場合、ポイントでのコミット（存在する場合）がデフォルトの選
     択として使用されます。 それ以外の場合は確認する必要があります。この
     オプションは、‘magit-commit-squash’と‘magit-commit-fixup’にのみ影響
     します。「インスタント」バリエーションは、使用中にエラーが発生する
     と回復が困難になるため、常に確認が必要です。

 -- User Option: magit-post-commit-hook
     ユーザーがメッセージを編集せずにコミットを作成した後、フックを実行
     します。

     ‘this-command’が‘magit-post-stage-hook-commands’のメンバーである場
     合、このフックは‘magit-refresh’によって実行されます。これには、
     ‘magit-commit-*’という名前のコマンドのみが含まれ、ユーザーがバッフ
     ァ内のコミットメッセージを編集する必要は「ありません」。

     こちらもご覧下さい→‘git-commit-post-finish-hook’

 -- User Option: magit-commit-diff-inhibit-same-window
     コミット中にdiffを表示するときに同じウィンドウの使用を禁止するかど
     うか。

     コミットを書き込むと、コミットされる変更のdiffが自動的に表示されま
     す。このアイデアは、diffが同じフレームの別のウィンドウに表示され、
     ほとんどのユーザーにとっては正常に機能するというものです。言い換え
     ると、ほとんどのユーザーは、このオプションの値がユーザーに違いをも
     たらさないため、このオプションを完全に無視できます。

     ただし、パッケージが明示的に作成しようとしても新しいウィンドウを作
     成しないようにEmacsを構成したユーザーにとって、2つの新しいバッファ
     を表示すると、必然的に最初のバッファがすぐに2番目のバッファに置き換
     えられます。 私たちの場合、メッセージバッファはすぐにdiffバッファに
     置き換えられますが、これはもちろん非常に望ましくありません。

     回避策としては、この特定の場合にこのユーザー構成を抑制することです
     。 ユーザーは、このオプション切り替えに関して明示的に事前に同意
     (opt-in)を取る要があります。この回避策を無条件に有効にすることはで
     きません。これも他のユーザーに問題を引き起こすためです。フレームが
     小さすぎるか、関連する設定が強すぎると、diffバッファが新しいフレー
     ムに表示されることになります。

     こちらも参照下さい(<https://github.com/magit/magit/issues/4132>)。


File: magit.ja.info,  Node: Editing Commit Messages,  Prev: コミット開始,  Up: Committing

6.5.2 Editing Commit Messages
-----------------------------

前節で説明したようにコミットを開始すると、2つの新しいバッファが表示され
ます。1つはコミットされようとしている変更を示し、もう1つはメッセージの書
き込みに使用されます。

コミットメッセージは編集セッションで編集されます。バックグラウンドで
‘git’は、エディタ(この場合は‘emacsclient’)がコミットメッセージをファイル
(ほとんどの場合‘.git/COMMIT_EDITMSG’)に保存するのを待機しています。そし
て戻ります。エディタがゼロ以外の終了ステータスで戻った場合、‘git’はコミ
ットを作成しません。したがって、最も重要なコマンドは、コミットを終了およ
び中止するためのコマンドです。

‘C-c C-c’ (‘with-editor-finish’)
     終了コード0で戻ることにより、現在の編集セッションを終了します。次に
     、Gitは、ファイル内で見つけたメッセージを使用してコミットを作成しま
     す。

‘C-c C-k’ (‘with-editor-cancel’)
     終了コード1で戻ることにより、現在の編集セッションをキャンセルします
     。Gitはコミットをキャンセルしますが、ファイルは変更されません。

‘git commit’によって使用されることに加えて、メッセージはEmacsが閉じられ
るまで持続するリング(ring)に保存されることもあります。デフォルトでは、メ
ッセージは、(セッションが正常に終了したかキャンセルされたかに関係なく、
)編集セッションの開始時と終了時に保存されます。そのリングからメッセージ
を戻すと便利な場合があります。

‘C-c M-s’ (‘git-commit-save-message’)
     現在のバッファの内容をコミットメッセージリングに保存します。

‘M-p’ (‘git-commit-prev-message’)
     現在のメッセージをリングに保存した後、コミットメッセージリングを逆
     方向に循環します。数字のプレフィックス引数を付けると、コメントをそ
     の数字の個数分遡ります。

‘M-n’ (‘git-commit-next-message’)
     現在のメッセージをリングに保存した後、コミットメッセージリングを順
     方向に循環します。数字のプレフィックス引数を付けると、コメントをそ
     の数字の個数分遡ります。

デフォルトでは、コミットしようとしている変更のdiffは、コミットを呼び出す
ときに自動的に表示されます。これを防ぐには、‘server-switch-hook’から
‘magit-commit-diff’を削除します。

既存のコミットを修正するときは、そのコミットに追加されようとしている変更
を表示するか、すでにコミットされている変更と一緒にそれらの変更を表示する
と便利な場合があります。

‘C-c C-d’ (‘magit-diff-while-committing’)
     コミット中に、コミットしようとしている変更を表示します。修正中にコ
     マンドを再度呼び出すと、新しい変更のみを表示するか、コミットされる
     すべての変更を表示するかが切り替わります。

* Menu:

* Using the Revision Stack::  Using the Revision Stack
* Commit Pseudo Headers::    Commit Pseudo Headers
* Commit Mode and Hooks::    Commit Mode and Hooks
* Commit Message Conventions::  Commit Message Conventions


File: magit.ja.info,  Node: Using the Revision Stack,  Next: Commit Pseudo Headers,  Up: Editing Commit Messages

Using the Revision Stack
........................

‘C-c C-w’ (‘magit-pop-revision-stack’)
     このコマンドは、リビジョンの表現(representation)を現在のバッファに
     挿入します。コミットメッセージの書き込みに使用されるバッファ内だけ
     でなく、電子メール(email)やChangeLogファイルの編集に使用されるバッ
     ファなどの他のバッファでも使用できます。

     デフォルトでは、このコマンドは‘magit-revision-stack’に最後に追加さ
     れたリビジョンをポップし、‘magit-pop-revision-stack-format’に従って
     現在のバッファに挿入します。リビジョンは、
     ‘magit-copy-section-value’と‘magit-copy-buffer-revision’を使用して
     スタックに配置できます。

     スタックが空であるか、プレフィックス引数がある場合は、代わりにミニ
     バッファのリビジョンを読み取ります。ミニバッファ履歴を使用すること
     により、以前にポップされたアイテムを選択したり、最初にスタックにプ
     ッシュせずに任意のreferenceまたはリビジョンを挿入したりできます。

     ミニバッファからリビジョンを読み取るとき、正しいリポジトリを推測で
     きない場合があります。このコマンドがリポジトリ内で呼び出されると(た
     とえば、コミットメッセージの作成中に)、そのリポジトリが使用されます
     。 それ以外の場合(たとえば、電子メールの作成中)、(別のリビジョンを
     挿入した場合でも)スタックの最上位要素として記録されたリポジトリが使
     用されます。リポジトリ内で呼び出されず、スタックが空の場合、または
     プレフィックス引数が2つある場合は、ミニバッファのリポジトリも読み取
     ります。

 -- User Option: magit-pop-revision-stack-format
     このオプションは、コマンド‘magit-pop-revision-stack’が現在のバッフ
     ァにリビジョンを挿入する方法を制御します。

     スタックのエントリの形式は‘(HASH TOPLEVEL)’で、このオプションの書式
     は‘(POINT-FORMAT EOB-FORMAT INDEX-REGEXP)’で、すべてnilまたは文字列
     です(ただし、 EOB-FORMATまたはPOINT-FORMATのいずれかを文字列にする
     必要があります。INDEX-REGEXPがnil以外の場合は、2つの書式も文字列に
     する必要があります)。

     最初のINDEX-REGEXPは、ポイントから逆方向に検索することにより、以前
     に挿入されたエントリを見つけるために使用されます。最初の部分一致は
     インデックス番号と一致する必要があります。その番号が1ずつ増え、挿入
     されるエントリのインデックス番号になります。挿入されたリビジョンに
     番号を付けたくない場合は、INDEX-REGEXPにnilを使用します。

     INDEX-REGEXPがnil以外の場合、POINT-FORMATとEOB-FORMATの両方に
     \"%N\" が含まれている必要があります。これは、前の手順で決定された番
     号に置き換えられます。

     両方の書式は、nil以外の場合、%Nを削除した後、TOPLEVEL内で‘git show
     --format=FORMAT ...’を使用して展開されます。

     POINT-FORMATの展開はポイントに挿入され、EOB-FORMATの展開はバッファ
     の最後に挿入されます(バッファがコメントで終了する場合は、その直前に
     挿入されます)。


File: magit.ja.info,  Node: Commit Pseudo Headers,  Next: Commit Mode and Hooks,  Prev: Using the Revision Stack,  Up: Editing Commit Messages

Commit Pseudo Headers
.....................

一部のプロジェクトでは、コミットメッセージで疑似ヘッダー(pseudo header)を
使用します。Magitはそのようなヘッダーを色付けし、そのようなヘッダーを挿
入するためのいくつかのコマンドを提供します。

 -- User Option: git-commit-known-pseudo-headers
     強調表示されるGit疑似ヘッダーのリスト。

‘C-c C-i’ (‘git-commit-insert-pseudo-header’)
     コミットメッセージの疑似ヘッダーを挿入します。

‘C-c C-a’ (‘git-commit-ack’)
     あなたがコミットをチェックしたことを承認(acknowledge)するヘッダーを
     挿入します。

‘C-c C-r’ (‘git-commit-review’)
     あなたがコミットをレビューしたことを承認(acknowledge)するヘッダーを
     挿入します。

‘C-c C-s’ (‘git-commit-signoff’)
     ヘッダーを挿入して、コミットを承認(sign off)します。

‘C-c C-t’ (‘git-commit-test’)
     あなたがコミットをテストしたことを承認(acknowledge)するヘッダーを挿
     入します。

‘C-c C-o’ (‘git-commit-cc’)
     興味があるかもしれない誰かに言及するヘッダーを挿入します。

‘C-c C-p’ (‘git-commit-reported’)
     コミットによって修正された問題を報告した人に言及するヘッダーを挿入
     します。

‘C-c M-i’ (‘git-commit-suggested’)
     変更を提案した人に言及するヘッダーを挿入します。


File: magit.ja.info,  Node: Commit Mode and Hooks,  Next: Commit Message Conventions,  Prev: Commit Pseudo Headers,  Up: Editing Commit Messages

Commit Mode and Hooks
.....................

‘git-commit-mode’は、特定のキーバインディングを確立するためにのみ使用さ
れるマイナーモードです。 これにより、コミットメッセージの編集に使用され
るバッファで任意のメジャーモードを使用できるようになります。異なるリポジ
トリで異なるメジャーモードを使用することも可能です。これは、異なるプロジ
ェクトが異なるコミットメッセージ規則を課す場合に役立ちます。

 -- User Option: git-commit-major-mode
     このオプションの値は、Gitコミットメッセージの編集に使用されるメジャ
     ーモードです。

‘git-commit-mode’はマイナーモードであるため、キーバインディングを除いて
、そのモードフックを使用してバッファをセットアップしません。他のすべての
セットアップは、関数‘git-commit-setup’で実行されます。この関数は、とりわ
けフック‘git-commit-setup-hook’を実行します。

 -- User Option: git-commit-setup-hook
     ‘git-commit-setup’の最後でフックを実行します。

このフックには、以下の関数が適しています:

 -- Function: git-commit-save-message
     現在のバッファの内容をコミットメッセージリングに保存します。

 -- Function: git-commit-setup-changelog-support
     この関数が呼び出された後、ChangeLogエントリは段落(paragraph)として
     扱われます。

 -- Function: git-commit-turn-on-auto-fill
     ‘auto-fill-mode’をオンにし、‘fill-column’を
     ‘git-commit-fill-column’の値に設定します。

 -- Function: git-commit-turn-on-flyspell
     Flyspellモードをオンにします。また、コメントがチェックされないよう
     にし、最後に現在の非コメントテキストをチェックします。

 -- Function: git-commit-propertize-diff
     コミットメッセージバッファ内に表示されるdiffをプロパティ化します。
     ‘--verbose’引数が使用されると、Gitはそのようなdiffをコミットメッセ
     ージテンプレートに挿入します。‘magit-commit’は、別のバッファに表示
     されるdiffの方が便利なため、デフォルトではその引数を提供しません。
     しかし、一部のユーザーはこれに同意しません。そのため、この機能が存
     在します。

 -- Function: bug-reference-mode
     バッファ内のハイパーリンクのバグ参照(bug reference)。

 -- Function: with-editor-usage-message
     エコーエリアに使用情報(usage information)を表示します。

 -- User Option: git-commit-post-finish-hook
     ユーザーがコミットメッセージの書き込みを終了した後、フックを実行し
     ます。

     このフックは、コミットメッセージの編集に使用されるバッファで‘C-c
     C-c’を押した後にのみ実行されます。ユーザーがバッファにメッセージを
     入力せずにコミットが作成された場合、このフックは実行されません。

     このフックは、新しいコミットが作成されるまで実行されません。Gitがコ
     ミットを作成するのに1秒以上かかる場合、このフックはまったく実行され
     ません。‘magit-rebase-continue’などの特定のコマンドでは、競合状態が
     発生するため、このフックは実行されません。

     このフックは、‘magit’が利用可能な場合にのみ実行されます。

     こちらもご覧ください→‘magit-post-commit-hook’


File: magit.ja.info,  Node: Commit Message Conventions,  Prev: Commit Mode and Hooks,  Up: Editing Commit Messages

Commit Message Conventions
..........................

Git-Commitは、一般的に受け入れられているコミットメッセージ規則の特定の違
反を強調しています。特定の違反により、Git-Commitは、本当にそれを実行した
いことを確認するように要求することさえあります。もちろん、このしつこい表
示はオフにすることができますが、通常、それを行うと、コードの代わりに、コ
ミットをレビューしている人間が、コミットを修正するように指示する時間を無
駄にする必要があります。

 -- User Option: git-commit-summary-max-length
     コミットメッセージの要約行(summry line)の意図する最大桁数。この桁数
     を超える文字は、この設定に違反していることを示すために色分します。

 -- User Option: git-commit-fill-column
     それを超えると、コミットメッセージバッファで自動行折り返しが発生す
     る桁数。

 -- User Option: git-commit-finish-query-functions
     コミットを実行する前にクエリを実行するために呼び出される関数のリス
     ト。

     関数が呼び出されている間、コミットメッセージバッファは最新です。そ
     れらのいずれかがnilを返す場合、コミットは実行されず、バッファは強制
     終了されません。 その後、ユーザーは問題を修正して再試行する必要があ
     ります。

     関数は1つの引数で呼び出されます。nil以外の場合は、問題があるにもか
     かわらず、ユーザーがプレフィックス引数を使用してセッションを強制的
     に終了したことを示します。関数は通常、この願いを尊重し、nil以外を返
     す必要があります。

     デフォルトでは、‘git-commit-check-style-conventions’が唯一のメンバ
     ーです。

 -- Function: git-commit-check-style-conventions
     この関数は、特定の基本的なスタイル規則の違反をチェックします。違反
     ごとに、とにかく続行するかどうかをユーザーに尋ねます。

 -- User Option: git-commit-style-convention-checks
     このオプションは、関数‘git-commit-check-style-conventions’が強制し
     ようとする規則を制御します。値は、特定の規則を識別する自明のシンボ
     ルのリストです。それは‘non-empty-second-line’と
     ‘overlong-summary-line’です。


File: magit.ja.info,  Node: Branching,  Next: Merging,  Prev: Committing,  Up: Manipulating

6.6 Branching
=============

* Menu:

* The Two Remotes::          The Two Remotes
* Branch Commands::          Branch Commands
* Branch Git Variables::     Branch Git Variables
* Auxiliary Branch Commands::  Auxiliary Branch Commands


File: magit.ja.info,  Node: The Two Remotes,  Next: Branch Commands,  Up: Branching

6.6.1 The Two Remotes
---------------------

一部のローカルブランチのアップストリームブランチは、そのローカルブランチ
のコミットが最終的にマージされるブランチであり、通常は‘origin/master’の
ようなものです。‘master’ブランチ自体の場合、アップストリームブランチとそ
れがプッシュされるブランチは、通常、同じリモートブランチです。ただし、機
能(feature)ブランチの場合、アップストリームブランチとプッシュ先のブラン
チは異なる必要があります。

機能(feature)ブランチでのコミットも、_最終的に_‘origin/master’や
‘origin/maint’などのリモートブランチで終了する必要があります。したがって
、このようなブランチはアップストリームとして使用する必要があります。 た
だし、機能ブランチをそのようなブランチに直接プッシュしないでください。代
わりに、機能ブランチ‘my-feature’は通常‘my-fork/my-feature’にプッシュされ
るか、寄稿者(contributor)の場合は‘origin/my-feature’にプッシュされます。
新しい機能がレビューされた後、メンテナはその機能を‘master’にマージします
。そして最後に、‘master’(‘my-feature’自体ではない)が‘origin/master’にプ
ッシュされます。

ただし、新しい機能が最初の試行で完全になることはめったにないため、通常、
機能(feature)ブランチを何度も確認、改善、および再プッシュする必要があり
ます。したがって、プッシュは簡単に実行できるべきです。そういう理由から、
多くのGitユーザーは、ローカル機能ブランチがプッシュされているリモートブ
ランチをアップストリームとして使用するのが最善であると結論付けています。

しかし幸運なことに、Gitは、変数‘branch.<name>.pushRemote’と
‘remote.pushDefault’を使用して、アップストリームブランチとは別に構成でき
るプッシュリモートのサポートをずっと前に手に入れています。だから私達は、
2つのリモートのどちらを「リモート」として使用するかを選択する必要がなく
なりました。

トランジェントコマンドのフェッチ、プル、およびプッシュのそれぞれは、現在
のブランチと他のいくつかのブランチに作用する3つのサフィックスコマンドが
あります。これらのうち、‘p’はプッシュリモートで動作するコマンドに結び付
けられ、‘u’はアップストリームで動作するコマンドに結び付けられ、‘e’は任意
の他のブランチで動作するコマンドに結び付けられます。ステータスバッファに
は、プッシュリモートとアップストリームの両方の、プッシュされていないコミ
ットとプルされていないコミットが表示されます。

これら2つのリモートを構成するのはかなり簡単です。フェッチ、プル、プッシ
ュに関連するすべての変数(およびその他のブランチ関連の変数)の値は、コマン
ド‘magit-branch-configure’を使用して検査および変更できます。これは、ブラ
ンチを処理する多くのトランジェントプレフィックスコマンドから利用できます
。プッシュ中にプッシュリモートまたはアップストリームを設定することもでき
ます(*note Pushing::)。


File: magit.ja.info,  Node: Branch Commands,  Next: Branch Git Variables,  Prev: The Two Remotes,  Up: Branching

6.6.2 Branch Commands
---------------------

トランジェントプレフィックスコマンド‘magit-branch’は、ブランチの作成とチ
ェックアウト、および既存のブランチへの変更に使用されます。ブランチのフェ
ッチまたはプルまたはマージまたはリベースまたはプッシュには使用されません
。つまり、このコマンドはブランチ自体を処理し、ブランチから到達可能なコミ
ットは処理しません。これらの機能は、個別のトランジェントコマンドから利用
できます。

‘b’ (‘magit-branch’)
     このトランジェント(一時的)プレフィックス(接頭辞)コマンドは、それに
     従うサフィックス(接尾辞)コマンド群を結びつけ、そのサフィックスコマ
     ンドのどれかを選ぶまでの間、サフィックス(接尾辞)コマンド群を一時バ
     ッファ(temporary buffer)に表示します。

     デフォルトでは、ブランチ関連のGit変数の値を結び付けて表示し、それら
     の値を変更することもできます。

 -- User Option: magit-branch-direct-configure
     このオプションは、トランジェントコマンド‘magit-branch’を使用して
     Git変数の値を直接変更できるかどうかを制御します。これはデフォルトで
     ‘t’になります(キーバインディングの変更を避けるため)。‘nil’に設定す
     ると、そのトランジェントコマンドによって変数は表示されず、代わりに
     そのサフィックスコマンド‘magit-branch-configure’を使用して、ブラン
     チ関連の変数を表示および変更する必要があります。

‘b C’ (‘magit-branch-configure’)
‘f C’
‘F C’
‘P C’
     このトランジェント(一時的)プレフィックス(接頭辞)コマンドは、ブラン
     チ関連変数の値を設定するコマンドを結び付け、トランジェントコマンド
     が終了するまでそれらブランチ関連変数の値を設定するコマンドを一時バ
     ッファ(temporary buffer)に表示します。

     プレフィックス引数を使用すると、このコマンドは常にブランチの入力を
     求めます。

     プレフィックス引数がない場合、これは‘magit-branch’のサフィックスコ
     マンドとして呼び出されたかどうかと‘magit-branch-direct-configure’オ
     プションに依存します。‘magit-branch’がすでに現在のブランチの変数を
     表示している場合、同じブランチの変数を表示する別のトランジェントコ
     マンドを呼び出すことは役に立ちません。その場合、このコマンドはブラ
     ンチの入力を求めます。

変数の説明についてはこちらを参照して下さい(*note Branch Git Variables::)

‘b b’ (‘magit-checkout’)
     ミニバッファで読み取られたリビジョンをチェックアウトし、デフォルト
     でブランチまたは任意のリビジョンに設定します。リビジョンがローカル
     ブランチの場合、それが現在のブランチになります。それが別のものであ
     る場合、‘HEAD’はdetachされます。作業ツリーまたはステージ領域に変更
     が含まれている場合、チェックアウトは失敗します。

‘b n’ (‘magit-branch-create’)
     新しいブランチを作成します。ユーザーは、新しいブランチの開始点とし
     て使用するブランチまたは任意のリビジョンの入力を求められます。ブラ
     ンチ名が指定されると、それが新しいブランチのアップストリームブラン
     チになります。新しいブランチの名前もミニバッファから読み込まれます
     。

     オプション‘magit-branch-prefer-remote-upstream’も参照してください。

‘b c’ (‘magit-branch-and-checkout’)
     このコマンドは、‘magit-branch-create’のような新しいブランチを作成し
     ますが、それをチェックアウトします。

     オプション‘magit-branch-prefer-remote-upstream’も参照してください。

‘b l’ (‘magit-branch-checkout’)
     このコマンドは、既存または新規のローカルブランチをチェックアウトし
     ます。すべてのローカルブランチとリモートブランチのサブセットを候補
     として提供して、ユーザーからブランチ名を読み取ります。同じ名前のロ
     ーカルブランチが存在するリモートブランチは、候補のリストから除外さ
     れます。 ユーザーは、まったく新しいブランチ名を入力することもできま
     す。

        • ユーザーが既存のローカルブランチを選択すると、それがチェックア
          ウトされます。

        • ユーザーがリモートブランチを選択すると、同じ名前の新しいローカ
          ルブランチが作成およびチェックアウトされ、選択されたリモートブ
          ランチがプッシュターゲットとして構成されます。

        • ユーザーが新しいブランチ名を入力すると、ユーザーから開始点
          (starting-point)も読み取った後、ブランチ名が作成されてチェック
          アウトされます。

     後者の2つのケースでは、アップストリームも設定されます。選択した開始
     点に設定するか、他の何かに設定するかは、
     ‘magit-branch-adjust-remote-upstream-alist’の値によって異なります。

‘b s’ (‘magit-branch-spinoff’)
     このコマンドは、現在のブランチから開始して追跡する新しいブランチを
     作成してチェックアウトします。そのブランチは、アップストリームと共
     有する最後のコミットにリセットされます。現在のブランチにアップスト
     リームまたはプッシュされていないコミットがない場合は、とにかく新し
     いブランチが作成され、以前の現在のブランチは変更されません。

     これは、古いブランチで作業がすでに開始された後に機能(feature)ブラン
     チを作成するのに役立ちます（おそらく「master」である必要はありませ
     ん）。

     現在のブランチがオプション‘magit-branch-prefer-remote-upstream’の値
     のメンバーである場合、現在のブランチは通常どおり開始点(starting
     point)として使用されますが、starting-pointそれ自身の代わりに、
     starting-pointを新しいブランチのアップストリームとして使用できます
     。

     オプションのFROMがnil以外の場合、ソースブランチは、アップストリーム
     と共有する最後のコミットではなく、‘FROM~’にリセットされます。対話的
     なFROMは、リージョンがいくつかのコミットを選択した場合にのみnil以外
     になり、それらのコミットの中で、FROMはソースブランチの前にあるコミ
     ットの数が最も少ないコミットです。

     選択範囲のもう一方の端でのコミットは実際には重要ではありません。
     FROMと‘HEAD’の間のすべてのコミットは新しいブランチに移動されます
     FROMが‘HEAD’から到達できない場合、またはソースブランチのアップスト
     リームから到達可能である場合、エラーが発生します。

‘b S’ (‘magit-branch-spinout’)
     このコマンドは、現在のブランチを変更しないことを除いて、
     ‘magit-branch-spinoff’のように動作します。コミットされていない変更
     がある場合は、‘magit-branch-spinoff’とまったく同じように動作します
     。

‘b x’ (‘magit-branch-reset’)
     このコマンドは、ブランチをリセットします。デフォルトでは、ポイント
     のブランチ、別のブランチの先端、またはその他のコミットにリセットさ
     れます。

     リセットされるブランチが現在のブランチである場合、ハードリセットが
     実行されます。コミットされていない変更がある場合、それらの変更は失
     われるため、ユーザーはリセットを確認する必要があります。

     これは、機能(feature)ブランチでの作業を開始したが、それがすべてがら
     くたであり、最初からやり直したい場合に役立ちます。

     別のブランチにリセットし、プレフィックス引数を使用すると、ターゲッ
     トブランチは、リセットされるブランチのアップストリームとして設定さ
     れます。

‘b k’ (‘magit-branch-delete’)
     1つまたは複数のブランチを削除します。リージョンが複数のブランチをマ
     ークしている場合は、それらを削除することを提案します。それ以外の場
     合は、削除する単一のブランチの入力を求めます。デフォルトでは、その
     ポイントでのブランチになります。

‘b m’ (‘magit-branch-rename’)
     ブランチの名前を変更します。ブランチと新しい名前がミニバッファで読
     み取られます。プレフィックス引数を使用すると、その名前が既存のブラ
     ンチと競合する場合でも、ブランチの名前が変更されます。

 -- User Option: magit-branch-read-upstream-first
     ブランチを作成するときに、作成するブランチの名前の前にアップストリ
     ームブランチをユーザーから読み取るかどうか。デフォルトは‘t’で、その
     ままにしておくことをお勧めします。

 -- User Option: magit-branch-prefer-remote-upstream
     このオプションは、新しいブランチを作成するときに、リモートアップス
     トリームをローカルアップストリームよりも優先するかどうかを指定しま
     す。

     新しいブランチが作成されると、そのポイントでのブランチ、コミット、
     またはスタッシュが新しいブランチの開始点として提案されます。そのよ
     うなリビジョンがポイントにない場合は、現在のブランチが提案されます
     。 いずれの場合も、ユーザーは別の開始点を選択できます。

     選択した開始点がブランチの場合、Git変数‘branch.autoSetupMerge’の値
     に応じて、新しいブランチのアップストリームとして設定することもでき
     ます。デフォルトでは、これはリモートブランチに対して実行され、ロー
     カルブランチに対しては実行されません。

     常にアップストリームとしてリモートブランチを使用することをお勧めし
     ます。選択した開始点が (1)ローカルブランチ、(2)名前がこのオプション
     の値のメンバーと一致する場合、(3)そのローカルブランチの上流が同じ名
     前のリモートブランチである場合、(4)そのリモートブランチをローカルブ
     ランチにfast-forwardedk可能、であるならば選択したブランチが開始点と
     して使用され、それ自体のアップストリームが新しいブランチのアップス
     トリームとして使用されます。

     このオプションの値のメンバーは、ブランチ名として無効にする文字が含
     まれていない限り、完全に一致する必要があるブランチ名として扱われま
     す。正規表現としての解釈をトリガーするために使用する推奨文字は、
     "*"と"^"です。 無効であると予想される他のいくつかの文字は、実際には
     そうではありません。".+$"はすべて完全に有効です。 より正確には、
     ‘git check-ref-format --branch STRING’がゼロ以外のステータスで終了
     する場合、STRINGを正規表現として扱います。

     選択したブランチがこれらの条件に一致すると仮定すると、以下のように
     なります:

          feature --upstream--> origin/master

     は以下の代わりです

          feature --upstream--> master --upstream--> origin/master

     あなたがどちらを好むかは個人的な好みの問題です。前者を使用する場合
     は、‘master’、‘next’、‘maint’などのブランチをこのオプションの値に追
     加する必要があります。

 -- User Option: magit-branch-adjust-remote-upstream-alist
     このオプションの値は、リモートブランチを分岐するときにアップストリ
     ームとして使用されるブランチのalistです。

     リモートにあるつかの間のブランチ(ephemeral branch)からローカルブラ
     ンチを作成する場合。機能(feature)ブランチまたはホットフィックスブラ
     ンチの場合、プッシュリモートはすでにアクセスを許可しており、アップ
     ストリームとプッシュリモートの両方が同じ関連ブランチを参照するのは
     無駄になるため、通常、そのリモートブランチをアップストリームブラン
     チとして使用しないでください。代わりに、"maint"や"master"などのブラ
     ンチをアップストリームとして使用する必要があります。

     このオプションを使用すると、特定のリモートブランチを分岐するときに
     アップストリームとして使用する必要があるブランチを指定できます。 値
     は、‘((UPSTREAM . RULE)...)’の形式のalistです。最初に一致する要素が
     使用され、その後の要素は無視されます。

     UPSTREAMは、RULEで指定されたブランチのアップストリームとして使用さ
     れるブランチです。ローカルブランチでもリモートブランチでもかまいま
     せん。

     RULEは正規表現のいずれかであり、そのアップストリームがUPSTREAMで指
     定されるべきであるブランチに一致します。または、UPSTREAMを使用して
     はならない単一のブランチのリストにすることもできます。他ブランチは
     全てそうします。マッチングは、分岐元のブランチ名のリモート部分を削
     除した後に行われます。

     あなたのすべてのリポジトリで永続的なブランチの限定セットを使用する
     場合、あなたは以下のようなものを使用できます:

          (("origin/master" . ("master" "next" "maint")))

     または、少なくとも一部のリポジトリで、あなたのすべてのつかの間の
     (ephemeral)ブランチの名前にスラッシュが含まれている場合、適切な値は
     以下のようになります:

          (("origin/master" . "/"))

     もちろん、あなたは微調整することもできます:

          (("origin/maint" . "\\`hotfix/")
           ("origin/master" . "\\`feature/"))

     UPSTREAMはローカルブランチにすることができます:

          (("master" . ("master" "next" "maint")))

メインブランチはほとんどの場合「master」という名前ではなくなったため、他
の一般的な名前も考慮する必要があります:

     (("main"  . ("main" "master" "next" "maint"))
      ("master" . ("main" "master" "next" "maint")))

 -- Command: magit-branch-orphan
     このコマンドは、指定されたリビジョンのコンテンツを含む新しい孤立し
     たブランチを作成してチェックアウトします。

 -- Command: magit-branch-or-checkout
     このコマンドは、‘magit-checkout’と‘magit-branch-and-checkout’のハイ
     ブリッドであり、‘magit-branch’で、‘magit-checkout’の代わりとして使
     用することを目的としています。

     最初に、既存のブランチまたはリビジョンをユーザーに要求します。ユー
     ザー入力が実際にブランチまたはリビジョンとして解決できる場合は、
     ‘magit-checkout’と同じように、それをチェックアウトします。

     それ以外の場合は、入力を名前として使用して新しいブランチを作成して
     チェックアウトします。そうする前に、新しいブランチの開始点を読み取
     ります。これは、‘magit-branch-and-checkout’が行うことと似ています。

     ‘magit-checkout’の代わりにこのコマンドを使用するには、以下をあなた
     のinitファイルに追加します:

          (transient-replace-suffix 'magit-branch 'magit-checkout
            '("b" "dwim" magit-branch-or-checkout))


File: magit.ja.info,  Node: Branch Git Variables,  Next: Auxiliary Branch Commands,  Prev: Branch Commands,  Up: Branching

6.6.3 Branch Git Variables
--------------------------

これらの変数は、トランジェントプレフィックスコマンド
‘magit-branch-configure’から設定できます。デフォルトでは、
‘magit-branch’から設定することもできます。こちらを参照して下さい(*note
Branch Commands::)

 -- Variable: branch.NAME.merge
     この変数は、‘branch.NAME.remote’とともに、NAMEという名前のローカル
     ブランチのアップストリームブランチを定義します。 この変数の値は、ア
     ップストリーム「ブランチ」の完全なreferenceです。

 -- Variable: branch.NAME.remote
     この変数は、‘branch.NAME.merge’とともに、NAMEという名前のローカルブ
     ランチのアップストリームブランチを定義します。 この変数の値は、アッ
     プストリーム「リモート」の名前です。

 -- Variable: branch.NAME.rebase
     この変数は、NAMEという名前のブランチへのプルが、リベースによって行
     われるか、フェッチされたブランチをマージすることによって行われるか
     を制御します。

        • ‘true’の場合、プルはリベースによって行われます。
        • ‘false’の場合、プルはマージによって行われます。
        • 未定義の場合、‘pull.rebase’の値が使用されます。その変数のデフ
          ォルトは‘false’です。

 -- Variable: branch.NAME.pushRemote
     この変数は、NAMEという名前のブランチが通常プッシュされるリモートを
     指定します。値は、既存のリモートの名前である必要があります。

     ローカルブランチをプッシュする「ブランチ」の名前を指定することはで
     きません。リモートブランチの名前は、常にローカルブランチの名前と同
     じです。

     この変数が未定義であるが、‘remote.pushDefault’が定義されている場合
     は、後者の値が使用されます。デフォルトでは、‘remote.pushDefault’は
     未定義です。

 -- Variable: branch.NAME.description
     この変数は、NAMEという名前のブランチを説明するために使用できます。
     例えばブランチを一連のパッチに変えるとき、その説明が使用されます。

以下の変数は、上記のブランチ固有の変数が設定されていない場合に使用される
デフォルトを指定します。

 -- Variable: pull.rebase
     この変数は、プルがリベースによって行われるか、マージによって行われ
     るかを指定します。‘branch.NAME.rebase’を使用して上書きできます。

        • ‘true’の場合、プルはリベースによって行われます。
        • ‘false’(デフォルト)の場合、プルはマージによって行われます。

     アップストリームブランチを、機能(feature)ブランチまたはホットフィッ
     クスブランチ(ほとんどのブランチはそのようなブランチです)にマージす
     ることは決して良い考えではなく、この変数を‘true’に設定し、
     ‘branch.master.rebase’を‘false’に設定することを検討する必要がありま
     す。

 -- Variable: remote.pushDefault
     この変数は、ローカルブランチが通常プッシュされるリモートを指定しま
     す。これは、‘branch.NAME.pushRemote’を使用してブランチごとに上書き
     できます。

以下の変数はブランチの作成中に使用され、さまざまなブランチ固有の変数がこ
の時点で自動的に設定されるかどうかを制御します。

 -- Variable: branch.autoSetupMerge
     この変数は、ブランチNAMEを作成すると、ブランチの作成に使用された開
     始点に従って変数‘branch.NAME.merge’と‘branch.NAME.remote’が設定され
     る状況を指定します。開始点がブランチでない場合、これらの変数は設定
     されません。

        • ‘always’の場合、開始点がローカルブランチであるかリモートブラン
          チであるかに関係なく、変数が設定されます。
        • ‘true’(デフォルト)の場合、開始点がリモートブランチの場合は変数
          が設定されますが、ローカルブランチの場合は設定されません。
        • ‘false’の場合、変数は設定されません。

 -- Variable: branch.autoSetupRebase
     この変数は、ブランチNAMEを作成すると、変数‘branch.NAME.rebase’が
     ‘true’に設定されるかどうかを指定します。

        • ‘always’の場合、開始点がローカルブランチであるかリモートブラン
          チであるかに関係なく、変数が設定されます。
        • ‘local’の場合、変数は開始点がローカルブランチの場合に設定され
          ますが、リモートブランチの場合は設定されません。
        • ‘remote’の場合、変数は開始点がリモートブランチの場合に設定され
          ますが、ローカルブランチの場合は設定されません。
        • ‘never’(デフォルト)の場合、変数は設定されません。

注意: それぞれのコマンドは常にリポジトリローカル値を変更することに注意し
てください。ローカル値が定義されていないときに使用されるグローバル値を変
更する場合は、コマンドラインで変更する必要があります。例:

     git config --global remote.autoSetupMerge always

これらの変数の詳細については、以下もご覧下さい

(*note (gitman)git-config::) こちらもご覧下さい (*note
(gitman)git-branch::) と (*note (gitman)git-checkout::) と(*note
Pushing::)

 -- User Option: magit-prefer-remote-upstream
     このオプションは、ユーザーからブランチを読み取り、それをアップスト
     リームブランチとして設定するコマンドが、選択可能な場合に、ローカル
     ブランチまたはリモートブランチをデフォルトの完了候補として提供する
     かどうかを制御します。

     これは、‘magit-read-upstream-branch’または
     ‘magit-read-starting-point’を使用するすべてのコマンドに影響します。
     これには、アップストリームを変更するすべてのコマンドと、新しいブラ
     ンチを作成する多くのコマンドが含まれます。


File: magit.ja.info,  Node: Auxiliary Branch Commands,  Prev: Branch Git Variables,  Up: Branching

6.6.4 Auxiliary Branch Commands
-------------------------------

これらのコマンドは、デフォルトではトランジェントコマンド‘magit-branch’か
らは使用できません。

 -- Command: magit-branch-shelve
     このコマンドはブランチを棚上げ(shelve)します。 これは、ブランチを削
     除し、指定されたブランチと同じコミットを指す新しい参照
     "refs/shelved/BRANCH-NAME"を作成することによって行われます。 削除さ
     れたブランチにreflogがあった場合、それは新しいreferenceのreflogとし
     て保持されます。

     これは、あなたがブランチを見えなくしたいが、まだ完全に破棄する準備
     ができていない場合に便利です。

 -- Command: magit-branch-unshelve
     このコマンドは、‘magit-branch-shelve’を使用して以前に棚上げ
     (shelve)されたブランチの棚上げ(shelve)を解除します。これは、
     reference "refs/shelved/BRANCH-NAME"を削除し、削除されたreferenceが
     指すのと同じコミットを指すブランチ"BRANCH-NAME"を作成することによっ
     て行われます。削除されたreferenceにreflogがあった場合、それはブラン
     チのreflogとして復元されます。


File: magit.ja.info,  Node: Merging,  Next: Resolving Conflicts,  Prev: Branching,  Up: Manipulating

6.7 Merging
===========

こちらもご覧下さい *note (gitman)git-merge:: マージの競合を解決する方法
については、次節を参照してください。

‘m’ (‘magit-merge’)
     このトランジェント(一時的)なプレフィックス(接頭辞)コマンドは、それ
     に従うサフィックス(接尾辞)コマンドを適切なインフィックス(中置)引数
     とともに結び付け、いずれかのサフィックスコマンドを選択するまでの間
     、そのインフィックス引数達とサフィックスコマンド達を一時バッファ
     (temporary buffer)に表示します。

マージが進行中でない場合、トランジェントコマンドにはそれに従うサフィック
スコマンドがあります。

‘m m’ (‘magit-merge-plain’)
     このコマンドは、別のブランチまたは任意のリビジョンを現在のブランチ
     にマージします。 マージされるその別のブランチまたは任意のリビジョン
     はミニバッファで読み込まれ、デフォルトでポイントのブランチになりま
     す。

     競合があるか、プレフィックス引数が使用されていない限り、結果のマー
     ジコミットは一般的なコミットメッセージを使用し、ユーザーはコミット
     が作成される前にそれを検査または変更する機会がありません。プレフィ
     ックス引数を使用すると、実際にはマージコミットが作成されないため、
     競合がどのように解決されたかを検査し、コミットメッセージを調整でき
     ます。

‘m e’ (‘magit-merge-editmsg’)
     このコマンドは、別のブランチまたは任意のリビジョンを現在のブランチ
     にマージし、コミットメッセージバッファを開いて、ユーザーが調整でき
     るようにします。コミットは、ユーザーが‘C-c C-c’で終了するまで実際に
     は作成されません。

‘m n’ (‘magit-merge-nocommit’)
     このコマンドは、別のブランチまたは任意のリビジョンを現在のブランチ
     にマージしますが、実際にはマージコミットを作成しません。その後、ユ
     ーザーは、自動競合解決が成功した場合でも、マージをさらに調整したり
     、コミットメッセージを調整したりできます。

‘m a’ (‘magit-merge-absorb’)
     このコマンドは、別のローカルブランチを現在のブランチにマージしてか
     ら、前者を削除します。

     ソースブランチがマージされる前に、それぞれのリモートブランチがすで
     に存在する場合、最初にプッシュリモートに強制的にプッシュされます。
     これにより、それぞれのプルリクエスト(存在する場合)が、マージされて
     いるコミットの廃止されたバージョンでスタックすることがなくなります
     。最後に、‘magit-branch-pull-request’を使用してマージされたブランチ
     を作成した場合、それぞれのリモートブランチも削除されます。

‘m i’ (‘magit-merge-into’)
     このコマンドは、現在のブランチを別のローカルブランチにマージしてか
     ら、前者を削除します。後者が新しい現在のブランチになります。

     ソースブランチがマージされる前に、それぞれのリモートブランチがすで
     に存在する場合、最初にプッシュリモートに強制的にプッシュされます。
     これにより、それぞれのプルリクエスト(存在する場合)が、マージされて
     いるコミットの廃止されたバージョンでスタックすることがなくなります
     。最後に、‘magit-branch-pull-request’を使用してマージされたブランチ
     を作成した場合、それぞれのリモートブランチも削除されます。

‘m s’ (‘magit-merge-squash’)
     このコマンドは、別のブランチまたは任意のリビジョンによって現在のブ
     ランチに導入された変更を破棄します。これは、squashコミットによって
     行われた変更にのみ適用されます。 実際のマージコミットの作成を可能に
     する情報は保持されません。このコマンドの代わりに、apply用トランジェ
     ントコマンドからのコマンドを使用する必要があります。

‘m p’ (‘magit-merge-preview’)
     このコマンドは、別のブランチまたは任意のリビジョンを現在のブランチ
     にマージするプレビューを表示します。

マージが進行中の場合、トランジェントコマンドには代わりのサフィックスコマ
ンドがあります。

‘m m’ (‘magit-merge’)
     ユーザーが競合を解決した後、このコマンドはマージを続行します。一部
     の競合が解決されなかった場合、このコマンドは失敗します。

‘m a’ (‘magit-merge-abort’)
     このコマンドは、現在のマージ操作を中止(abort)します。


File: magit.ja.info,  Node: Resolving Conflicts,  Next: Rebasing,  Prev: Merging,  Up: Manipulating

6.8 Resolving Conflicts
=======================

ブランチをマージする(または履歴を結合または変更する)と、競合が発生する可
能性があります。 同じファイルの2つの完全に異なる部分を2つのブランチで編
集してから、これらのブランチの1つを別のブランチにマージすると、Gitはそれ
を独自に解決できますが、ファイルの同じ領域を編集する場合は、人間が必要で
す。 2つのバージョン、つまり「競合の側面」を1つに組み合わせる方法を決定
します。

ここでは、主題の簡単な紹介のみを提供し、役立ついくつかのツールを紹介しま
す。これが初めての場合は、Git独自の文書やその他のリソースも参照してくだ
さい。

ファイルに競合があり、Gitがそれ自体で解決できない場合は、ファイルの未解
決部分の境界と異なるバージョン間の境界を示すことを目的とした特別なマーカ
ーとともに、両方のバージョンを影響を受けるファイルに配置します。 これら
の境界線は、‘<’、‘|’、‘=’、‘>’のいずれかの6個の同じ文字で構成される文字
列で始まり、その後にそれぞれのバージョンのソースに関する情報が続きます。
例:

     <<<<<<< HEAD
     Take the blue pill.
     =======
     Take the red pill.
     >>>>>>> feature

この場合、1つのブランチで赤い薬(red pill)を服用し、別のブランチで青い薬
(blue pill)を選択しました。 これらの2つの分岐するブランチをマージしてい
るので、Gitはどちらの薬を服用したいかをおそらく知ることができません。

この競合を解決するには、ファイルの影響を受ける領域のバージョンを作成する
必要があります。一方の側だけを保持し、場合によってはもう一方の側から変更
を取り込むために編集して、他のバージョンとマーカーを削除します。次に結果
をステージします。 考えられる解決策は次のとおりです:

     Take both pills.

多くの場合、競合の2つの側面だけでなく、ファイルの同じ領域が異なるブラン
チで2回変更される前の「元の」バージョンも確認すると便利です。 このコマン
ドを1回実行して、そのバージョンも挿入するようにGitに指示します:

     git config --global merge.conflictStyle diff3

上記の競合は以下のようになっているかもしれません:

     <<<<<<< HEAD
     Take the blue pill.
     ||||||| merged common ancestors
     Take either the blue or the red pill, but not both.
     =======
     Take the red pill.
     >>>>>>> feature

その場合、上記の競合解決は正しくありませんでした。これは、競合するバージ
ョンと一緒に元のバージョンを表示することが役立つ理由を示しています。

あなたは競合の解決を手動で完全に実行できますが、Emacsには、この処理に役
立ついくつかのパッケージ（Smerge、Ediff(*note (ediff)Top::)、
Emerge(*note (emacs)Emerge::))も用意されています。 Magitは、競合を解決す
るための独自のツールを提供していませんが、SmergeとEdiffの使用をより便利
にします。(EdiffはEmergeに取って代わるので、あなたはEmergeを使いたくなく
なる事でしょう。)

Magitステータスバッファでは、競合が解決されていないファイルが"Unstaged
changes"または"Staged changes"セクションに一覧表示されます。 これらの前
には"unmerged"という単語が付いています。これは、この文脈では本質的に
"unresolved"の同義語です。

ポイントがそのようなファイルセクションにあるときに‘RET’を押すと、そのフ
ァイルを訪れているバッファが表示され、そのバッファで‘smerge-mode’がオン
になり、競合のある最初の領域内にポイントが配置されます。あなたは、通常の
編集コマンドやSmergeコマンドを使用してその競合を解決する必要があります。

残念ながら、Smergeにはマニュアルがありませんが、コマンドのリストを取得し
て‘C-c ^ C-h’をバインドし、ポイントがコマンド名にあるときに‘RET’を押して
ドキュメントを読むことができます。

通常、1つのバージョンを編集してから、そのバージョンのみを保持するように
Smergeに指示します。‘C-c ^ m’(‘smerge-keep-mine’)を使用して‘HEAD’バージ
ョンを保持するか、‘C-c ^ o’(‘smerge-keep-other’)を使用して"|||||||"に続
くバージョンを保持します。次に、‘C-c ^ n’を使用して、同じファイル内の次
の競合する領域に移動します。競合の解決が完了したら、Magitステータスバッ
ファに戻ります。 最後の競合を解決した後にバッファを保存すると、Smergeが
ファイルを自動的にステージするため、ファイルは"unmerged"として表示されな
くなり、"modified"として表示されます。

Magitは、前述のSmergeコマンドをラップするようになり、ファイル訪問バッフ
ァに移動することなく、これらのキーバインディングを使用できるようになりま
した。 さらに、競合が解決されていないハンクの‘k’(‘magit-discard’)は、ど
ちらの側を保持するかを尋ねます。ポイントがそのどちらかの側にある場合は、
プロンプトを表示せずに保持します。同様に、未解決のファイルの‘k’は、どち
らの側を保持するかを尋ねます。

あるいは、ファイルのバージョンごとに別々のバッファを使用するEdiffを使用
することもできます。 Ediffを使用してファイル内の競合を解決するには、ステ
ータスバッファ内のそのようなファイル上にポイントがあるときに‘e’を押しま
す。

Ediffは他の目的にも使用できます。MagitからEdiffに入る方法の詳細について
はこちらを参照して下さい(*note Ediffing::)。 Ediffの使用方法の説明は、こ
のマニュアルの範囲を超えています。代わりにこちらを参照して下さい(*note
(ediff)Top::)。

SmergeとEdiffのどちらを使用すべきかわからない場合は、前者を使用してくだ
さい。理解して使用する方がはるかに簡単であり、本当に複雑な競合を除いて、
後者は通常やり過ぎです。


File: magit.ja.info,  Node: Rebasing,  Next: Cherry Picking,  Prev: Resolving Conflicts,  Up: Manipulating

6.9 Rebasing
============

こちらもご覧下さい *note (gitman)git-rebase:: リベース中に発生する競合を
解決する方法については、前節を参照してください。

‘r’ (‘magit-rebase’)
     このトランジェント(一時的)なプレフィックス(接頭辞)コマンドは、それ
     に従うサフィックス(接尾辞)コマンドを適切なインフィックス(中置)引数
     とともに結び付け、いずれかのサフィックスコマンドを選択するまでの間
     、そのインフィックス引数達とサフィックスコマンド達を一時バッファ
     (temporary buffer)に表示します。

リベースが進行中でない場合、トランジェントコマンドにはそれ従うサフィック
スコマンドがあります。

これらのコマンドの1つを使用して、リベースシーケンスを_開始_します。 Gitは
、あなたが途中で中断するように指示したか、競合が原因でコミットの適用が失
敗したために中断する可能性があります。その場合、ステータスバッファには、
ログセクションに似たセクションで、進行中のリベースシーケンスに関する情報
が表示されます。こちらを参照して下さい(*note Information About
In-Progress Rebase::)。

アップストリーム(upstream)とプッシュリモート(push-remote)の詳細について
はこちらを参照して下さい(*note The Two Remotes::)。

‘r p’ (‘magit-rebase-onto-pushremote’)
     このコマンドは、現在のブランチをプッシュリモートにリベースします。

     プレフィックス引数を使用する場合、またはプッシュリモートが構成され
     ていないか使用できない場合は、最初にユーザーにプッシュリモートを構
     成させます。

‘r u’ (‘magit-rebase-onto-upstream’)
     このコマンドは、現在のブランチをそのアップストリームブランチにリベ
     ースします。

     プレフィックス引数を使用する場合、またはアップストリームが構成され
     ていないか使用できない場合は、ユーザーが最初にアップストリームを構
     成できるようにします。

‘r e’ (‘magit-rebase-branch’)
     このコマンドは、現在のブランチをミニバッファでユーザーから読み取っ
     たブランチにリベースします。ヘッドからは到達可能であるが、選択した
     ブランチTARGETからは到達できないすべてのコミットがリベースされます
     。

‘r s’ (‘magit-rebase-subset’)
     このコマンドは、非対話型のリベースシーケンスを開始して、コミットを
     STARTからNEWBASEの‘HEAD’に転送します。STARTは、最近のコミットのリス
     トから選択する必要があります。

デフォルトでは、Magitは‘--autostash’引数を使用します。これにより、コミッ
トされていない変更はリベースが開始される前にスタッシュに格納されます。こ
れらの変更は、リベースが完了した後に復元され、可能であればスタッシュが削
除されます。スタッシュがきれいに適用されない場合、スタッシュは削除されま
せん。これにより、競合を解決するときに何か問題が発生した場合は、あなたは
最初からやり直すことができます。

アクションの1つとして、対話型リベース専用のインフィックス引数
‘--interactive’があります。これを使用して、非対話型リベースバリエーショ
ンを対話型リベースに変えることができます。

たとえば、機能(feature)ブランチをクリーンアップすると同時に、それを
‘master’にリベースする場合は、‘r-iu’を使用できますが、代わりに2つのステ
ップで行うことをお勧めします。最初に‘ri’を使用して機能ブランチをクリーン
アップし、次に‘ru’を使用して‘master’にリベースします。そうすれば、物事が
思ったよりも複雑であることが判明した場合、および/または間違いを犯して最
初からやり直さなければならない場合は、作業の半分をやり直すだけで済みます
。

‘--interactive’を明示的に有効にしたあと、それに続く以下のトランジェント
コマンド内では‘--interactive’が有効でない場合でも、常にその引数を使用す
るため、影響はありません。

‘r i’ (‘magit-rebase-interactive’)
     このコマンドは、対話的なリベースシーケンスを開始します。

‘r f’ (‘magit-rebase-autosquash’)
     このコマンドは、スカッシュコミットとフィックスアップコミットを、意
     図したターゲットと組み合わせます。

‘r m’ (‘magit-rebase-edit-commit’)
     このコマンドは、ユーザーが1つの古いコミットを編集できるようにする対
     話的なリベースシーケンスを開始します。

‘r w’ (‘magit-rebase-reword-commit’)
     このコマンドは、ユーザーが1つの古いコミットをrewordする対話的なリベ
     ースシーケンスを開始します。

‘r k’ (‘magit-rebase-remove-commit’)
     このコマンドは、リベースを使用して1つの古いコミットを削除します。

リベースが進行中の場合、トランジェントコマンドには代わりのサフィックスコ
マンドがあります。

‘r r’ (‘magit-rebase-continue’)
     このコマンドは、現在のリベース操作を再開します。

     場合によっては、これにより、編集を行うためのコミットメッセージバッ
     ファがポップアップ表示されます。プレフィックス引数を使用すると、古
     いメッセージはそのまま再利用されます。

‘r s’ (‘magit-rebase-skip’)
     このコマンドは、現在のコミットをスキップし、現在のリベース操作を再
     開します。

‘r e’ (‘magit-rebase-edit’)
     このコマンドを使用すると、ユーザーは現在のリベース操作のToDoリスト
     を編集できます。

‘r a’ (‘magit-rebase-abort’)
     このコマンドは、現在のリベース操作を中止し、元のブランチを復元しま
     す。

* Menu:

* Editing Rebase Sequences::  Editing Rebase Sequences
* Information About In-Progress Rebase::  Information About In-Progress
                                            Rebase


File: magit.ja.info,  Node: Editing Rebase Sequences,  Next: Information About In-Progress Rebase,  Up: Rebasing

6.9.1 Editing Rebase Sequences
------------------------------

‘C-c C-c’ (‘with-editor-finish’)
     終了コード0で戻ることにより、現在の編集セッションを終了します。
     Gitは、ファイル内で検出したリベース命令(rebase instructions)を使用
     します。

‘C-c C-k’ (‘with-editor-cancel’)
     終了コード1で戻ることにより、現在の編集セッションをキャンセルします
     。その後、Gitはリベースシーケンスの開始を中止します。

‘<RET>’ (‘git-rebase-show-commit’)
     別のバッファの現在の行にコミットを表示し、そのバッファを選択します
     。

‘<SPC>’ (‘git-rebase-show-or-scroll-up’)
     別のバッファを選択せずに、現在の行のコミットを別のバッファに表示し
     ます。 リビジョンバッファが現在のフレームの別のウィンドウにすでに表
     示されている場合は、代わりにそのウィンドウを上にスクロールします。

‘<DEL>’ (‘git-rebase-show-or-scroll-down’)
     別のバッファを選択せずに、現在の行のコミットを別のバッファに表示し
     ます。 リビジョンバッファが現在のフレームの別のウィンドウにすでに表
     示されている場合は、代わりにそのウィンドウを下にスクロールします。

‘p’ (‘git-rebase-backward-line’)
     前の行に移動します。

‘n’ (‘forward-line’)
     次の行に移動します。

‘M-p’ (‘git-rebase-move-line-up’)
     現在のコミット(またはコマンド)を上に移動します。

‘M-n’ (‘git-rebase-move-line-down’)
     現在のコミット(またはコマンド)を下に移動します。

‘r’ (‘git-rebase-reword’)
     現在行のコミットのメッセージを編集します。

‘e’ (‘git-rebase-edit’)
     現在の行のコミットで中断します。

‘s’ (‘git-rebase-squash’)
     現在行のコミットを前行のコミットにマージし、メッセージを編集します
     。

‘f’ (‘git-rebase-fixup’)
     現在行のコミットを前行コミットにマージし、現在のコミットのメッセー
     ジを破棄します。

‘k’ (‘git-rebase-kill-line’)
     現在の実行行(action line)を強制終了します。

‘c’ (‘git-rebase-pick’)
     現在行でcommitを使用します。

‘x’ (‘git-rebase-exec’)
     進行中のコミットの後に実行されるシェルコマンドを挿入します。

     現在の行にそのようなコマンドがすでにある場合は、代わりにそれを編集
     します。プレフィックス引数を使用すると、現在の行にすでにコマンドが
     ある場合でも、新しいコマンドを挿入します。入力が空の場合、現在の行
     のコマンドを削除します(存在する場合)。

‘b’ (‘git-rebase-break’)
     現在行の前にブレークアクション(break action)を挿入し、Gitに、制御を
     ユーザーに戻すように指示します。

‘y’ (‘git-rebase-insert’)
     任意のコミットを読み取り、現在行の下に挿入します。

‘C-x u’ (‘git-rebase-undo’)
     直近の幾つかの変更を元に戻します。‘undo’と同様ですが、読み取り専用
     バッファで機能します。

 -- User Option: git-rebase-auto-advance
     行を変更した後、次の行に移動するかどうか。

 -- User Option: git-rebase-show-instructions
     リベースバッファ内に使用説明を表示するかどうか。

 -- User Option: git-rebase-confirm-cancel
     キャンセルするために確認が必要かどうか。

‘--rebase-merges’オプションを使用してリベースを実行すると、シーケンスに
は他のいくつかのタイプのアクションが含まれ、以下のコマンドが関連するよう
になります。

‘l’ (‘git-rebase-label’)
     このコマンドは、ラベルアクションを挿入するか、ポイントのアクション
     を編集します。

‘t’ (‘git-rebase-reset’)
     このコマンドは、リセットアクションを挿入するか、その時点でアクショ
     ンを編集します。プロンプトは、現在バッファに存在するラベルを提供し
     ます。

‘MM’ (‘git-rebase-merge’)
     このコマンドは、マージアクションを挿入するか、その時点でのアクショ
     ンを編集します。プロンプトでは、現在バッファに存在するラベルを提供
     します。‘-c’または‘-C’を介して再利用するメッセージを指定することは
     サポートされていません。マージのために常にエディタが呼び出されます
     。

‘Mt’ (‘git-rebase-merge-toggle-editmsg’)
     このコマンドは、ポイントでのマージアクションの‘-C’オプションと
     ‘-c’オプションを切り替えます。これらのオプションは両方とも、メッセ
     ージを再利用する必要があるコミットを指定します。小文字のバリエーシ
     ョンは、マージの作成時にエディタを呼び出すようにGitに指示し、ユーザ
     ーがメッセージを編集できるようにします。


File: magit.ja.info,  Node: Information About In-Progress Rebase,  Prev: Editing Rebase Sequences,  Up: Rebasing

6.9.2 Information About In-Progress Rebase
------------------------------------------

リベースシーケンスの進行中、ステータスバッファには、すでに適用されている
コミットと、まだ適用する必要のあるコミットを一覧表示するセクションがあり
ます。

コミットは2つに等分されます。ユーザーが競合に対処する必要があるため、ま
たはリベースがそのコミットで中断するように明示的に要求したために、リベー
スがコミットで中断すると、ポイントは2つのグループを分離するコミットに置
かれます。つまり‘HEAD’です。その上のコミットはまだ適用されていませんが、
‘HEAD’とその下のコミットにはすでに適用されています。適用されたコミットと
まだ適用されていないコミットのこれら2つのグループの間に、ドロップされた
コミットがある場合があります。

各コミットには単語が前に付けられ、これらの単語はコミットのステータスを示
すために異なる色で追加で表示されます。

以下の色が使用されます:

   • ‘default’ フェイスと同じ前景色を使用するコミットはまだ適用されてい
     ません。

   • 黄色のコミットは、停止(stop)したコミットリベースと特別な関係があり
     ます。 これは、「join」や「goal」や「same」や「work」という言葉に使
     用されます (以下を参照)。

   • 灰色のコミットはすでに適用されています。

   • 青色のコミットは‘HEAD’コミットです。

   • 緑色のコミットは、リベースシーケンスが中断しているコミットです。こ
     れが‘HEAD’と同じコミットである場合は、たとえば、コミットでリベース
     が中断した後、まだ何もしていないなら、このコミットは緑色ではなく青
     色で表示されています。リベースがコミットで中断した後に1つ以上の新し
     いコミットを作成した場合、同時に存在できるのは*緑色と青色のコミット
     のみ*です。

   • 赤色のコミットは削除されました。それらは参照用(reference)にのみ示さ
     れています。diffを取りやすくします。

もちろん、これらの色は使用中のカラーテーマの影響を受けます。

以下の単語が使用されます:

   • 接頭辞が‘pick’・‘reword’・‘edit’・‘squash’・‘fixup’であるコミットは
     まだ適用されていません。これらの単語は、リベースシーケンスの編集に
     使用されるバッファと同じ意味を持ちます。(*note Editing Rebase
     Sequences::) ‘--rebase-merges’オプションが指定された場合、‘reset’・
     ‘label’・‘merge’行も存在する可能性があります。

   • 接頭辞が‘done’・‘onto’であるコミットはすでに適用されています。その
     ようなコミットは‘HEAD’である可能性があり、‘HEAD’の場合は青色になり
     ます。それ以外の場合は灰色です。

        • 接頭辞が‘onto’のコミットは、再適用された他のすべてのコミットの
          先頭であるコミットです。このコミット自体を再適用する必要はあり
          ませんでした。他のコミットの再適用を開始する前に、リベースが巻
          き戻されたコミットです。

        • 接頭辞が‘done’のコミットはすでに再適用されています。これには、
          再適用されたコミットだけでなく、リベース中に作成した新しいコミ
          ットも含まれます。

   • 上記の単語のいずれの接頭辞も付いていない他のすべてのコミットは、リ
     ベースが中断したコミットに何らかの形で関連しています。

     コミットが中断中のコミット(stopped-at commit)に関連しているかどうか
     を判断するために、ハッシュ達、ツリー達、およびパッチID達(patch-id)
     (1) が比較されています。コミットメッセージはこの目的には使用されま
     せん。

     一般的に、中断中のコミット(stopped-at commit)に関連するコミットは、
     使用されている色のいずれかを持つことができますが、すべての色/単語の
     組み合わせが可能であるとは限りません。

     中断中のコミット(stopped-at commit)に使用される単語は以下のとおりで
     す:

        • 接頭辞が‘void’の場合、それは、そのコミットのすべての変更がいく
          つかの新しいコミットを使用して適用されたことをMagitが確実に認
          識していることを示します。このコミットは‘HEAD’から到達できなく
          なり、セッションを再開するときに適用されるコミットの1つでもあ
          りません。

        • 接頭辞が‘join’の場合、競合が原因でリベースシーケンスがそのコミ
          ットで中断したことを示しています。ここで、変更を既に適用されて
          いるものと結合（マージ）する必要があります。 ある意味で、これ
          はで中断したコミットリベースで、その効果はすでにインデックスと
          ワークツリー（競合マーカー付き）にありますが、コミット自体はま
          だ実際には適用されていません(‘HEAD’ではありません)。したがって
          、まだ適用する必要がある他のコミットと同様に、黄色で表示されま
          す。

        • 接頭辞が‘stop’または、_青色_または_緑色_の‘same’の場合、それは
          、リベースがこのコミットで中断したこと、まだ適用されているか、
          再度適用されたことを示します。そして少なくともそのパッチIDは変
          更されていません。

             • 接頭辞が‘stop’のコミットの場合、それは、以前に要求したた
               めにリベースがそのコミットで中断したことを示し、そのパッ
               チIDは変更されていません。それでもまったく同じコミットで
               ある可能性があります。

             • 接頭辞が_青色_または_緑色_の‘same’の場合、それは、ツリー
               またはハッシュが変更されたが、パッチIDが変更されなかった
               ことを示します。青色の場合は、‘HEAD’コミットです(青色の場
               合は常にそうです)。緑色の場合、それ以降（ただし、リベース
               を続行する前に）他のコミットが作成されているため、
               ‘HEAD’ではなくなります。

        • 接頭辞が‘goal’または_黄色_の‘same’または‘work’の場合、リベース
          がそのコミットを適用したが、‘HEAD’にリセットしたことを示します
          。 以前のコミット(複数のコミットに分割される可能性が高い)、そ
          してそのコミットに起因する可能性が高い(必ずしもそうではない)コ
          ミットされていない変更が残っています。

             • 接頭辞‘goal’の場合、ファイルを手動で編集したり、インデッ
               クスをコミットしたり、ステージしたりすることなく、まった
               く同じツリー(つまり目標(the "goal"))で新しいコミットを作
               成できることを示しています。すべての変更とそれをコミット
               します。これは、元のツリーが汚染されていない形式でインデ
               ックスまたはワークツリーにまだ存在する場合です。

             • 接頭辞が黄色の‘same’のコミットの場合、まったく同じツリー
               でコミットを作成することはできなくなっていますが、同じパ
               ッチIDでコミットを作成することは可能です。これは、他の変
               更を加えて新しいコミットを作成したが、元のコミットからの
               変更が汚染されていない形式でインデックスまたは作業ツリー
               にまだ存在している場合に当てはまります。

             • 接頭辞が‘work’の場合、‘HEAD’を以前のコミットにリセットし
               、そのコミットに起因するステージされていない変更(unstaged
               changes)および/またはステージされた変更(staged changes)(可
               能性が高いが、必ずしもそうではない)があることを示します。
               ただし、すでに他の変更を行っているため、同じツリーまたは
               少なくとも同じパッチIDで新しいコミットを作成することはで
               きなくなりました。

        • 接頭辞が‘poof’または‘gone’の場合、それは、リベースがそのコミッ
          トを適用したが、‘HEAD’を以前のコミットにリセットしたことを示し
          ます(複数のコミットに分割する可能性があります)、そしてコミット
          されていない変更はありません。

             • 接頭辞が‘poof’の場合、それは‘HEAD’から到達できなくなった
               ことを示しますが、1つ以上のコミットに置き換えられ、まった
               く同じ効果があります。

             • 接頭辞が‘gone’の場合、それは‘HEAD’から到達できなくなった
               こと、およびその変更が1つ以上の新しいコミットでまだ有効で
               あるかどうかを判断できないことを示します。そうかもしれま
               せんが、もしそうなら、確実に知ることを不可能にする他の変
               更もあるに違いありません。

あなたが今、上記を完全に理解できなくても心配しないでください。大丈夫、あ
なたは練習を通して十分な理解を得ることが出来るようになります。

チェリーピッキングなどの他のシーケンス操作についても、同様のセクションが
表示されますが、それらの実装に使用されるgitコマンドの制限により、上記の
機能の一部が欠けています。最も重要なことは、これらのシーケンスはコミット
の"picking"のみをサポートし、"rewording"などの他のアクションはサポートせ
ず、すでに適用されているコミットを追跡しません。

   ---------- Footnotes ----------

   (1) patch-idは、コミットによって導入された_変更_のハッシュです。 これ
は、コミット自体のハッシュとは異なります。これは、その変更を適用した結果
のハッシュ(つまり、結果のツリーとblob)、作成者とコミッターの情報、コミッ
トメッセージ、およびコミットの親のハッシュです。一方、パッチIDハッシュは
、追加および削除された行からのみ作成されます。このハッシュを計算するとき
は、行番号や空白の変更も無視されます。2つのコミットのパッチIDを使用して
、「これらのコミットは同じ変更を行いますか？」という質問に答えることがで
きます。


File: magit.ja.info,  Node: Cherry Picking,  Next: Resetting,  Prev: Rebasing,  Up: Manipulating

6.10 Cherry Picking
===================

こちらもご覧下さい *note (gitman)git-cherry-pick::

‘A’ (‘magit-cherry-pick’)
     このトランジェント(一時的)なプレフィックス(接頭辞)コマンドは、それ
     に従うサフィックス(接尾辞)コマンドを適切なインフィックス(中置)引数
     とともに結び付け、いずれかのサフィックスコマンドを選択するまでの間
     、そのインフィックス引数達とサフィックスコマンド達を一時バッファ
     (temporary buffer)に表示します。

cherry-pickまたはrevertが進行中でない場合、トランジェントコマンドはそれ
に従うサフィックスコマンドがあります。

‘A A’ (‘magit-cherry-copy’)
     このコマンドは、COMMITSを別のブランチから現在のブランチにコピーしま
     す。リージョンが複数のコミットを選択した場合、プロンプトなしでそれ
     らがコピーされます。それ以外の場合、ユーザーはコミットまたは範囲の
     入力を求められ、デフォルトではそのポイントでのコミットになります。

‘A a’ (‘magit-cherry-apply’)
     このコマンドは、COMMITSの変更を別のブランチから現在のブランチに適用
     します。リージョンが複数のコミットを選択した場合、プロンプトなしで
     それらが使用されます。それ以外の場合、ユーザーはコミットまたは範囲
     の入力を求められ、デフォルトでそのポイントでのコミットになります。

     このコマンドにはトップレベルのバインディングもあり、トップレベルで
     ‘a’と入力することにより、トランジェントコマンドを使用せずに呼び出す
     ことができます。

以下のコマンド達は、いくつかのコミットをいくつかのブランチに適用するだけ
でなく、それらを他のブランチから削除します。 削除は、‘git-update-ref’ま
たは必要に応じて‘git-rebase’のいずれかを使用して実行されます。コミットを
適用することと、‘git-rebase’を使用してコミットを削除することの両方で、競
合が発生する可能性があります。 その場合、これらのコマンドは中止(abort)さ
れ、競合を解決するだけでなく、これらのコマンドがまったく存在しなかった場
合と同じ方法でプロセスを終了する必要があります。

‘A h’ (‘magit-cherry-harvest’)
     このコマンドは、別のブランチの選択したコミットを現在のブランチに移
     動し、その、別のブランチから削除します。このコマンドが成功すると、
     以前と同じ(same)ブランチがcurrentになります。

     現在のブランチにコミットを適用したり、他のブランチからコミットを削
     除したりすると、競合が発生する可能性があります。その場合、このコマ
     ンドは中断し、競合を解決してから手動でプロセスを終了する必要があり
     ます。

‘A d’ (‘magit-cherry-donate’)
     このコマンドは、選択したCOMMITSを現在のブランチから別の既存のブラン
     チに移動し、その、現在のブランチから削除します。このコマンドが成功
     すると、以前と同じ(same)ブランチがcurrentになります。 ‘HEAD’ は最初
     に切り離し(detach)することができます。

     他のブランチにコミットを適用したり、現在のブランチからコミットを削
     除したりすると、競合が発生する可能性があります。その場合、このコマ
     ンドは中断し、競合を解決してから手動でプロセスを終了する必要があり
     ます。

‘A n’ (‘magit-cherry-spinout’)
     このコマンドは、選択したCOMMITSを現在のブランチから新しいブランチ
     BRANCHに移動し、その、現在のブランチから削除します。 このコマンドが
     成功すると、以前と同じ(same)ブランチがcurrentになります。

     他のブランチにコミットを適用したり、現在のブランチからコミットを削
     除したりすると、競合が発生する可能性があります。その場合、このコマ
     ンドは中断し、競合を解決してから手動でプロセスを終了する必要があり
     ます。

‘A s’ (‘magit-cherry-spinoff’)
     このコマンドは、選択したCOMMITSを現在のブランチから新しいブランチ
     BRANCHに移動し、その、現在のブランチから削除します。このコマンドが
     成功すると、新しいブランチがチェックアウトされます。

     他のブランチにコミットを適用したり、現在のブランチからコミットを削
     除したりすると、競合が発生する可能性があります。その場合、このコマ
     ンドは中断し、競合を解決してから手動でプロセスを終了する必要があり
     ます。

cherry-pickまたはrevertが進行中の場合、トランジェントコマンドには代わり
に従うサフィックスコマンドがあります。

‘A A’ (‘magit-sequence-continue’)
     現在のcherry-pickを再開するか、シーケンスをrevertします。

‘A s’ (‘magit-sequence-skip’)
     cherry-pickまたはrevertシーケンス中にコミットで中断したものをスキッ
     プします。

‘A a’ (‘magit-sequence-abort’)
     現在のcherry-pickまたはrevertシーケンスを中止します。これにより、シ
     ーケンスの開始以降に行われたすべての変更が破棄されます。

* Menu:

* Reverting::                Reverting


File: magit.ja.info,  Node: Reverting,  Up: Cherry Picking

6.10.1 Reverting
----------------

‘V’ (‘magit-revert’)
     このトランジェント(一時的)なプレフィックス(接頭辞)コマンドは、それ
     に従うサフィックス(接尾辞)コマンドを適切なインフィックス(中置)引数
     とともに結び付け、いずれかのサフィックスコマンドを選択するまでの間
     、そのインフィックス引数達とサフィックスコマンド達を一時バッファ
     (temporary buffer)に表示します。

cherry-pickまたはrevertが進行中でない場合、トランジェントコマンドはそれ
に従うサフィックスコマンドがあります。

‘V V’ (‘magit-revert-and-commit’)
     新しいコミットの作成によってコミットをrevertします。プロンプトを出
     してコミットの入力を求めます。デフォルトでは、そのポイントでのコミ
     ットになります。 リージョンが複数のコミットを選択した場合は、プロン
     プトを表示せずにすべてをrevertします。

‘V v’ (‘magit-revert-no-commit’)
     コミットを作業ツリーに逆に適用して、コミットをrevertします。 プロン
     プトを出してコミットの入力を求めます。デフォルトでは、そのポイント
     でのコミットになります。リージョンが複数のコミットを選択した場合は
     、プロンプトを表示せずにすべてをrevertします。

cherry-pickまたはrevertが進行中の場合、トランジェントコマンドには代わり
に従うサフィックスコマンドがあります。

‘V A’ (‘magit-sequence-continue’)
     現在のcherry-pickを再開するか、シーケンスをrevertします。

‘V s’ (‘magit-sequence-skip’)
     cherry-pickまたはrevertシーケンス中にコミットで中断したものをスキッ
     プします。

‘V a’ (‘magit-sequence-abort’)
     現在のcherry-pickまたはrevertシーケンスを中止します。これにより、シ
     ーケンスの開始以降に行われたすべての変更が破棄されます。


File: magit.ja.info,  Node: Resetting,  Next: Stashing,  Prev: Cherry Picking,  Up: Manipulating

6.11 Resetting
==============

こちらもご覧下さい *note (gitman)git-reset::

‘x’ (‘magit-reset-quickly’)
     ‘HEAD’とインデックスを、ユーザーから読み取られたコミットにリセット
     し、デフォルトでその時点のコミットに設定します。場合によっては、作
     業ツリーもリセットします。プレフィックス引数を使用して作業ツリーを
     リセットします。それ以外の場合はリセットしません。

‘X m’ (‘magit-reset-mixed’)
     ‘HEAD’をリセットし、ユーザーから読み取ったコミットにインデックスを
     付け、デフォルトでその時点のコミットに設定します。作業ツリーはその
     まま保持されます。

‘X s’ (‘magit-reset-soft’)
     ‘HEAD’をユーザーから読み取ったコミットにリセットし、デフォルトでそ
     の時点でコミットします。インデックスと作業ツリーはそのまま保持され
     ます。

‘X h’ (‘magit-reset-hard’)
     ‘HEAD’、インデックス、および作業ツリーを、ユーザーから読み取られた
     コミットにリセットし、デフォルトでそのポイントのコミットに設定しま
     す。

‘X k’ (‘magit-reset-keep’)
     ‘HEAD’、インデックス、および作業ツリーを、ユーザーから読み取られた
     コミットにリセットし、デフォルトでそのポイントのコミットに設定しま
     す。コミットされていない変更はそのまま保持されます。

‘X i’ (‘magit-reset-index’)
     インデックスをユーザーから読み取ったコミットにリセットし、デフォル
     トでそのポイントでコミットします。‘HEAD’と作業ツリーをそのままにし
     ておくと、コミットが‘HEAD’を参照している場合、これによりすべての変
     更が効果的にステージ解除(unstage)されます。

‘X w’ (‘magit-reset-worktree’)
     作業ツリーをユーザーから読み取ったコミットにリセットし、デフォルト
     でその時点でコミットします。‘HEAD’とインデックスはそのままにします
     。

‘X f’ (‘magit-file-checkout’)
     作業ツリーのファイルを更新し、リビジョンのコンテンツにインデックス
     を付けます。リビジョンとファイルの両方がユーザーから読み取られます
     。


File: magit.ja.info,  Node: Stashing,  Prev: Resetting,  Up: Manipulating

6.12 Stashing
=============

こちらもご覧下さい *note (gitman)git-stash::

‘z’ (‘magit-stash’)
     このトランジェント(一時的)なプレフィックス(接頭辞)コマンドは、それ
     に従うサフィックス(接尾辞)コマンドを適切なインフィックス(中置)引数
     とともに結び付け、いずれかのサフィックスコマンドを選択するまでの間
     、そのインフィックス引数達とサフィックスコマンド達を一時バッファ
     (temporary buffer)に表示します。

‘z z’ (‘magit-stash-both’)
     インデックスと作業ツリーのスタッシュを作成します。追跡されていない
     ファイル(untracked files)が含まれるかどうかはインフィックス引数の指
     定に依ります。1つのプレフィックス引数は‘--include-untracked’と同等
     で、2つのプレフィックス引数は‘--all’と同等です。

‘z i’ (‘magit-stash-index’)
     インデックスのみのスタッシュを作成します。ステージされていない変更
     (unstaged changes)と追跡されていない変更(untracked changes)はスタッ
     シュされません。

‘z w’ (‘magit-stash-worktree’)
     作業ツリーにステージされていない変更(unstaged changes)のスタッシュ
     を作成します。追跡されていないファイル(untracked files)は、インフィ
     ックス引数に依ります。1つのプレフィックス引数は
     ‘--include-untracked’と同等で、2つのプレフィックス引数は‘--all’と同
     等です。

‘z x’ (‘magit-stash-keep-index’)
     インデックスをそのままにして、インデックスと作業ツリーのスタッシュ
     を作成します。追跡されていないファイル(untracked files)は、インフィ
     ックス引数に依ります。1つのプレフィックス引数は
     ‘--include-untracked’と同等で、2つのプレフィックス引数は‘--all’と同
     等です。

‘z Z’ (‘magit-snapshot-both’)
     インデックスと作業ツリーのスナップショットを作成します。追跡されて
     いないファイル(untracked files)は、インフィックス引数に依ります。
     1つのプレフィックス引数は‘--include-untracked’と同等で、2つのプレフ
     ィックス引数は‘--all’と同等です。

‘z I’ (‘magit-snapshot-index’)
     インデックスのみのスナップショットを作成します。ステージされていな
     い変更(unstaged changes)と追跡されていない変更(untracked changes)は
     スタッシュされません。

‘z W’ (‘magit-snapshot-worktree’)
     作業ツリーでステージされていない変更(unstaged changes)のスナップシ
     ョットを作成します。追跡されていないファイル(untracked files)は、イ
     ンフィックス引数に依ります。1つのプレフィックス引数は
     ‘--include-untracked’と同等で、2つのプレフィックス引数は‘--all’と同
     等です。

‘z a’ (‘magit-stash-apply’)
     作業ツリーにスタッシュを適用します。 スタッシュインデックスを保持す
     るよう試みます。ステージされた変更(staged changes)があるために失敗
     した場合は、スタッシュインデックスを保持せずに適用します。

‘z p’ (‘magit-stash-pop’)
     作業ツリーにスタッシュを適用し、スタッシュリストから削除します。ス
     タッシュインデックスを保持するよう試みます。ステージされた変更
     (staged changes)があるためにそれが失敗した場合は、スタッシュインデ
     ックスを保持せずに適用し、スタッシュを削除しません。

‘z k’ (‘magit-stash-drop’)
     スタッシュリストからスタッシュを削除します。リージョンがアクティブ
     になったら、含まれているすべてのスタッシュの削除を提案します。

‘z v’ (‘magit-stash-show’)
     バッファ内のスタッシュのすべてのdiffを表示します。

‘z b’ (‘magit-stash-branch’)
     STASHから新しいBRANCHを作成してチェックアウトします。ブランチは、ス
     タッシュが作成されたときの現在のコミットで開始されます。

‘z B’ (‘magit-stash-branch-here’)
     現在のブランチまたは‘HEAD’を開始点(starting-point)として
     ‘magit-branch’を使用して、新しいBRANCHを作成してチェックアウトしま
     す。それからSTASHを適用し、きれいに適用される場合はドロップします。

‘z f’ (‘magit-stash-format-patch’)
     STASHからパッチを作成します。

‘k’ (‘magit-stash-clear’)
     REFを削除して、REFのreflogに保存されているすべてのスタッシュを削除
     します。

‘z l’ (‘magit-stash-list’)
     バッファ内のすべてのスタッシュを一覧表示します。

 -- User Option: magit-stashes-margin
     このオプションは、欄外が最初にスタッシュバッファに表示されるかどう
     か、およびそのフォーマット方法を指定します。

     値の形式は‘(INIT STYLE WIDTH AUTHOR AUTHOR-WIDTH)’です。

        • INITがnil以外の場合、欄外(margin)が最初に表示されます。
        • STYLEは、作成者(author)またはコミッター(committer)の日付をフォ
          ーマットする方法を制御します。‘age’(コミットの経過時間を示す
          )または‘age-abbreviated’(時間単位を文字に短縮する)または実際の
          日付を表す文字列(‘format-time-string’に適しています)のいずれか
          になります。オプション‘magit-log-margin-show-committer-date’は
          、表示される日付を制御します。
        • WIDTHは、欄外(margin)の幅を制御します。これは上位互換性のため
          に存在し、現在値を変更すべきではありません。
        • AUTHORは、作成者の名前もデフォルトで表示されるかどうかを制御し
          ます。
        • AUTHOR-WIDTHは整数である必要があります。作成者の名前が表示され
          ている場合、これはそのために使用されるスペース(空き)の量を指定
          します。


File: magit.ja.info,  Node: Transferring,  Next: Miscellaneous,  Prev: Manipulating,  Up: Top

7 Transferring
**************

* Menu:

* Remotes::                  Remotes
* Fetching::                 Fetching
* Pulling::                  Pulling
* Pushing::                  Pushing
* Plain Patches::            Plain Patches
* Maildir Patches::          Maildir Patches


File: magit.ja.info,  Node: Remotes,  Next: Fetching,  Up: Transferring

7.1 Remotes
===========

* Menu:

* Remote Commands::          Remote Commands
* Remote Git Variables::     Remote Git Variables


File: magit.ja.info,  Node: Remote Commands,  Next: Remote Git Variables,  Up: Remotes

7.1.1 Remote Commands
---------------------

トランジェントプレフィックスコマンド‘magit-remote’は、リモートを追加し、
既存のリモートに変更を加えるために使用されます。このコマンドは、リモート
自体のみを処理し、ブランチやコミットの転送は処理しません。それらの機能は
個別のトランジェントコマンドから利用できます。

こちらもご覧下さい *note (gitman)git-remote::

‘M’ (‘magit-remote’)
     このトランジェント(一時的)プレフィックス(接頭辞)コマンドは、それに
     従うサフィックス(接尾辞)コマンド群を結びつけ、そのサフィックスコマ
     ンドのどれかを選ぶまでの間、サフィックス(接尾辞)コマンド群を一時バ
     ッファ(temporary buffer)に表示します。

     デフォルトでは、リモート関連のGit変数の値を結び付けて表示し、それら
     の値を変更することもできます。

 -- User Option: magit-remote-direct-configure
     このオプションは、リモート関連のGit変数にトランジェントコマンド
     ‘magit-remote’から直接アクセスできるかどうかを制御します。

     ‘t’(デフォルト)でローカルブランチがチェックアウトされている場合、
     ‘magit-remote’はそのブランチのアップストリームリモートの変数、また
     は‘HEAD’がデタッチされている場合で、存在する場合、‘origin’の変数を
     備えています。

     ‘nil’の場合は、‘magit-remote-configure’を使用する必要があります。

‘M C’ (‘magit-remote-configure’)
     このトランジェントレフィックスコマンドは、リモート関連変数の値を設
     定するコマンドを結び付け、一時バッファが終了するまでそれらを一時バ
     ッファに表示します。

     プレフィックス引数を使用すると、このコマンドは常にリモートの入力を
     求めます。

     プレフィックス引数がない場合、これは‘magit-remote’のサフィックスコ
     マンドとして呼び出されたかどうかと‘magit-remote-direct-configure’オ
     プションに依存します。‘magit-remote’がすでにアップストリームの変数
     を表示している場合、同じリモートの変数を表示する別のトランジェント
     コマンドを呼び出すことは意味がありません。その場合、このコマンドは
     リモートの入力を求めます。

変数についてはこちらの説明をご覧ください(*note Remote Git Variables::)。

‘M a’ (‘magit-remote-add’)
     このコマンドは、リモートを追加してフェッチします。リモート名とURLが
     ミニバッファで読み取られます。

‘M r’ (‘magit-remote-rename’)
     このコマンドは、リモートの名前を変更します。 古い名前と新しい名前の
     両方がミニバッファで読み取られます。

‘M u’ (‘magit-remote-set-url’)
     このコマンドは、リモートのURLを変更します。リモートと新しいURLの両
     方がミニバッファで読み取られます。

‘M k’ (‘magit-remote-remove’)
     このコマンドは、ミニバッファに読み込まれたリモートを削除します。

‘M p’ (‘magit-remote-prune’)
     このコマンドは、ミニバッファ内でリモートを読み取り、古いリモート追
     跡ブランチを削除します。

‘M P’ (‘magit-remote-prune-refspecs’)
     このコマンドは、ミニバッファ内で読み取られたリモートの陳腐化した
     (stale)refspecを削除します。

     refspecでフェッチされるブランチがリモートに1つも存在しない場合、そ
     のrefspecは陳腐化しています。陳腐化したrefspecがあると、Gitがその行
     以降の陳腐化してないrefspecによるフェッチも拒否するため、問題があり
     ます。

     陳腐化したrefspecのみが残っている場合、このコマンドは、リモートを削
     除するか、陳腐化したrefspecをデフォルトのrefspec
     ("+refs/heads/*:refs/remotes/REMOTE/*") に置き換えることを提案しま
     す。

     このコマンドは、今や陳腐化したrefspecsのために作成されたリモートト
     ラッキングブランチも削除します。他の陳腐化したブランチは削除されま
     せん。

 -- User Option: magit-remote-add-set-remote.pushDefault
     このオプションは、リモートを追加した後に‘remote.pushDefault’を設定
     するかどうかをユーザーに尋ねるかどうかを制御します。

     ‘ask’の場合、ユーザーは常に質問されます。‘ask-if-unset’の場合、ユー
     ザーは変数がまだ設定されていない場合にのみ使用できます。‘nil’の場合
     、ユーザーは尋ねられず、変数は設定されません。値が文字列の場合、追
     加されたリモートの名前がその文字列と等しく、変数がまだ設定されてい
     なければ、ユーザーに尋ねられることなく変数が設定されます。


File: magit.ja.info,  Node: Remote Git Variables,  Prev: Remote Commands,  Up: Remotes

7.1.2 Remote Git Variables
--------------------------

これらの変数は、トランジェントプレフィックスコマンド
‘magit-remote-configure’から設定できます。デフォルトでは、
‘magit-remote’から設定することもできます。こちらを参照して下さい(*note
Remote Commands::)。

 -- Variable: remote.NAME.url
     この変数は、NAMEという名前のリモートのURLを指定します。複数の値を持
     つことができます。

 -- Variable: remote.NAME.fetch
     NAMEという名前のリモートからフェッチするときに使用されるrefspecです
     。複数の値を持つことができます。

 -- Variable: remote.NAME.pushurl
     この変数は、NAME という名前のリモートへのプッシュに使用される URL を
     指定します。 指定されていない場合は、代わりに ‘remote.NAME.url’ が
     使用されます。 複数の値を持つことができます。

 -- Variable: remote.NAME.push
     NAMEという名前のリモートにプッシュするときに使用されるrefspecです。
     複数の値を持つことができます。

 -- Variable: remote.NAME.tagOpts
     この変数は、デフォルトでフェッチされるタグを指定します。値が
     ‘--no-tags’の場合、タグはフェッチされません。値が‘--tags’の場合、す
     べてのタグがフェッチされます。この変数に値がない場合、フェッチされ
     たブランチから到達可能なタグのみがフェッチされます。


File: magit.ja.info,  Node: Fetching,  Next: Pulling,  Prev: Remotes,  Up: Transferring

7.2 Fetching
============

こちらもご覧下さい *note (gitman)git-fetch:: アップストリーム
(upstream)とプッシュリモート(push-remote)の詳細についてはこちらを参照し
て下さい(*note The Two Remotes::)。

‘f’ (‘magit-fetch’)
     このトランジェント(一時的)なプレフィックス(接頭辞)コマンドは、それ
     に従うサフィックス(接尾辞)コマンドを適切なインフィックス(中置)引数
     とともに結び付け、いずれかのサフィックスコマンドを選択するまでの間
     、そのインフィックス引数達とサフィックスコマンド達を一時バッファ
     (temporary buffer)に表示します。

‘f p’ (‘magit-fetch-from-pushremote’)
     このコマンドは、現在のプッシュリモートからフェッチします。

     プレフィックス引数を使用する場合、またはプッシュリモートが構成され
     ていないか使用できない場合は、最初にユーザーにプッシュリモートを構
     成させます。

‘f u’ (‘magit-fetch-from-upstream’)
     このコマンドは、現在のブランチのアップストリームからフェッチします
     。

     アップストリームが現在のブランチ用に構成されていて、既存のリモート
     に名前を付けている場合は、それを使用します。それ以外の場合は、別の
     リモートを使用しようと試みます。リモートが1つだけ構成されている場合
     は、それを使用します。それ以外の場合、"origin"という名前のリモート
     が存在する場合は、それを使用します。

     リモートを判別できない場合、このコマンドは‘magit-fetch’トランジェン
     トプレフィックスコマンドから使用できず、直接呼び出すとエラーになり
     ます。

‘f e’ (‘magit-fetch-other’)
     このコマンドは、ミニバッファから読み取られたリポジトリからフェッチ
     します。

‘f o’ (‘magit-fetch-branch’)
     このコマンドは、リモートからブランチをフェッチします。どちらもミニ
     バッファから読み取られます。

‘f r’ (‘magit-fetch-refspec’)
     このコマンドは、明示的なrefspecを使用してリモートからフェッチします
     。どちらも、ミニバッファから読み取られます。

‘f a’ (‘magit-fetch-all’)
     このコマンドは、すべてのリモートからフェッチします。

‘f m’ (‘magit-submodule-fetch’)
     このコマンドは、すべてのサブモジュールをフェッチします。プレフィッ
     クス引数を使用して、すべてのサブモジュールのすべてのリモートをフェ
     ッチします。

 -- User Option: magit-pull-or-fetch
     デフォルトでは、フェッチコマンドとプルコマンドは、個別のトランジェ
     ントプレフィックスコマンドから使用できます。これを‘t’に設定すると、
     (すべてではありませんが)上記のサフィックスコマンドの一部が
     ‘magit-pull’トランジェントコマンドに追加されます。

     あなたがそうしたい場合、これらのプレフィックスコマンドのキーバイン
     ディングを変更することもできます。例:

          (setq magit-pull-or-fetch t)
          (define-key magit-mode-map "f" 'magit-pull) ; was magit-fetch
          (define-key magit-mode-map "F" nil)         ; was magit-pull


File: magit.ja.info,  Node: Pulling,  Next: Pushing,  Prev: Fetching,  Up: Transferring

7.3 Pulling
===========

こちらもご覧下さい *note (gitman)git-pull:: アップストリーム(upstream)と
プッシュリモート(push-remote)の詳細についてはこちらを参照して下さい
(*note The Two Remotes::)。

‘F’ (‘magit-pull’)
     このトランジェント(一時的)プレフィックス(接頭辞)コマンドは、それに
     従うサフィックス(接尾辞)コマンド群を結びつけ、そのサフィックスコマ
     ンドのどれかを選ぶまでの間、サフィックス(接尾辞)コマンド群を一時バ
     ッファ(temporary buffer)に表示します。

‘F p’ (‘magit-pull-from-pushremote’)
     このコマンドは、現在のブランチのプッシュリモートからプルします。

     プレフィックス引数を使用する場合、またはプッシュリモートが構成され
     ていないか使用できない場合は、最初にユーザーにプッシュリモートを構
     成させます。

‘F u’ (‘magit-pull-from-upstream’)
     このコマンドは、現在のブランチのアップストリームからプルします。

     プレフィックス引数を使用する場合、またはアップストリームが構成され
     ていないか使用できない場合は、ユーザーが最初にアップストリームを構
     成できるようにします。

‘F e’ (‘magit-pull-branch’)
     このコマンドは、ミニバッファで読み取られたブランチからプルします。


File: magit.ja.info,  Node: Pushing,  Next: Plain Patches,  Prev: Pulling,  Up: Transferring

7.4 Pushing
===========

こちらもご覧下さい *note (gitman)git-push:: アップストリーム(upstream)と
プッシュリモート(push-remote)の詳細についてはこちらを参照して下さい
(*note The Two Remotes::)。

‘P’ (‘magit-push’)
     このトランジェント(一時的)なプレフィックス(接頭辞)コマンドは、それ
     に従うサフィックス(接尾辞)コマンドを適切なインフィックス(中置)引数
     とともに結び付け、いずれかのサフィックスコマンドを選択するまでの間
     、そのインフィックス引数達とサフィックスコマンド達を一時バッファ
     (temporary buffer)に表示します。

‘P p’ (‘magit-push-current-to-pushremote’)
     このコマンドは、現在のブランチをそのプッシュリモートにプッシュしま
     す。

     プレフィックス引数を使用する場合、またはプッシュリモートが構成され
     ていないか使用できない場合は、最初にユーザーにプッシュリモートを構
     成させます。

‘P u’ (‘magit-push-current-to-upstream’)
     このコマンドは、現在のブランチをそのアップストリームブランチにプッ
     シュします。

     プレフィックス引数を使用する場合、またはアップストリームが構成され
     ていないか使用できない場合は、ユーザーが最初にアップストリームを構
     成できるようにします。

‘P e’ (‘magit-push-current’)
     このコマンドは、現在のブランチをミニバッファで読み取られたブランチ
     にプッシュします。

‘P o’ (‘magit-push-other’)
     このコマンドは、任意のブランチをプッシュするか、どこかにコミットし
     ます。ソースとターゲットの両方がミニバッファで読み取られます。

‘P r’ (‘magit-push-refspecs’)
     このコマンドは、1つまたは複数のrefspecを使用してリモートにプッシュ
     します。どちらもミニバッファで読み取られます。

     複数のrefspecを使用するには、それらをコンマで区切ります。補完は、コ
     ロンの前の部分、またはコロンが使用されていない場合にのみ使用できま
     す。

‘P m’ (‘magit-push-matching’)
     このコマンドは、一致するすべてのブランチを別のリポジトリにプッシュ
     します。

     リモートが1つしかない場合は、そこにプッシュします。それ以外の場合は
     、リモートのプロンプトを表示し、現在のブランチ用に構成されたリモー
     トをデフォルトとして提供します。

‘P t’ (‘magit-push-tags’)
     このコマンドは、すべてのタグを別のリポジトリにプッシュします。

     リモートが1つしかない場合は、そこにプッシュします。それ以外の場合は
     、リモートのプロンプトを表示し、現在のブランチ用に構成されたリモー
     トをデフォルトとして提供します。

‘P T’ (‘magit-push-tag’)
     このコマンドは、タグを別のリポジトリにプッシュします。

注意: インフィックス引数の1つである‘--force-with-lease’には、注意が必要
です。値なしで渡されます。これは、「リモート追跡ブランチがリモートエンド
の対応するブランチと一致する限り、強制プッシュを許可する」ことを意味しま
す。(Magit自体はそのような機能を提供しませんが、)あなたが自動フェッチを
実行するツールを設定した場合、‘--force-with-lease’を使用すると、実際には
リモートトラッキングへの参照状態(the state of the remote-tracking refs)を
制御または認識していないため、危険な場合があります。その場合は、
‘push.useForceIfIncludes’を‘true’に設定することを検討する必要があります
(Git 2.30以降で使用可能)。

さらに2つのプッシュコマンドが存在しますが、デフォルトではプッシュトラン
ジェントコマンドからは使用できません。それらをトランジェントコマンドに追
加する方法については、doc-stringsを参照してください。

 -- Command: magit-push-implicitly args
     このコマンドは、明示的なrefspecを使用せずにどこかにプッシュします。

     このコマンドは、単純に‘git push -v [ARGS]’を実行するだけです。
     ARGSはインフィックス引数です。明示的なrefspec引数は使用されません。
     代わりに、動作は少なくとも次のGit変数に依存します: ‘push.default’、
     ‘remote.pushDefault’、‘branch.<branch>.pushRemote’、
     ‘branch.<branch>.remote’、‘branch.<branch>.merge’、
     ‘remote.<remote>.push’

     あなたがdescriptionを明示的に指定せずにこのサフィックスコマンドをト
     ランジェントプレフィックスコマンド追加すると、Magitはこのコマンドの
     動作を予測しようとします。例えば:

          (transient-insert-suffix 'magit-push \"p\"
            '(\"i\" magit-push-implicitly))"

 -- Command: magit-push-to-remote remote args
     このコマンドは、明示的なrefspecを使用せずにリモートであるREMOTEにプ
     ッシュします。リモートはミニバッファに読み込まれます。

     このコマンドは、単純に‘git push -v [ARGS] REMOTE’を実行するだけです
     。ARGSはインフィックス引数です。refspec引数は使用されません。 代わ
     りに、動作は少なくとも次のGit変数に依存します: ‘push.default’、
     ‘remote.pushDefault’、‘branch.<branch>.pushRemote’、
     ‘branch.<branch>.remote’、‘branch.<branch>.merge’、
     ‘remote.<remote>.push’


File: magit.ja.info,  Node: Plain Patches,  Next: Maildir Patches,  Prev: Pushing,  Up: Transferring

7.5 Plain Patches
=================

‘W’ (‘magit-patch’)
     このトランジェント(一時的)なプレフィックス(接頭辞)コマンドは、それ
     に従うサフィックス(接尾辞)コマンドを適切なインフィックス(中置)引数
     とともに結び付け、いずれかのサフィックスコマンドを選択するまでの間
     、そのインフィックス引数達とサフィックスコマンド達を一時バッファ
     (temporary buffer)に表示します。

‘W c’ (‘magit-patch-create’)
     このコマンドは、コミットの組み(a set commits)のパッチを作成します。
     リージョンが複数のコミットをマークする場合、それらすべてのパッチを
     作成します。それ以外の場合は、トランジェントプレフィックスコマンド
     として機能します。このコマンドは、いくつかのインフィックス引数を備
     え、サフィックスコマンドとして自身を結び付けます。このコマンドがそ
     れ自体のサフィックスコマンドとして呼び出されると、指定されたインフ
     ィックス引数を使用してパッチが作成されます。

‘w a’ (‘magit-patch-apply’)
     このコマンドはパッチを適用します。これはトランジェントプレフィック
     スコマンドであり、いくつかのインフィックス引数を備え、サフィックス
     コマンドとしてそれ自体を結び付けます。このコマンドがそれ自体のサフ
     ィックスコマンドとして呼び出されると、指定されたインフィックス引数
     を使用してパッチが適用されます。

‘W s’ (‘magit-patch-save’)
     このコマンドは、現在のdiffからパッチを作成します。

     ‘magit-diff-mode’または‘magit-revision-mode’バッファ内では、‘C-x
     C-w’もこのコマンドに結び付けられています。

‘magit-diff-mode’または‘magit-revision-mode’バッファ内で‘C-x C-w’を使用
して、プレーンパッチファイルを保存することもできます。


File: magit.ja.info,  Node: Maildir Patches,  Prev: Plain Patches,  Up: Transferring

7.6 Maildir Patches
===================

こちらもご覧下さい *note (gitman)git-am:: と *note (gitman)git-apply::

‘w’ (‘magit-am’)
     このトランジェント(一時的)なプレフィックス(接頭辞)コマンドは、それ
     に従うサフィックス(接尾辞)コマンドを適切なインフィックス(中置)引数
     とともに結び付け、いずれかのサフィックスコマンドを選択するまでの間
     、そのインフィックス引数達とサフィックスコマンド達を一時バッファ
     (temporary buffer)に表示します。

‘w w’ (‘magit-am-apply-patches’)
     このコマンドは、1つ以上のパッチを適用します。リージョンがファイルを
     マークしている場合、それらはパッチとして適用されます。それ以外の場
     合、このコマンドはミニバッファ内のファイル名を読み取り、デフォルト
     ではそのポイントのファイルになります。

‘w m’ (‘magit-am-apply-maildir’)
     このコマンドは、maildirからパッチを適用します。

‘w a’ (‘magit-patch-apply’)
     このコマンドは、プレーンパッチを適用します。詳細はこちらをご覧下さ
     い(*note Plain Patches::)。 このコマンドは、歴史的な理由から、
     ‘magit-am’トランジェントコマンドからのみ使用できます。

"am"操作が進行中の場合、トランジェントコマンドには代わりのサフィックスコ
マンドがあります。

‘w w’ (‘magit-am-continue’)
     このコマンドは、現在のパッチ適用シーケンスを再開します。

‘w s’ (‘magit-am-skip’)
     このコマンドは、パッチ適用シーケンス中にパッチ当てが中断したものを
     スキップします。

‘w a’ (‘magit-am-abort’)
     このコマンドは、現在のパッチ適用シーケンスを中止(abort)します。 こ
     れにより、シーケンスの開始以降に行われたすべての変更が破棄されます
     。


File: magit.ja.info,  Node: Miscellaneous,  Next: Customizing,  Prev: Transferring,  Up: Top

8 Miscellaneous
***************

* Menu:

* Tagging::                  Tagging
* Notes::                    Notes
* Submodules::               Submodules
* Subtree::                  Subtree
* Worktree::                 Worktree
* Sparse checkouts::         Sparse checkouts
* Bundle::                   Bundle
* Common Commands::          Common Commands
* Wip Modes::                Wip Modes
* Commands for Buffers Visiting Files::  Commands for Buffers Visiting Files
* Minor Mode for Buffers Visiting Blobs::  Minor Mode for Buffers Visiting
                                             Blobs


File: magit.ja.info,  Node: Tagging,  Next: Notes,  Up: Miscellaneous

8.1 Tagging
===========

こちらもご覧下さい *note (gitman)git-tag::

‘t’ (‘magit-tag’)
     このトランジェント(一時的)なプレフィックス(接頭辞)コマンドは、それ
     に従うサフィックス(接尾辞)コマンドを適切なインフィックス(中置)引数
     とともに結び付け、いずれかのサフィックスコマンドを選択するまでの間
     、そのインフィックス引数達とサフィックスコマンド達を一時バッファ
     (temporary buffer)に表示します。

‘t t’ (‘magit-tag-create’)
     このコマンドは、REVで指定されたNAMEを使用して新しいタグを作成します
     。プレフィックス引数を使用して、注釈付きタグ(annotated tag)を作成し
     ます。

‘t r’ (‘magit-tag-release’)
     このコマンドはリリースタグを作成します。リリースタグが
     ‘magit-release-tag-regexp’と一致することを前提としています。

     最初に、既存の最も最近のタグを初期入力として表示して新しいタグの名
     前の入力を求め、バージョン文字列の部分をインクリメントするようにユ
     ーザーに任せます。 型破りなリリースタグまたはバージョン番号(例:
     ‘v1.2.3-custom.1’)を使用する場合、あなたは
     ‘magit-release-tag-regexp’と‘magit-tag-version-regexp-alist’変数を
     設定できます。

     ‘--annotate’が有効になっている場合は、新しいタグのメッセージ入力を
     求められます。提案されたタグメッセージは、対応するバージョン文字列
     を含み、その代わりに新しいバージョン文字列を使用するという条件で、
     最も最近のタグのメッセージに基づいています。それ以外の場合は、例え
     ば、TAG "v1.2.3"と"/path/to/foo-bar"のようなリポジトリであれば
     ."Foo-Bar 1.2.3"のようなものを提案します。

‘t k’ (‘magit-tag-delete’)
     このコマンドは、1つ以上のタグを削除します。リージョンが複数のタグを
     マークしている場合(そして他には何もマークしていない場合)、それらを
     削除することを提案します。それ以外の場合は、単一のタグを削除するよ
     うに求められ、デフォルトでそのポイントのタグになります。

‘t p’ (‘magit-tag-prune’)
     このコマンドは、REMOTEにありローカルに欠落しているタグを削除するこ
     とを提案します。その逆も同様にします。


File: magit.ja.info,  Node: Notes,  Next: Submodules,  Prev: Tagging,  Up: Miscellaneous

8.2 Notes
=========

こちらもご覧下さい *note (gitman)git-notes::.

‘T’ (‘magit-notes’)
     このトランジェント(一時的)なプレフィックス(接頭辞)コマンドは、それ
     に従うサフィックス(接尾辞)コマンドを適切なインフィックス(中置)引数
     とともに結び付け、いずれかのサフィックスコマンドを選択するまでの間
     、そのインフィックス引数達とサフィックスコマンド達を一時バッファ
     (temporary buffer)に表示します。

‘T T’ (‘magit-notes-edit’)
     コミットに添付されたnoteを編集します。デフォルトでは、そのポイント
     でのコミットになります。

     デフォルトでは、Git変数‘core.notesRef’または "refs/notes/commits"の
     値が未定義の場合は、その値を使用します。

‘T r’ (‘magit-notes-remove’)
     コミットに添付されたnoteを削除します。デフォルトでは、そのポイント
     でのコミットになります。

     デフォルトでは、Git変数‘core.notesRef’または "refs/notes/commits"の
     値が未定義の場合は、その値を使用します。

‘T p’ (‘magit-notes-prune’)
     到達不能なコミットに関するnoteを削除します。

1つのnote refを別のnote refにマージすることが可能です。 その結果、一時的
なワークツリー ".git/NOTES_MERGE_WORKTREE" で解決する必要のある競合が発
生する可能性があります。

‘T m’ (‘magit-notes-merge’)
     ユーザーから読み取ったrefのnotesを現在のnotes refにマージします。現
     在のnotes refは、Git変数‘core.notesRef’の値、または定義されていない
     場合は"refs/notes/commits"の値です。

notesのマージが進行中の場合、トランジェントコマンドは上記のコマンドに代
わるサフィックスコマンドがあります。

‘T c’ (‘magit-notes-merge-commit’)
     競合を手動で解決した後、現在のnotes refマージをコミットします。

‘T a’ (‘magit-notes-merge-abort’)
     現在のnotes ref マージを中止(abort)します。

以下の変数達は、notes referenceに‘magit-notes-*’と‘git notes’と‘git
show’がどのように作用して表示するかを制御します。ローカル値とグローバル
値の両方が表示され、変更できます。

 -- Variable: core.notesRef
     この変数は、デフォルトで表示されるnotes refと、デフォルトで動作する
     コマンドを指定します。

 -- Variable: notes.displayRef
     この変数は、‘core.notesRef’で指定されたrefに加えて、表示される追加
     のnotes refを指定します。複数の値を持つことができ、‘*’で終わる場合
     は、‘refs/notes/’名前空間(または一部の名前にスラッシュが含まれてい
     る場合は‘**’)内のすべてのrefを表示します。


File: magit.ja.info,  Node: Submodules,  Next: Subtree,  Prev: Notes,  Up: Miscellaneous

8.3 Submodules
==============

こちらもご覧下さい *note (gitman)git-submodule::

* Menu:

* Listing Submodules::       Listing Submodules
* submodule用トランジェントコマンド::  submodule用トランジェントコマンド


File: magit.ja.info,  Node: Listing Submodules,  Next: submodule用トランジェントコマンド,  Up: Submodules

8.3.1 Listing Submodules
------------------------

コマンド‘magit-list-submodules’は、現在のリポジトリのサブモジュールのリ
ストを別のバッファに表示します。(*note Status Module Sections::)で説明さ
れているように、‘magit-insert-modules’をフック
‘magit-status-sections-hook’に追加することで、スーパーリポジトリ
(super-repository)のステータスバッファにサブモジュールに関する情報を直接
表示することもできます。

 -- Command: magit-list-submodules
     このコマンドは、現在のリポジトリのサブモジュールのリストを別のバッ
     ファに表示します。

     "Modules"というタイトルのセクションで‘RET’を押すと呼び出すことがで
     きます。

 -- User Option: magit-submodule-list-columns
     このオプションは、コマンド‘magit-list-submodules’によって表示される
     列とその表示方法を制御します。

     各要素の形式は‘(HEADER WIDTH FORMAT PROPS)’です。

     HEADERは、ヘッダーに表示される文字列です。WIDTHは、列の幅です。
     FORMATは、1つの引数とリポジトリID(通常はそのベース名)と作業ツリーの
     最上位に結び付けられたされた‘default-directory’を使用して呼び出され
     る関数です。挿入する文字列またはnilを返す必要があります。PROPSは、
     キー‘:right-align’と‘:pad-right’と‘:sort’をサポートするalistです。

     ‘:sort’ 関数は、 ‘tabulated-list--get-sort’ の docstring に記述され
     ている奇妙なインターフェースを持っています。 あるいは ‘<’ や
     ‘magit-repolist-version<’ を使用できます。これらの関数は、インター
     フェイスを満たす関数に自動的に置き換えられます。 ‘:sort’ を ‘nil’ に
     設定してソートを禁止します。 指定しない場合、列はデフォルトのソータ
     ーを使用してソート可能です。

     あなたは列ごとに1文字だけを使用し、列間にパディングなしで数値列の範
     囲を表示したい場合があるかもしれません。その場合は、適切なHEADERを
     使用し、WIDTHを1に設定し、‘:pad-right’を9に設定する必要があります。
     ‘+’は、9より大きい数値に置き換えられます。


File: magit.ja.info,  Node: submodule用トランジェントコマンド,  Prev: Listing Submodules,  Up: Submodules

8.3.2 submodule用トランジェントコマンド
---------------------------------------

‘o’ (‘magit-submodule’)
     このトランジェント(一時的)なプレフィックス(接頭辞)コマンドは、それ
     に従うサフィックス(接尾辞)コマンドを適切なインフィックス(中置)引数
     とともに結び付け、いずれかのサフィックスコマンドを選択するまでの間
     、そのインフィックス引数達とサフィックスコマンド達を一時バッファ
     (temporary buffer)に表示します。

以下のコマンドのいくつかは、デフォルトで、リージョンを使用して選択された
モジュールに作用します。簡潔にするために、それらの説明は「選択されたモジ
ュール」について説明していますが、モジュールが選択されていない場合は、代
わりに現在のモジュールに作用します。ポイントがモジュール上にない場合は、
単一のモジュールを読み取って作用します。プレフィックス引数を使用すると、
これらのコマンドは選択したのや現在のモジュールを無視し、その代わりにすべ
ての適切なモジュールに作用します。

‘o a’ (‘magit-submodule-add’)
     このコマンドは、指定のURLのリポジトリをモジュールとして追加します。
     オプションのPATHは、スーパープロジェクトのルートを基準にしたモジュ
     ールへのパスです。nilの場合、パスはURLに基づいて決定されます。

‘o r’ (‘magit-submodule-register’)
     このコマンドは、URLを".gitmodules"から"$GIT_DIR/config"にコピーする
     ことにより、選択したモジュールを登録します。これらの値は、
     ‘magit-submodule-populate’を実行する前に編集できます。URLを編集する
     必要がない場合は、後者を直接使用してください。

‘o p’ (‘magit-submodule-populate’)
     このコマンドは、選択したモジュールの1つまたは複数の作業ディレクトリ
     を作成し、記録されたコミットをチェックアウトします。

‘o u’ (‘magit-submodule-update’)
     このコマンドは、記録されたコミットをチェックアウトする選択したモジ
     ュールを更新します。

‘o s’ (‘magit-submodule-synchronize’)
     このコマンドは、選択したモジュールのURLを同期し、スーパープロジェク
     トの".gitmodules"から".git/config"に値をコピーし、モジュールの値も
     コピーします。

‘o d’ (‘magit-submodule-unpopulate’)
     このコマンドは、選択したモジュールの作業ディレクトリを削除します。

‘o l’ (‘magit-list-submodules’)
     このコマンドは、現在のリポジトリのモジュールのリストを表示します。

‘o f’ (‘magit-fetch-modules’)
     このコマンドは、すべてのモジュールをフェッチします。

     オプション‘magit-fetch-modules-jobs’は、並列にフェッチされるサブモ
     ジュールの数を制御します。‘git fetch’はスーパーリポジトリのフェッチ
     を行わないことをサポートしていないため、スーパーリポジトリもフェッ
     チします。プレフィックス引数を使用すると、すべてのリモートをフェッ
     チします。


File: magit.ja.info,  Node: Subtree,  Next: Worktree,  Prev: Submodules,  Up: Miscellaneous

8.4 Subtree
===========

こちらもご覧下さい *note (gitman)git-subtree::

‘O’ (‘magit-subtree’)
     このトランジェントプレフィックスコマンドは、2つのサブトランジェント
     コマンドを結び付けます。1つはサブツリーをインポートするためのもので
     、もう1つはサブツリーをエクスポートするためのものです。

‘O i’ (‘magit-subtree-import’)
     このトランジェント(一時的)なプレフィックス(接頭辞)コマンドは、それ
     に従うサフィックス(接尾辞)コマンドを適切なインフィックス(中置)引数
     とともに結び付け、いずれかのサフィックスコマンドを選択するまでの間
     、そのインフィックス引数達とサフィックスコマンド達を一時バッファ
     (temporary buffer)に表示します。

     このコマンドのサフィックスコマンドはサブツリーをインポートします。

     ‘--prefix’引数が設定されている場合、サフィックスコマンドはユーザー
     にプロンプトを表示せずにそのプレフィックス引数を使用します。設定さ
     れていない場合は、ミニバッファでプレフィックス引数を読み取ります。

‘O i a’ (‘magit-subtree-add’)
     このコマンドは、REPOSITORYからのCOMMITをPREFIXの新しいサブツリーと
     して追加します。

‘O i c’ (‘magit-subtree-add-commit’)
     このコマンドは、COMMITをPREFIXの新しいサブツリーとして追加します。

‘O i m’ (‘magit-subtree-merge’)
     このコマンドは、COMMITをPREFIXサブツリーにマージします。

‘O i f’ (‘magit-subtree-pull’)
     このコマンドは、COMMITをREPOSITORYからPREFIXサブツリーにプルします
     。

‘O e’ (‘magit-subtree-export’)
     このトランジェント(一時的)なプレフィックス(接頭辞)コマンドは、それ
     に従うサフィックス(接尾辞)コマンドを適切なインフィックス(中置)引数
     とともに結び付け、いずれかのサフィックスコマンドを選択するまでの間
     、そのインフィックス引数達とサフィックスコマンド達を一時バッファ
     (temporary buffer)に表示します。

     このコマンドのサフィックスコマンドはサブツリーをエクスポートします
     。

     ‘--prefix’引数が設定されている場合、サフィックスコマンドはユーザー
     にプロンプトを表示せずにそのプレフィックス引数を使用します。設定さ
     れていない場合は、ミニバッファでプレフィックス引数を読み取ります。

‘O e p’ (‘magit-subtree-push’)
     このコマンドは、サブツリーPREFIXの履歴を抽出し、それをREPOSITORYの
     REFにプッシュします。

‘O e s’ (‘magit-subtree-split’)
     このコマンドは、サブツリーPREFIXの履歴を抽出します。


File: magit.ja.info,  Node: Worktree,  Next: Sparse checkouts,  Prev: Subtree,  Up: Miscellaneous

8.5 Worktree
============

こちらもご覧下さい *note (gitman)git-worktree::

‘Z’ (‘magit-worktree’)
     このトランジェント(一時的)プレフィックス(接頭辞)コマンドは、それに
     従うサフィックス(接尾辞)コマンド群を結びつけ、そのサフィックスコマ
     ンドのどれかを選ぶまでの間、サフィックス(接尾辞)コマンド群を一時バ
     ッファ(temporary buffer)に表示します。

‘Z b’ (‘magit-worktree-checkout’)
     PATHの新しいworktreeでBRANCHをチェックアウトします。

‘Z c’ (‘magit-worktree-branch’)
     新しいBRANCHを作成し、PATHの新しいworktreeでチェックアウトします。

‘Z m’ (‘magit-worktree-move’)
     既存のworktreeを新しいPATHに移動します。

‘Z k’ (‘magit-worktree-delete’)
     worktreeを削除します。デフォルトでは、ポイントのworktreeになります
     。プライマリworktreeは削除できません。

‘Z g’ (‘magit-worktree-status’)
     ポイントでのworktreeのステータスを表示します。

     ポイントにworktreeがない場合は、ミニバッファでworktreeを読み取りま
     す。ポイントのworktreeが、現在のバッファにステータスがすでに表示さ
     れているworktreeである場合は、代わりにDiredで表示します。


File: magit.ja.info,  Node: Sparse checkouts,  Next: Bundle,  Prev: Worktree,  Up: Miscellaneous

8.6 Sparse checkouts
====================

スパースチェックアウトは、作業ツリーをディレクトリのサブセットに制限する
方法を提供します。 以下をご覧下さい *note (gitman)git-sparse-checkout::.

*警告*: Git はバージョン 2.25 で ‘git sparse-checkout’ コマンドを導入し
ましたが、まだ実験的であり、変更される可能性があると公告しています。
Magit のインターフェイスも同様と見なす必要があります。 特に、Git が下位
互換性のない変更を導入した場合、Magit のスパースチェックアウト機能は、よ
り新しい Git バージョンを必要とする方法で更新される可能性があります。

‘>’ (‘magit-sparse-checkout’)
     このトランジェント(一時的)プレフィックス(接頭辞)コマンドは、それに
     従うサフィックス(接尾辞)コマンド群を結びつけ、そのサフィックスコマ
     ンドのどれかを選ぶまでの間、サフィックス(接尾辞)コマンド群を一時バ
     ッファ(temporary buffer)に表示します。

‘> e’ (‘magit-sparse-checkout-enable’)
     このコマンドは、最上位ディレクトリ内のファイルのみを含むスパースチ
     ェックアウトを初期化します。

     注意: ‘magit-sparse-checkout-set’ と ‘magit-sparse-checkout-add’ は
     、必要に応じてスパースチェックアウトを自動的に初期化することに注意
     してください。 ただし、‘magit-sparse-checkout-enable’ を明示的に呼
     び出して、‘magit-sparse-checkout-disable’ を呼び出した後にスパース
     チェックアウトを再初期化し、追加の引数を ‘git sparse-checkout init’
     に渡すこともできます。 または初期化を非同期で実行します。

‘> s’ (‘magit-sparse-checkout-set’)
     このコマンドは、ディレクトリのリストを取得し、それらのサブディレク
     トリ内のファイルのみを含めるようにスパースチェックアウトを構成しま
     す。 指定されたディレクトリのリストに含まれていない限り、以前に含ま
     れていたディレクトリは除外されます。

‘> a’ (‘magit-sparse-checkout-add’)
     このコマンドは ‘magit-sparse-checkout-set’ に似ていますが、代わりに
     、指定されたディレクトリのリストを、スパース チェックアウトに既に含
     まれているディレクトリのセットに追加します。

‘> r’ (‘magit-sparse-checkout-reapply’)
     このコマンドは、現在構成されているスパースチェックアウトパターンを
     作業ツリーに適用します。 これは、マージやリベースなどの操作の後に除
     外されたファイルがチェックアウトされている場合に呼び出すと便利です
     。

‘> d’ (‘magit-sparse-checkout-disable’)
     このコマンドは、完全なチェックアウト(full checkout)を復元
     (restore)します。 以前のスパースチェックアウトに戻るには、
     ‘magit-sparse-checkout-enable’ を呼び出します。

‘magit-clone’ トランジェントで ‘magit-clone-sparse’ コマンドを使用してリ
ポジトリのクローンを作成するときに、スパースチェックアウトを開始すること
もできます (*note Cloning Repository:: を参照)。

スパースチェックアウトが有効になっていることをステータスバッファーに表示
する場合は、関数 ‘magit-sparse-checkout-insert-header’ を
‘magit-status-headers-hook’ に追加します。


File: magit.ja.info,  Node: Bundle,  Next: Common Commands,  Prev: Sparse checkouts,  Up: Miscellaneous

8.7 Bundle
==========

こちらもご覧下さい *note (gitman)git-bundle::.

 -- Command: magit-bundle
     このトランジェント(一時的)プレフィックス(接頭辞)コマンドは、‘git
     bundle’サブコマンドを実行するためのいくつかのサフィックス(接尾辞)コ
     マンドを結び付け、サフィックスコマンドが呼び出されるまでそれらを一
     時バッファ(temporary buffer)に表示します。


File: magit.ja.info,  Node: Common Commands,  Next: Wip Modes,  Prev: Bundle,  Up: Miscellaneous

8.8 Common Commands
===================

 -- Command: magit-switch-to-repository-buffer
 -- Command: magit-switch-to-repository-buffer-other-window
 -- Command: magit-switch-to-repository-buffer-other-frame
 -- Command: magit-display-repository-buffer
     これらのコマンドは、現在のリポジトリに属する既存のMagitバッファをユ
     ーザーから読み取り、(リフレッシュせずに)選択したバッファに切り替え
     ます。

     最後のバリエーションは‘magit-display-buffer’を使用してこれを行うた
     め、‘magit-display-buffer-function’を尊重します。

これらは、メジャーモードが‘magit-mode’から派生するすべてのバッファで使用
できるコマンドの一部です。以下のコマンドのほかに他の一般的なコマンドがあ
りますが、これらは他には当てはまりませんでした。

‘C-w’ (‘magit-copy-section-value’)
     このコマンドは、現在のセクションの値を‘kill-ring’に保存し、現在のセ
     クションがコミットまたはブランチまたはタグセクションである場合、(参
     照される)リビジョンを‘magit-revision-stack’にプッシュします。

     現在のセクションがブランチまたはタグであり、プレフィックス引数が使
     用されている場合、その先端(tip)のリビジョンは、参照名の代わりに
     ‘kill-ring’に保存されます。

     リージョンがアクティブな場合、このコマンドは、上記のように動作する
     代わりに、‘kill-ring-save’のように‘kill-ring’にそれを保存します。プ
     レフィックス引数が使用され、領域がハンク内にある場合、プレフィック
     ス引数の符号に応じて、diffマーカー列が削除され、追加または削除され
     た行のみが保持されます。

‘M-w’ (‘magit-copy-buffer-revision’)
     このコマンドは、現在のバッファに表示されているリビジョンを
     ‘kill-ring’に保存し、‘magit-revision-stack’にもプッシュします。これ
     は主に‘magit-revision-mode’バッファでの使用を目的としています。これ
     は、どのリビジョンを保存する必要があるかが常に明確である唯一のバッ
     ファです。

     他のほとんどのMagitバッファは通常、何らかの方法で複数のリビジョンを
     表示するため、このコマンドはそれらの1つを選択する必要があり、その選
     択が常に最良の選択であるとは限りません。

Magitの外部では、‘M-w’と‘C-w’は通常‘kill-ring-save’と‘kill-region’にバイ
ンドされており、これらのコマンドはMagitバッファでも役立ちます。したがっ
て、リージョンがアクティブな場合、これらのコマンドは両方とも、上記のよう
にではなく、‘kill-ring-save’のように動作します。


File: magit.ja.info,  Node: Wip Modes,  Next: Commands for Buffers Visiting Files,  Prev: Common Commands,  Up: Miscellaneous

8.9 Wip Modes
=============

Gitは、ユーザーが誤って削除した変更を復元するのに十分な時間、*コミットさ
れた変更*を保持します。これは、コミットされたが参照されなくなったオブジ
ェクトを一定期間(デフォルトでは30日間)ガベージコレクションしないことによ
って行われます。

ただし、Gitは、作業ツリーのコミットされていない変更を追跡せず、インデッ
クス(ステージ領域)も追跡しません。Magitを使用すると、コミットされていな
い変更を簡単に変更できるため、その過程で自分の足を簡単に撃つことができま
す(訳注:墓穴を掘るぐらいの意味)。

そのため、Magitは、特定のアクションの後または前に、追跡ファイル(tracked
files)を進行中のreferenceに保存するグローバルモードを提供します。(現在の
ところ、追跡されていないファイルは保存されず、技術的な理由から、最初のコ
ミットが作成されるまでは何も保存されません)。

インデックスと作業ツリーの状態を追跡するために、2つの別々の進行中の
refernceが使用されます。それは‘refs/wip/index/<branchref>’と
‘refs/wip/wtree/<branchref>’です。ここで‘<branchref>’は現在のブランチの
完全なrefで、例えば‘refs/heads/master’です。‘HEAD’がデタッチされると、
‘<branchref>’の替わりに‘HEAD’が使用されます。

別のブランチをチェックアウトする(または‘HEAD’をデタッチする)と、その後の
変更では異なるwip refsが使用されます。

 -- User Option: magit-wip-mode
     このモードが有効になっている場合、コミットされていない変更は、必要
     に応じて(つまり、データ損失が発生する可能性がある場合)、専用の進行
     中のrefsにコミットされます。

     この変数を直接設定しても効果はありません。カスタムインターフェイス
     を使用してこれを行うか、それぞれのモード関数を呼び出します。

     歴史的な理由から、このモードは他の4つの‘magit-wip-*’モードの上に実
     装されています。あなたが wip refsが更新されるタイミングをより細かく
     制御したい場合は、これらのモードを個別に使用することもできます。し
     かし、それはお勧めしません。こちらを参照して下さい(*note Legacy Wip
     Modes::)。

ブランチとそのwip refsのログを表示するには、コマンド‘magit-wip-log’と
‘magit-wip-log-current’を使用します。これらのコマンドを使用するときは、
‘--graph’を使用する必要があります。

 -- Command: magit-wip-log
     このコマンドは、ブランチとそのwip refsのログを表示します。負のプレ
     フィックス引数を使用すると、worktree wip refs のみが表示されます。

     プレフィックス引数の絶対値は、表示される各wip refsの「ブランチ」の
     数を制御します。これは、‘magit-wip-merge-branch’の値が‘nil’の場合に
     のみ関係します。

 -- Command: magit-wip-log-current
     このコマンドは、現在のブランチとそのwip refs のログを表示します。負
     のプレフィックス引数を使用すると、worktree wip refs のみが表示され
     ます。

     プレフィックス引数の絶対値は、表示される各wip refsの「ブランチ」の
     数を制御します。これは、‘magit-wip-merge-branch’の値が‘nil’の場合に
     のみ関係します。

‘X w’ (‘magit-reset-worktree’)
     このコマンドは、‘HEAD’とインデックスをそのままにして、作業ツリーを
     ユーザーから読み取られたコミットにリセットし、デフォルトでそのポイ
     ントのコミットにリセットします。

     これを使用して、ファイルをwip ref にコミットされた状態に復元できま
     す。これにより、このコマンドを呼び出す前に存在していた可能性のある
     ステージされていない変更(unstaged changes)がすべて破棄されることに
     注意してください(ただし、もちろん、作業ツリー wip refにコミットした
     後でのみ)。

注意: ‘magit-wip-mode’を有効にしても、完全な保護にはならないことに注意し
てください。‘magit-wip-mode’を使用しているにもかかわらず変更が失われる可
能性が最も高いシナリオは、Emacsの外部で変更を加えてから、Emacsの外部でそ
れを破棄することです。そのようなシナリオのいくつかでは、Emacsパッケージ
であるMagitには、あなたが自分の足を撃つのを防ぐチャンスがありません。

Magitがwip refsに変更をコミットしたかどうかわからない場合は、追跡された
すべてのファイルへのすべての変更がコミットされるように明示的に要求できま
す。

‘M-x magit-wip-commit’
     このコマンドは、追跡されたすべてのファイルに対するすべての変更を、
     インデックスおよび作業ツリーの進行中のrefsにコミットします。上記の
     モードと同様に、追跡されていないファイルはコミットされませんが、追
     跡されているすべてのファイルの変更がチェックされます。モードが
     Emacs/Magitの外部で行われた変更を見落としている可能性があると思われ
     る場合は、このコマンドを使用します。

 -- User Option: magit-wip-namespace
     進行中の作業のrefsに使用される名前空間。スラッシュで終了する必要が
     あります。wip refsの名前は‘<namespace>index/<branchref>’や
     ‘<namespace>wtree/<branchref>’です。‘HEAD’がデタッチされているとき
     にスナップショットが作成されると、‘<branchref>’の代わりに‘HEAD’が使
     用されます。

 -- User Option: magit-wip-mode-lighter
     ‘magit-wip--mode’のモードラインライター(lighter)。

* Menu:

* Wip Graph::                Wip Graph
* Legacy Wip Modes::         Legacy Wip Modes


File: magit.ja.info,  Node: Wip Graph,  Next: Legacy Wip Modes,  Up: Wip Modes

8.9.1 Wip Graph
---------------

 -- User Option: magit-wip-merge-branch
     このオプションは、ブランチで新しいコミットが作成された後に、現在の
     ブランチを wip refs にマージするかどうかを制御します。

     nil以外でかつ現在のブランチに新しいコミットがある場合、新しいwipコ
     ミットを作成する前に、それがwip refにマージされます。これにより、
     wip履歴の検査が容易になり、wipコミットがガベージコレクションされる
     ことはありません。

     nilでかつ現在のブランチに新しいコミットがある場合、新しいwipコミッ
     トを作成する前に、wip refがブランチの先端(tip)にリセットされます。
     この設定では、wipコミットは最終的にガベージコレクションされます。

‘magit-wip-merge-branch’が‘t’の場合、履歴は以下のようになります:

       *--*--*--*--*--*       refs/wip/index/refs/heads/master
      /     /     /
     A-----B-----C            refs/heads/master

‘magit-wip-merge-branch’が‘nil’の場合、実際のブランチでコミットを作成し
てから変更を加えると、wip refが再作成され、新しいコミットからフォークさ
れます。ただし、wip refs の古いコミットは失われません。それらはまだ
reflogから入手できます。wip refsのフォーク点がいつ変更されたかを簡単に確
認できるように、"restart autosaving"(自動保存の再開)というメッセージを含
む追加のコミットが作成されます(以下の‘xxO’コミットはそのような境界コミッ
トです)。

開始時は

           BI0---BI1    refs/wip/index/refs/heads/master
          /
     A---B              refs/heads/master
          \
           BW0---BW1    refs/wip/wtree/refs/heads/master

で、ステージされた変更(staged changes)をコミットし、ファイルを編集して保
存すると、以下のようになります。

           BI0---BI1        refs/wip/index/refs/heads/master
          /
     A---B---C              refs/heads/master
          \   \
           \   CW0---CW1    refs/wip/wtree/refs/heads/master
            \
             BW0---BW1      refs/wip/wtree/refs/heads/master@{2}

インデックスwip refのフォーク点は、何らかの変更が行われるまで変更されま
せん。同様に、ブランチをチェックアウトしたり、コミットを作成したりしても
、作業ツリーwip refのフォーク点は変更されません。フォーク点は、それぞれ
のwip refにコミットする必要のある変更が実際に行われるまで調整されません
。


File: magit.ja.info,  Node: Legacy Wip Modes,  Prev: Wip Graph,  Up: Wip Modes

8.9.2 Legacy Wip Modes
----------------------

‘magit-wip-mode’モード(を参照)を使用してください。以下のモードは歴史的な
事情で残されています。無視することをお勧めします。

以下の変数達を直接設定しても効果はありません。カスタムインターフェイスを
使用してこれを行うか、それぞれのモード関数を呼び出します。

 -- User Option: magit-wip-after-save-mode
     このモードが有効になっている場合、Gitリポジトリで追跡されているファ
     イルを訪問するバッファを保存すると、現在の状態が現在のブランチの作
     業ツリー wip refにコミットされます。

 -- User Option: magit-wip-after-apply-mode
     このモードを有効にすると、Gitリポジトリで追跡されているファイルに変
     更を適用(つまり、ステージ、ステージ解除、discard、revert、regulary
     apply)すると、現在の状態が現在のブランチのインデックスや作業ツリー
     のwip refsにコミットされます。

Emacsを使用してファイルを編集し、Magitを使用してGitと対話するだけの場合
は、上記の2つのモードで、すべての変更を偶発的な損失から保護するのに十分
なはずです。しかし、実際はそうではありません。以前の変更が失われる可能性
のある変更を行う前に、wip refsにコミットする2つの追加モードが存在します
。

 -- User Option: magit-wip-before-change-mode
     このモードを有効にすると、特定のコマンドで、あなたが変更しようとし
     ているファイルに既に存在する変更をコミットします。

 -- User Option: magit-wip-initial-backup-mode
     このモードを有効にすると、ファイルを訪問するバッファが作成されてか
     ら初めて保存される前に、ファイルの現在のバージョンがworktree wip
     refにコミットされます。

     これにより、‘backup-buffer’が保存するのと同じバージョンのファイルが
     バックアップされます。‘backup-buffer’はバックアップファイルを使用し
     ますが、このモードは他のMagit Wipモードで使用されるものと同じ
     worktree wip refを使用します。‘backup-buffer’と同様に、これは1回だ
     け実行されます。バッファを強制終了してファイルに再度訪問しない限り
     、Emacsセッションごとに1つのバックアップのみが作成されます。

     このモードは、‘backup-buffer’に影響を与える変数を無視し、その関数と
     一緒に使用できます。これは、Gitリポジトリで追跡されるファイルのみを
     バックアップするため推奨されます。

 -- User Option: magit-wip-after-save-local-mode-lighter
     ‘magit-wip-after-save-local-mode’のモードラインライター(lighter)。

 -- User Option: magit-wip-after-apply-mode-lighter
     ‘magit-wip-after-apply-mode’のモードラインライター(lighter)

 -- User Option: magit-wip-before-change-mode-lighter
     ‘magit-wip-before-change-mode’のモードラインライター(lighter)

 -- User Option: magit-wip-initial-backup-mode-lighter
     ‘magit-wip-initial-backup-mode’のモードラインライター(lighter)


File: magit.ja.info,  Node: Commands for Buffers Visiting Files,  Next: Minor Mode for Buffers Visiting Blobs,  Prev: Wip Modes,  Up: Miscellaneous

8.10 Commands for Buffers Visiting Files
========================================

ユーザーが‘magit-define-global-key-bindings’を‘nil’に設定しない限り、
Magitはいくつかのグローバルキーバインディングを定義します。これには、
‘C-c M-g’の‘magit-file-dispatch’への結び付けが含まれます。‘C-c g’の方が
はるかに優れたバインディングですが、‘C-c <letter>’名前空間はユーザー用に
予約されているため、パッケージでの使用は許可されていません。‘C-c g’を使
用する場合は、そのバインディングを自分で追加する必要があります。こちらも
参照下さい(*note Default Bindings::)と(*note (elisp)Key Binding
Conventions::)

あなたがより良いバインディングを欲する場合、あなた自身で追加する必要があ
ります:

     (global-set-key (kbd "C-c g") 'magit-file-dispatch)

以下に示すキーバインディングは、‘magit-file-dispatch’のバインディングを
改善していないことを前提としています。

‘C-c M-g’ (‘magit-file-dispatch’)
     このトランジェント(一時的)プレフィックス(接頭辞)コマンドは、それに
     従うサフィックス(接尾辞)コマンド群を結びつけ、そのサフィックスコマ
     ンドのどれかを選ぶまでの間、サフィックス(接尾辞)コマンド群を一時バ
     ッファ(temporary buffer)に表示します。

     ファイルに訪問しないバッファで呼び出されると、通常の
     ‘magit-dispatch’にフォールバックします。

‘C-c M-g s’ (‘magit-stage-file’)
     現在のバッファが訪問しているファイルのすべての変更をステージします
     。

‘C-c M-g u’ (‘magit-unstage-file’)
     現在のバッファが訪問しているファイルのすべての変更をステージ解除し
     ます。

‘C-c M-g c’ (‘magit-commit’)
     このトランジェントプレフィックスコマンドは、それに従うサフィックス
     コマンドと適切なインフィックス引数とともに結び付け、サフィックスコ
     マンドを選ぶまでの間、そのサフィックスコマンドと適切なインフィック
     ス引数を一時バッファに表示します(*note コミット開始::)。

‘C-c M-g D’ (‘magit-diff’)
     このトランジェントプレフィックスコマンドは、いくつかのdiffサフィッ
     クスコマンドとインフィックス引数を結び付けし、サフィックスコマンド
     が呼び出されるまでそれらを一時バッファに表示します。参照(*note
     Diffing::)

     これは、‘d’がMagitバッファで結び付けられているのと同じコマンドです
     。このコマンドがfile-visitingバッファから呼び出された場合、diffを特
     定のファイルに制限するオプション(‘--’)の初期値が訪問したファイルに
     設定されます。

‘C-c M-g d’ (‘magit-diff-buffer-file’)
     このコマンドは、現在のバッファが訪れるblobのファイルのdiffを表示し
     ます。

 -- User Option: magit-diff-buffer-file-locked
     このオプションは、‘magit-diff-buffer-file’が専用のバッファを使用す
     るかどうかを制御します。こちらを参照して下さい(*note Modes and
     Buffers::)。

‘C-c M-g L’ (‘magit-log’)
     このトランジェントプレフィックスコマンドは、いくつかのログ用サフィ
     ックスコマンドとインフィックス引数を結び付け、サフィックスコマンド
     が呼び出されるまでそれらを一時バッファに表示します。参照(*note
     Logging::)。

     これは、‘l’がMagitバッファで結び付けられているのと同じコマンドです
     。このコマンドがfile-visitingバッファから呼び出された場合、ログを特
     定のファイルに制限するオプション(‘--’)の初期値が訪問したファイルに
     設定されます。

‘C-c M-g l’ (‘magit-log-buffer-file’)
     このコマンドは、現在のバッファが訪問するblobのファイルのログを表示
     します。プレフィックス引数が使用されている場合、または‘--follow’が
     アクティブなログ引数である場合は、名前が変更されます。リージョンが
     アクティブな場合、ログは選択した行範囲に制限されます。

‘C-c M-g t’ (‘magit-log-trace-definition’)
     このコマンドは、ポイントでの定義のログを表示します。

 -- User Option: magit-log-buffer-file-locked
     このオプションは、‘magit-log-buffer-file’が専用のバッファを使用する
     かどうかを制御します。参照(*note Modes and Buffers::)。

‘C-c M-g B’ (‘magit-blame’)
     このトランジェントプレフィックスコマンドは、すべてのblameサフィック
     スコマンドを適切なインフィックス引数とともに結び付け、サフィックス
     コマンドが呼び出されるまで一時バッファに表示します。

     このコマンドと以下のコマンドの詳細については、こちらを参照(*note
     Blaming::)。

‘magit-blame’サブトランジェントコマンドに加えて、ディスパッチトランジェ
ントコマンドはいくつかのblameサフィックスコマンドを直接結び付けます。こ
れらのコマンドとバインディングについては、こちらを参照して下さい(*note
Blaming::)。

‘C-c M-g e’ (‘magit-edit-line-commit’)
     このコマンドは、現在の行を追加したコミットを編集可能にします。

     プレフィックス引数を使用すると、コミットが編集可能になり、行がある
     場合は削除されます。コミットは‘git blame’を使用して決定され、
     ‘HEAD’から到達可能である場合は、‘git rebase --interactive’を使用し
     て編集可能にするか、そうでない場合はコミット(またはそれを指すブラン
     チ)をチェックアウトします。

‘C-c M-g p’ (‘magit-blob-previous’)
     変更した現在のファイルの以前のBLOBを訪問します。

単一のファイルで動作するが、デフォルトではファイルトランジェントコマンド
で有効になっていない追加のコマンドがいくつかあります:

 -- Command: magit-file-rename
     このコマンドは、ユーザーから読み取ってファイルの名前を変更します。

 -- Command: magit-file-delete
     このコマンドは、ユーザーから読み取ってファイルを削除します。

 -- Command: magit-file-untrack
     このコマンドは、ユーザーから読み取られたファイルの追跡を解除
     (untrack)します。

 -- Command: magit-file-checkout
     このコマンドは、作業ツリー内のファイルを更新し、リビジョンの内容に
     インデックスを付けます。リビジョンとファイルの両方がユーザーから読
     み取られます。

それらを有効にするには、トランジェントコマンド(‘C-c M-g’)を呼び出し、「
編集モード」(‘C-x l’)に入り、「トランジェントレベル」(再び‘C-x l’)を設定
し、‘5’を入力し、編集モードを終了します(‘C-g’)。こちらも参照下さい(*note
(transient)Enabling and Disabling Suffixes::)。


File: magit.ja.info,  Node: Minor Mode for Buffers Visiting Blobs,  Prev: Commands for Buffers Visiting Files,  Up: Miscellaneous

8.11 Minor Mode for Buffers Visiting Blobs
==========================================

‘magit-blob-mode’は、blob訪問バッファで特定のMagit機能を有効にします。こ
のようなバッファは、‘magit-find-file’と以下で説明するいくつかのコマンド
を使用して作成できます。これらのコマンドは、このマイナーモードの開始も処
理します。現在、このモードはいくつかのキーバインディングのみを確立します
が、これは拡張される可能性があります。

‘p’ (‘magit-blob-previous’)
     変更した現在のファイルの以前のBLOBを訪問します。

‘n’ (‘magit-blob-next’)
     変更した現在のファイルの次のBLOBを訪問します。

‘q’ (‘magit-kill-this-buffer’)
     現在のバッファを強制終了します。


File: magit.ja.info,  Node: Customizing,  Next: 配管コマンド(Plumbing),  Prev: Miscellaneous,  Up: Top

9 Customizing
*************

GitとEmacsはどちらも高度にカスタマイズ可能です。MagitはGit磁器であると同
時にEmacsパッケージでもあるため、Git変数とEmacsオプションの両方を使用し
てカスタマイズすることは理にかなっています。ただし、この柔軟性には、以下
のような問題もあります。

   • 一部のGit変数は、明示的なサポートを必要とせずに、Magitで自動的に効
     果を発揮します。それが望ましい場合もあれば、一方でMagitを壊す場合も
     あります。

     特定のGit設定がMagitを壊したが、コマンドラインでその設定を使い続け
     たい場合は、‘magit-git-global-arguments’に‘("-c"
     "some.variable=compatible-value")’のようなものを追加してMagitの値を
     オーバーライドすることで実現できます。

   • ‘fetch.prune=true’のような特定の設定は、(単にそれぞれのGitコマンド
     を呼び出すため)Magitコマンドによって尊重されますが、それらの値はそ
     れぞれの一時バッファに反映されません。この場合、‘magit-fetch’の
     ‘--prune’引数はアクティブまたは非アクティブである可能性がありますが
     、それでもGit変数がサフィックスコマンドによって尊重されることを妨げ
     ません。したがって、‘--prune’引数が、pruningが発生しないことを示し
     ているように見える方法で表示されているにもかかわらず、pruningが発生
     する可能性があります。

今後のリリースで、これらの問題や同様の問題に対処する予定です。

* Menu:

* Per-Repository Configuration::  Per-Repository Configuration
* 基本設定::             基本設定


File: magit.ja.info,  Node: Per-Repository Configuration,  Next: 基本設定,  Up: Customizing

9.1 Per-Repository Configuration
================================

Magitは、Git変数とEmacsオプションの両方を使用して、リポジトリごとの設定
を行う事ができます。

あるリポジトリのみのGit変数を設定するには、‘$HOME/.gitconfig’や
‘/etc/gitconfig’の代わりに‘/path/to/repo/.git/config’に設定するだけです
。参照: (*note (gitman)git-config::)

同様に、Emacsオプションは、‘/path/to/repo/.dir-locals.el’を編集すること
によってあるリポジトリのみに設定できます。こちらを参照して下さい(*note
(emacs)Directory Variables::)。たとえば、1つの巨大なリポジトリで
file-visitingバッファの自動リフレッシュを無効にするには、以下を使用しま
す:

   • ‘/path/to/huge/repo/.dir-locals.el’

          ((nil . ((magit-refresh-buffers . nil))))

非常に大きなリポジトリのMagitバッファに特定の情報を挿入するのはコストが
かかるかもしれません。その場合、そのようなリポジトリに対してのみそれぞれ
のセクションインサーターを無効にすることができます:

   • ‘/path/to/tag/invested/repo/.dir-locals.el’

          ((magit-status-mode
            . ((eval . (magit-disable-section-inserter 'magit-insert-tags-header)))))

 -- Function: magit-disable-section-inserter fn
     この関数は、現在のリポジトリのセクションインサーターFNを無効にしま
     す。‘.dir-locals.el’と‘.dir-locals-2.el’のみでの使用を目的としてい
     ます。

すべてではありませんが複数のリポジトリに同じ設定を適用したい場合は、リポ
ジトリローカル構成ファイルの同期を維持するのはすぐに面倒になります。これ
を回避するには、特定のクラスのリポジトリ(「巨大なリポジトリ」など)の構成
ファイルを作成してから、それらのファイルをリポジトリごとの構成ファイルに
含めることができます。 例えば:

   • ‘/path/to/huge/repo/.git/config’

          [include]
                  path = /path/to/huge-gitconfig

   • ‘/path/to/huge-gitconfig’

          [status]
                  showUntrackedFiles = no

   • ‘$HOME/.emacs.d/init.el’

          (dir-locals-set-class-variables 'huge-git-repository
             '((nil . ((magit-refresh-buffers . nil)))))

          (dir-locals-set-directory-class
             "/path/to/huge/repo/" 'huge-git-repository)


File: magit.ja.info,  Node: 基本設定,  Prev: Per-Repository Configuration,  Up: Customizing

9.2 基本設定
============

次の2つの節は、安全性やパフォーマンス上の理由から、多くのユーザーがカス
タマイズする可能性のあるいくつかの変数について説明します。

* Menu:

* Safety::                   Safety
* Performance::              Performance
* Default Bindings::         Default Bindings


File: magit.ja.info,  Node: Safety,  Next: Performance,  Up: 基本設定

9.2.1 Safety
------------

この節では、安全上の理由から変更する(または変更しない)可能性のあるさまざ
まな変数について説明します。

Gitは、ユーザーが誤って削除した変更を復元するのに十分な時間、コミットし
た変更を保持します。作業ツリーのコミットされていない変更に対しては同じこ
とを行わず、インデックス(ステージ領域)に対しても同じことを行いません。
Magitを使用すると、コミットされていない変更を簡単に変更できるため、その
過程で自分の足を簡単に撃つことができます。そのため、Magitは、特定のアク
ションの前後に追跡されているファイルを進行中のreferenceに保存する3つのグ
ローバルモードを提供します。こちらを参照して下さい(*note Wip Modes::)。

これらのモードは、パフォーマンス上の懸念から、デフォルトでは有効になって
いません。 代わりに、破壊的な可能性のあるコマンドの多くは、使用するたび
に確認が必要です。多くの場合、これは‘magit-no-confirm’にシンボルを追加す
ることで無効にできます(*note 補完と確認::)。 さまざまなwipモードを有効に
する場合は、このリストに‘safe-with-wip’を追加する必要があります。

同様に、ファイルをシステムのゴミ箱に移動する前に確認を要求する必要はあり
ません。誤ってファイルをゴミ箱に移動した場合は、そこから回復できます。オ
プション‘magit-delete-by-moving-to-trash’は、システムのゴミ箱を使用する
かどうかを制御します。これはデフォルトの場合です。 それでも、‘trash’は
‘magit-no-confirm’のメンバーではありません。あなたはこれを変更したいと思
うかもしれません。

デフォルトでは、訪問したファイルがディスク上で変更されると、訪問したファ
イルは自動的revertされます。 これは見た目ほど危険ではありませんが、十分
な情報に基づいて決定を下すには確認が必要です。こちらを参照して下さい
(*note Risk of Reverting Automatically::)


File: magit.ja.info,  Node: Performance,  Next: Default Bindings,  Prev: Safety,  Up: 基本設定

9.2.2 Performance
-----------------

Magitは副作用のために‘git’を実行した後、現在のMagitバッファとそれぞれの
ステータスバッファもリフレッシュします。これが必要なのは、そうしないと、
ユーザーが気付かないうちに古い情報が表示される可能性があるためです。
Magitバッファは、コンテンツを最初から再作成することで更新されます。これ
により、更新が簡単になり、エラーが発生しにくくなりますが、コストも高くな
ります。シンプルに保ち、すべてを最初から再作成することは古い設計上の決定
であり、それから逸脱するには大規模なリファクタリングが必要になります。

次のメジャーリリースに間に合うようにそれを行う予定です。また、ログと
diffを非同期で作成する予定です。これも大いに役立つはずですが、大幅なリフ
ァクタリングも必要です。

一方、Magitに、現在のMagitバッファのみを自動的にリフレッシュするように指
示できますが、ステータスバッファはリフレッシュできません。 これを行うと
、ステータスバッファは、現在のバッファである場合にのみ自動的にリフレッシ
ュされます。

     (setq magit-refresh-status-buffer nil)

また、サードパーティのパッケージが‘magit-refresh-buffer-hook’と
‘magit-status-refresh-hook’と‘magit-pre-refresh-hook’と
‘magit-post-refresh-hook’に何かを追加していないかどうかを確認する必要が
あります。その場合は、それらの追加がパフォーマンスに大きな影響を与えるか
どうかを確認してください。

Magitは、‘M-x magit-toggle-verbose-refresh’を使用して詳細にバッファをリ
フレッシュするように指示できます。これを有効にすると、どのセクションがボ
トルネックであるかを把握するのに役立ちます。追加の出力は、‘*Messages*’バ
ッファにあります。

Magitは、訪問したファイルがディスク上で変更されると、現在のリポジトリ内
にある訪問したファイルのバッファもrevertします。これは、組み込みライブラ
リ‘autorevert’の‘auto-revert-mode’の上に実装されています。それがパフォー
マンスに影響を与えるかどうかを判断するには、多数のバッファが存在する場合
、および/または一部のバッファがTRAMPを使用してファイルを訪問する場合に、
パフォーマンスが大幅に低下するかどうかを確認します。 もしパフォーマンス
に影響があるなら、この確認が役に立つはずです。

     (setq auto-revert-buffer-list-filter
           'magit-auto-revert-repository-buffer-p)

別のアプローチについては、こちらを参照(*note Automatic Reverting of
File-Visiting Buffers::)

あなたがデフォルトで無効になっている機能を有効にしている場合は、それらが
パフォーマンスに大きな影響を与えるかどうかを確認する必要があります。少な
くとも大規模なリポジトリではパフォーマンスが低下することがわかっているた
め、それらはデフォルトでは有効になっていない可能性があります。

特定の異常に大きなリポジトリ内でのみパフォーマンスが低下する場合は、リポ
ジトリごとまたはリポジトリクラスごとにのみ特定の機能を無効にすることをお
勧めします。こちらを参照して下さい(*note Per-Repository
Configuration::)。たとえば、非常に多くのタグがあるリポジトリ内の次の現在
のタグを判別するのに長い時間がかかります。したがって、前節で説明されてい
るように、‘magit-insert-tags-headers’を無効にすることをお勧めします。

* Menu:

* Microsoft Windows Performance::  Microsoft Windows Performance
* MacOS Performance::        MacOS Performance

Log Performance
...............

ログを表示するとき、Magitは、不要な作業を回避することを期待して、最初に
表示されるコミットの数を制限します。‘--graph’を使用する場合は、残念なが
ら、これは大きな履歴に対して望ましい効果をもたらしません。Gitのメンテナ
であるJunioは、gitメーリングリスト
(<http://www.spinics.net/lists/git/msg232230.html>)で次のように述べてい
ます。「‘--graph’は履歴全体を計算したいと考えているので、max-countは、
‘--graph’が計算を行った後の出力フェーズにのみ影響します。」

言い換えれば、Gitが差分を出力するのが遅いということでも、Magitが出力を解
析するのが遅いということでもありません。問題は、Gitが如何に早く狼煙を上
げるかです。

実際には、‘-<N>’を使用するだけでなく、範囲を使用してコミットの数を制限す
ることで、この問題を回避しています。しかし残念ながら、それが常に可能であ
るとは限りません。

数千を超えるコミットが表示される場合、‘--graph’を使用すると処理速度が低
下する可能性があります。

‘--color --graph’の使用はさらに遅くなります。 Magitは、Emacsの一部である
コードを使用して、制御文字をfaceに変換します。そのコードはかなり遅く、こ
れは多くのブランチとマージを含むログを表示するときに非常に目立ちます。そ
のため、‘--color’はデフォルトで有効ではなくなりました。そのままにしてお
くことを検討してください。

Diff Performance
................

diffが遅い場合は、次の変数のすべてまたは一部を‘nil’に設定して、オプショ
ンのdiff機能をオフにすることを検討してください:
‘magit-diff-highlight-indentation’、‘magit-diff-highlight-trailing’、
‘magit-diff-paint-whitespace’、‘magit-diff-highlight-hunk-body’、
‘magit-diff-refine-hunk’.

任意のdiffの代わりにコミットを表示すると、いくつかの追加情報が表示されま
す。この情報の計算は、特定の状況を考えると非常にコストがかかる可能性があ
ります。‘magit-revision-mode’を使用してコミットを確認する方が、
‘magit-diff-mode’で同じコミットを確認するよりもかなり時間がかかる場合は
、‘magit-revision-insert-related-refs’を‘nil’に設定することを検討してく
ださい。

あなたが削除されたファイルを含むdiffに頻繁に直面する場合は、
‘--irreversible-delete’引数を有効にすることをお勧めします。これを行うと
、diffはファイルが削除されたことを示しはしますが、ファイルの完全に削除さ
れた内容の表示は行いません。この引数はデフォルトでは使用できません。こち
らを参照して下さい(*note (transient)Enabling and Disabling Suffixes::)。
それが完了したら、それを有効にしてその設定を保存する必要があります。こち
らを参照して下さい(*note (transient)Saving Values::)。これは、
diff(‘d’)とdiff refresh(‘D’)の両方のトランジェントポップアップで行う必要
があります。

Refs Buffer Performance
.......................

"references buffer"のリフレッシュが遅い場合、それは通常、数百のrefsが表
示されているためです。これに対処する最善の方法は、明らかに、表示する
ref数を減らすことです。

あなたがタグのリストを表示することに興味がない、または興味がほとんど無い
場合は、タグを表示しないことから始めます。

     (remove-hook 'magit-refs-sections-hook 'magit-insert-tags)

それから、あなたはリストされているリモートブランチが実際にすべて存在する
ことも確認する必要があります。これを行うには、‘f-pa’を使用して存在しなく
なったブランチをpruningします。

Committing Performance
......................

あなたがコミットを開始すると、Magitはデフォルトで、コミットしようとして
いる変更のdiffを自動的に表示します。大規模なコミットの場合、これには長い
時間がかかる可能性があります。これは、コミットする前に実際に検査する予定
のない大量の生成データをコミットする場合に特に気が散ります。この動作は、
以下を使用してオフにできます:

     (remove-hook 'server-switch-hook 'magit-commit-diff)

それからあなたは、‘C-c C-d’と入力して、実際に見たいときにdiffを表示でき
ますが、それはそのときだけです。またはフックはそのままにしておいて、
diffの生成に時間がかかりすぎる場合に、‘C-g’と入力することもできます。こ
れを行うと、diffバッファが壊れてしまいますが、この方法で行うと、通常は
diffを確認できるという利点があります。これは、潜在的な問題を見つける可能
性が高くなるため便利です。


File: magit.ja.info,  Node: Microsoft Windows Performance,  Next: MacOS Performance,  Up: Performance

Microsoft Windows Performance
.............................

ステータスバッファを更新するには、‘git’を数十回実行する必要があります。
これはMicrosoft Windowsでは問題があります。なぜならこのオペレーティング
システムはプロセスの開始が非常に遅いためです。残念ながら、これは
Microsoft自身によってのみ修正できる問題であり、彼らはそうすることに特に
関心を持っていないようです。

サブプロセスの問題の他に、Windows固有のパフォーマンスの問題もあります。
これらのいくつかには回避策があります。"Git for Windows"のメンテナは、
Windowsのパフォーマンスを向上させようとしています。最新のパフォーマンス
調整を利用するには、常に最新のリリースを使用してください。 Magitも、
Windows固有の問題を回避しようとします。

一部の情報源によると、以下のGit変数を設定することも役立ちます。

     git config --global core.preloadindex true   # default since v2.1
     git config --global core.fscache true        # default since v2.8
     git config --global gc.auto 256

また、あなたはアンチウイルスプログラムがパフォーマンスに影響を与えている
かどうかを確認すべきです。


File: magit.ja.info,  Node: MacOS Performance,  Prev: Microsoft Windows Performance,  Up: Performance

MacOS Performance
.................

Emacs 26.1より前は、macOSでは‘fork’を使用して子プロセスが作成されていま
した。それは不必要にGUIリソースをコピーし、高コストです。その結果、
DarwinではLinuxよりもフォークに約30倍の時間がかかり、Magitは多くの
‘git’プロセスを開始するため、かなりの違いが生じました。

したがって、あなたは少なくともEmacs 26.1を使用していることを確認してくだ
さい。その場合、より高速な‘vfork’が使用されます。(子プロセスの作成には、
Linuxと比較してDarwinではまだ約2倍の時間がかかります。) (1)

   ---------- Footnotes ----------

   (1) 詳細についてはこちらを参照してください
<https://lists.gnu.org/archive/html/bug-gnu-emacs/2017-04/msg00201.html>


File: magit.ja.info,  Node: Default Bindings,  Prev: Performance,  Up: 基本設定

9.2.3 Default Bindings
----------------------

 -- User Option: magit-define-global-key-bindings
     このオプションは、Magitが現在のセッションで初めて使用される前であっ
     ても、一部のMagitコマンドがグローバルキーマップに自動的にバインドさ
     れるかどうかを制御します。

     この変数がデフォルト以外である、nilでない場合、以下のバインディング
     がグローバルキーマップに追加される可能性があります。

     ‘C-x g’     ‘magit-status’
     ‘C-x M-g’   ‘magit-dispatch’
     ‘C-c M-g’   ‘magit-file-dispatch’

     これらのバインディングは、‘after-init-hook’の実行時に追加される場合
     があります。各バインディングは、その時点で他のキーが同じコマンドに
     バインドされておらず、他のコマンドが同じキーにバインドされていない
     場合にのみ追加されます。つまり、不要なバインディングや、他のバイン
     ディングと競合するバインディングの追加は避けようとしています。

     上記のバインディングの追加は、‘after-init-hook’が呼び出されて、ユー
     ザーがinitファイルの任意の場所に変数を設定できるようになるまで遅延
     されます(‘magit’がロードまたは自動ロードされる前に必ず設定する必要
     はありません)。競合する可能性のあるすべてのユーザーバインディングが
     すでに追加されている可能性を高めるためです。

     この変数を設定するには、‘setq’またはカスタムインターフェイスのいず
     れかを使用します。関数‘customize-set-variable’を使用しないでくださ
     い。使用すると、フォームが評価されるとすぐにMagitが読み込まれます
     (これは、カスタマイズされた変数を定義するライブラリを読み込まない
     ‘custom-set-variables’とは異なります)。

     この変数をnilに設定しても、キーバインディングがすでに追加された後に
     設定しては効果はありません。

     ‘C-c M-g’ではなく‘C-c g’を‘magit-file-dispatch’にバインドすることを
     お勧めします。‘C-c g’の方がはるかに優れたバインディングですが、‘C-c
     <letter>’名前空間はユーザー専用に厳密に予約されています。Magitがデ
     フォルトでそれを使用するのを妨げます。

          (global-set-key (kbd "C-c g") 'magit-file-dispatch)

     こちらも参照下さい(*note Commands for Buffers Visiting Files::)と
     (*note (elisp)Key Binding Conventions::)


File: magit.ja.info,  Node: 配管コマンド(Plumbing),  Next: FAQ,  Prev: Customizing,  Up: Top

10 配管コマンド(Plumbing)
*************************

以下の節では、Magitのコア部分の抽象化のいくつかを使用して、Magit自体を拡
張する方法、または個別の拡張を実装する方法について説明します。

Magitで使用される低レベルの機能のいくつかは、個別の ライブラリ/パッケー
ジ に分解されているため、Magitに依存することなく他のパッケージで使用でき
ます。‘with-editor’についてはこちらを参照して下さい(*note
(with-editor)Top::)。 ‘transient’についてはこちらを参照して下さい(*note
(transient)Top::)。

独自のMagit拡張機能によって提供されるコマンドにバインドできる未使用のキ
ーを見つけようとしている場合は、
<https://github.com/magit/magit/wiki/Plugin-Dispatch-Key-Registry>をチェ
ックアウトしてください。

* Menu:

* Calling Git::              Calling Git
* Section Plumbing::         Section Plumbing
* Refreshing Buffers::       Refreshing Buffers
* 慣習::                   慣習


File: magit.ja.info,  Node: Calling Git,  Next: Section Plumbing,  Up: 配管コマンド(Plumbing)

10.1 Calling Git
================

Magitは、Gitを呼び出すための多くの特殊な関数を提供します。これらの関数は
すべて、‘magit-git.el’または‘magit-process.el’のいずれかで定義され、接頭
辞‘magit-run-’または‘magit-call-’または‘magit-start-’または
‘magit-git-’のいずれかが付いています(‘magit-git-’は他の目的にも使用され
ます)。

これらの関数はすべて、Git(または場合によっては任意の実行可能ファイル)の
コマンドライン引数を指定する文字列である、無制限の数の引数を受け入れます
。これらの引数は、実行可能ファイルに渡される前にフラット化(flattened)さ
れます。したがって、文字列の代わりに、‘nil’である文字列と引数のリストを
黙って削除することもできます。これらの関数の一部は、これらのコマンドライ
ン引数の前に単一の必須引数も必要とします。

大まかに言えば、これらの関数はGitを実行して、何らかの値を取得するか、副
作用を検出します。値を返す関数は、Magitバッファにデータを取り込むために
必要な情報を収集するのに役立ちますが、他の関数はMagitコマンドを実装する
ために使用されます。

値のみのグループの関数は常に同期的に実行され、リフレッシュをトリガーする
ことはありません。副作用グループの関数は、Gitを同期的に実行するか非同期
的に実行するか、および実行可能ファイルの終了時にリフレッシュをトリガーす
るかどうかに応じて、さらにサブグループに分割できます。

* Menu:

* Getting a Value from Git::  Getting a Value from Git
* Calling Git for Effect::   Calling Git for Effect


File: magit.ja.info,  Node: Getting a Value from Git,  Next: Calling Git for Effect,  Up: Calling Git

10.1.1 Getting a Value from Git
-------------------------------

これらの関数は、値、終了ステータス、または出力を取得するためにGitを実行
します。 もちろん、それらを使用して副作用のあるGitコマンドを実行すること
もできますが、それは避ける必要があります。

 -- Function: magit-git-exit-code &rest args
     ARGSを伴ったgitを実行し、そのexit codeを返します。

 -- Function: magit-git-success &rest args
     ARGSを伴ってgitを実行し、exit codeが‘0’ならば‘t’を返し、exit codeが
     それ以外の場合は‘nil’を返します。

 -- Function: magit-git-failure &rest args
     ARGSを伴ってgitを実行し、exit codeが‘1’ならば‘t’を返し、exit codeが
     それ以外の場合は‘nil’を返します。

 -- Function: magit-git-true &rest args
     ARGSを伴ってgitを実行し、gitによって出力される最初の行が文字列
     "true"の場合は‘t’を返し、それ以外の場合は‘nil’を返します。

 -- Function: magit-git-false &rest args
     ARGSを伴ってgitを実行し、gitによって出力される最初の行が文字列
     "false"の場合は‘t’を返し、それ以外の場合は‘nil’を返します。

 -- Function: magit-git-insert &rest args
     ARGSを伴ってgitを実行し、その出力をポイントに挿入します。

 -- Function: magit-git-string &rest args
     ARGSを伴ってgitを実行し、その出力の最初の行を返します。出力がない場
     合、または改行文字(newline character)で始まる場合は、‘nil’が返され
     ます。

 -- Function: magit-git-lines &rest args
     ARGSを伴ってgitを実行し、その出力を行のリスト(list)として返します。
     出力の空行は省略されます。

 -- Function: magit-git-items &rest args
     ARGSを伴ってgitを実行し、nullで区切られた出力をリスト(list)として返
     します。空のアイテムは省略されます。

     オプション‘magit-git-debug’の値がnil以外で、gitがゼロ以外の終了ステ
     ータスで終了する場合は、エコー領域でそのことを警告し、現在のリポジ
     トリのプロセスバッファにgitの標準エラーを含むセクションを追加します
     。

 -- Function: magit-process-git destination &rest args
     別のプロセスでGitを同期的に呼び出し、終了コードを返します。
     DESTINATIONは、ファイルハンドラーがサポートされていることを除いて、
     ‘call-process’のように出力を処理する方法を指定します。呼び出し中は
     Cygwinの「noglob」オプションを有効にし、unix eol変換を保証します。

 -- Function: magit-process-file process &optional infile buffer display
          &rest args
     別のプロセスでファイルを同期的に処理します。‘process-file’と同じで
     すが、呼び出し中はCygwinの「noglob」オプションを一時的に有効にし、
     unix eol変換を保証します。

上記の関数のいずれかを使用しているときにエラーが発生した場合、それは通常
、バグが原因です。つまり、実際にはサポートされていない引数を使用していま
す。 このようなエラーは通常報告されませんが、発生した場合はデバッグでき
る必要があります。

 -- User Option: magit-git-debug
     ‘magit-git-insert’または‘magit-git-string’または‘magit-git-lines’ま
     たは‘magit-git-items’の使用時に発生するエラーを報告するかどうか。こ
     れは実際にはエラーを発生させません。代わりに、エコー領域にメッセー
     ジが表示され、gitの標準エラーが現在のリポジトリのプロセスバッファの
     新しいセクションに挿入されます。

 -- Function: magit-git-str &rest args
     これは、オプション‘magit-git-debug’を無視する‘magit-git-string’のバ
     リエーションです。これは主に、そのオプションを尊重する関数のエラー
     を処理するときに使用することを目的としています。エラーの処理中にこ
     のような関数を使用すると、さらに別のエラーが発生する可能性があるた
     め、無限再帰が発生する可能性があります。おそらく、あなたは、この関
     数を使用する必要を感じないでしょう。


File: magit.ja.info,  Node: Calling Git for Effect,  Prev: Getting a Value from Git,  Up: Calling Git

10.1.2 Calling Git for Effect
-----------------------------

これらの関数は、gitを実行して何らかの効果を生み出すために使用されます。
実際にgitを実行するほとんどのMagitコマンドは、そのような関数を使用して実
行します。

これらの関数を使用するときにgitの出力を消費する必要がないため、それらの
出力は代わりにリポジトリごとのバッファに記録されます。これは、Magitバッ
ファの‘$’または、他の場所では‘M-x magit-process’を使用して表示できます。

これらの関数は、2つの異なる方法で効果を発揮する可能性があります。まず、
gitを実行すると何かが変わる可能性があります。つまり、新しいコミットを作
成またはプッシュします。 次に、その変更では、リポジトリの変更された状態
を反映するためにMagitバッファをリフレッシュする必要がある場合があります
。 ただし、リフレッシュが常に望ましいとは限らないため、gitが戻った後、こ
れらの関数の一部のみがそのようなリフレッシュを実行します。

gitを非同期で実行すると便利な場合があります。たとえば、ユーザーがプッシ
ュを開始したばかりの場合、それが完了するまでユーザーを待たせる理由はあり
ません。それ以外の場合は、ユーザーに他のことをさせる前にgitが完了するの
を待つのが理にかなっています。 たとえば、変更をステージした後は、自動的
に次の行の変更に移動するため、リフレッシュが完了するまで待つと便利です。

 -- Function: magit-call-git &rest args
     ARGSを伴ってgitを同期的に呼び出します。

 -- Function: magit-call-process program &rest args
     ARGSを伴って同期的にPROGRAMを呼び出します。

 -- Function: magit-run-git &rest args
     ARGSを伴ってgitを同期的に呼び出し、それからリフレッシュします。

 -- Function: magit-run-git-with-input &rest args
     ARGSを伴って同期的にgitを呼び出し、標準入力(standard input)で現在の
     バッファの内容を送信します。

     現在のバッファの‘default-directory’がリモートファイルシステム上にあ
     る場合、この関数は実際にはgitを非同期で実行します。ただし、プロセス
     が戻るのを待つため、関数自体は同期しています。

 -- Function: magit-git &rest args
     副作用についてのみ、ARGSを伴って同期的にgitを呼び出します。この関数
     はバッファをリフレッシュしません。

 -- Function: magit-git-wash washer &rest args
     ARGSを伴ってGitを実行して、洗浄された出力をポイントに挿入します。実
     際には、最初に生の出力をポイントに挿入します。出力がない場合は、
     ‘magit-cancel-section’を呼び出します。それ以外の場合は、挿入された
     テキストのみ一時的にバッファをnarrowし、最初に移動してから、ARGSを
     唯一の引数として関数WASHERを呼び出します。

以下は非同期バリエーションです。

 -- Function: magit-run-git-async &rest args
     Gitを開始(start)し、リフレッシュの準備をして、プロセスオブジェクト
     を返します。ARGSはフラット化され、Gitへの引数として使用されます。

     エコー領域にコマンドライン引数を表示します。

     Gitから戻った後、いくつかのバッファがリフレッシュされます。それは、
     この関数が呼び出されたときに現在のバッファ(Magitバッファであり、ま
     だ生きている場合)と、それぞれのMagitステータスバッファです。
     ‘magit-revert-buffers’がnil以外の場合、現在のリポジトリで追跡されて
     いるファイルを訪問している変更されていないバッファはrevertされます
     。

 -- Function: magit-run-git-with-editor &rest args
     GIT_EDITORをエクスポートし、Gitを開始します。また、リフレッシュの準
     備をして、プロセスオブジェクトを返します。ARGSはフラット化され、
     Gitへの引数として使用されます。

     エコー領域にコマンドライン引数を表示します。

     Gitから戻った後、いくつかのバッファがリフレッシュされます。それは、
     この関数が呼び出されたときに現在のバッファ(Magitバッファであり、ま
     だ生きている場合)と、それぞれのMagitステータスバッファです。

 -- Function: magit-start-git input &rest args
     Gitを開始し、リフレッシュの準備をして、プロセスオブジェクトを返しま
     す。

     INPUTがnilでない場合、それはバッファまたは既存のバッファの名前であ
     る必要があります。バッファの内容がプロセスの標準入力になります。

     オプション‘magit-git-executable’はGit実行可能ファイルを指定し、オプ
     ション‘magit-git-global-arguments’は定数引数を指定します。残りの引
     数ARGSは、Gitへの引数を指定します。それらは使用前にフラット化されま
     す。

     Gitから戻った後、いくつかのバッファがリフレッシュされます。それは、
     この関数が呼び出されたときに現在のバッファ(Magitバッファであり、ま
     だ生きている場合)と、それぞれのMagitステータスバッファです。
     ‘magit-revert-buffers’がnil以外の場合、現在のリポジトリで追跡されて
     いるファイルを訪問している変更されていないバッファはrevertされます
     。

 -- Function: magit-start-process &rest args
     PROGRAMを開始し、リフレッシュの準備をして、プロセスオブジェクトを返
     します。

     オプションの引数INPUTがnil以外の場合、それはバッファまたは既存のバ
     ッファの名前である必要があります。バッファの内容がプロセスの標準入
     力になります。

     プロセスは‘start-file-process’を使用して開始され、センチネル(番兵)
     ‘magit-process-sentinel’とフィルター‘magit-process-filter’を使用す
     るようにセットアップされます。これらの関数に必要な情報は、プロセス
     オブジェクトに格納されます。この関数から戻ったとき、プロセスはまだ
     実行を開始していないため、センチネルとフィルターをオーバーライドす
     ることができます。

     プロセスから戻った後、‘magit-process-sentinel’は、
     ‘magit-start-process’が呼び出されたときに現在のバッファ(Magitバッフ
     ァであり、まだ生きている場合)と、それぞれのMagitステータスバッファ
     をリフレッシュします。‘magit-revert-buffers’がnil以外の場合、現在の
     リポジトリで追跡されているファイルを訪問している変更されていないバ
     ッファはrevertされます。

 -- Variable: magit-this-process
     開始しようとしている子プロセス。これは、フィルターとセンチネル(番兵
     )を変更するために使用できます。

 -- Variable: magit-process-raise-error
     これがnil以外の場合、gitがゼロ以外の終了ステータスで終了すると、
     ‘magit-process-sentinel’はエラーを発生させます。これはデバッグ用で
     す。


File: magit.ja.info,  Node: Section Plumbing,  Next: Refreshing Buffers,  Prev: Calling Git,  Up: 配管コマンド(Plumbing)

10.2 Section Plumbing
=====================

* Menu:

* Creating Sections::        Creating Sections
* Section Selection::        Section Selection
* Matching Sections::        Matching Sections


File: magit.ja.info,  Node: Creating Sections,  Next: Section Selection,  Up: Section Plumbing

10.2.1 Creating Sections
------------------------

 -- Macro: magit-insert-section &rest args
     ポイントにセクションを挿入します。

     TYPEのセクションオブジェクトを作成し、その‘value’スロットにVALUEを
     格納して、ポイントにセクションを挿入します。TYPEはセクションタイプ
     で、シンボルです。現在のセクションに作用する多くのコマンドは、その
     タイプに応じて異なる動作をします。また、変数
     ‘magit-TYPE-section-map’が存在する場合は、それをセクションに属する
     すべてのテキストのテキストプロパティ‘keymap’として使用します(ただし
     、これはサブセクションで上書きされる場合があります)。 TYPEは、
     ‘(eval FORM)’の形式にすることもできます。この場合、FORMは実行時に評
     価されます。

     オプションのVALUEはセクションの値であり、通常はセクションを操作する
     ときに必要な文字列です。

     オプションのHIDEがnil以外の場合、デフォルトでセクション本体を折りた
     たみます。つまり、それは最初にセクションを作成するときです。しかし
     、バッファをリフレッシュするときは折りたたみません。それ以外の場合
     は、デフォルトで展開します。これは、
     ‘magit-section-set-visibility-hook’を使用して上書きできます。リフレ
     ッシュ中にセクションが再作成されると、先行の可視性が継承され、
     HIDEは無視されます(ただし、フックは引き続き尊重されます)。

     BODYは、セクションの見出しと本文を実際に挿入する任意の数のフォーム
     です。オプションのNAMEを指定する場合は、シンボルにする必要がありま
     す。シンボルは、挿入されるセクションの構造体(struct)に結び付けられ
     ます。

     BODYが評価される前に、セクションオブジェクトの‘start’が‘point’の値
     に設定され、BODYが評価された後、その‘end’が‘point’の新しい値に設定
     されます。 BODYは、‘point’を前進させる責任があります。

     セクションが空であることがBODY内で判明した場合は、
     ‘magit-cancel-section’を使用して、部分的に挿入されたセクションのす
     べてのトレースを中止して削除できます。これは、Gitの出力を洗浄
     (wash)してセクションを作成し、Gitが今回は実際には何も出力しなかった
     場合に発生する可能性があります。

 -- Function: magit-insert-heading &rest args
     現在挿入されているセクションの見出しを挿入します。

     この関数は、‘magit-insert-section’内でのみ使用する必要があります。

     引数なしで呼び出された場合は、挿入されるセクションを表すオブジェク
     トの‘content’スロットを‘point’のマーカーに設定するだけです。この関
     数をこのように使用する場合、セクションには1行のみを含める必要があり
     ます。

     文字列でなければならない引数ARGSを指定して呼び出された場合は、それ
     らの文字列をポイントに挿入します。これが発生する前はセクションにテ
     キストを含めないでください。その後、セクションには1行だけを含める必
     要があります。‘face’プロパティがこれらの文字列のいずれかの内部のど
     こかに設定されている場合は、それらすべてを変更せずに挿入します。そ
     れ以外の場合は、挿入されたすべてのテキストに‘magit-section-heading’
     faceを使用します。

     セクション構造体の‘content’プロパティは、見出しの終わり(‘start’から
     ‘content’まで続く)と本文の始まり(‘content’から‘end’まで続く)です。
     ‘content’の値がnilの場合、セクションには見出しがなく、本文を折りた
     たむことはできません。セクションに見出しがある場合、その高さは、末
     尾の改行文字を含めて、正確に1行である必要があります。これは強制され
     ません。あなたはそれを正しくする責任があります。唯一の例外は、この
     関数が必要に応じて改行文字を挿入することです。

 -- Function: magit-cancel-section
     現在挿入されているセクションをキャンセルします。これにより、
     ‘magit-insert-section’への最も内側の呼び出しが終了し、その呼び出し
     内ですでに発生したことのすべての痕跡が削除されます。

 -- Function: magit-define-section-jumper sym title &optional value
     現在挿入されているセクションSYMをキャンセルします。 これにより、
     ‘magit-insert-section’への最も内側の呼び出しが終了し、その呼び出し
     内ですでに発生したことのすべての痕跡が削除されます。


File: magit.ja.info,  Node: Section Selection,  Next: Matching Sections,  Prev: Creating Sections,  Up: Section Plumbing

10.2.2 Section Selection
------------------------

 -- Function: magit-current-section
     ポイントのセクションを返します。

 -- Function: magit-region-sections &optional condition multiple
     選択したセクションのリストを返します。

     リージョンがアクティブで、有効なセクション選択を構成している場合は
     、選択されたすべてのセクションのリストを返します。これは、領域がセ
     クションの見出しで始まり、同じセクションまたは兄弟セクションの見出
     しで終わる場合です。オプションのMULTIPLEがnil以外の場合、領域は同じ
     セクションで開始および終了できません。

     選択が無効な場合は、nilを返します。この場合、選択したセクションに作
     用する可能性のあるほとんどのコマンドは、代わりにそのポイントのセク
     ションに作用します。

     領域が他のバッファにあるように見える場合、選択は無効です。選択が有
     効な場合、領域は‘magit-section-highlight’ faceを使用します。これは
     、物事が少し複雑になるdiffには適用されませんが、ここでも、領域が通
     常のように見える場合でも、この関数に関する限り、これは有効な選択で
     はありません。

     オプションのCONDITIONがnil以外の場合、選択は有効である必要があるだ
     けではありません。選択したすべてのセクションは、さらにCONDITIONと一
     致する必要があります。一致しない場合、nilが返されます。CONDITIONが
     取ることができる形式については、‘magit-section-match’を参照してくだ
     さい。

 -- Function: magit-region-values &optional condition multiple
     選択したセクションの値のリストを返します。

     ‘magit-region-sections’(を参照)によって返される値を返します。


File: magit.ja.info,  Node: Matching Sections,  Prev: Section Selection,  Up: Section Plumbing

10.2.3 Matching Sections
------------------------

‘M-x magit-describe-section-briefly’
     ポイントのセクションに関する情報を表示します。このコマンドは、デバ
     ッグを目的としています。

 -- Function: magit-section-ident section
     SECTIONの一意のIDを返します。戻り値の形式は‘((TYPE . VALUE)...)’で
     す。

 -- Function: magit-get-section ident &optional root
     IDENTで識別されるセクションを返します。IDENTは、
     ‘magit-section-ident’によって返されるリストである必要があります。

 -- Function: magit-section-match condition &optional section
     SECTIONがCONDITIONと一致する場合は、‘t’を返します。SECTIONは、デフ
     ォルトでポイントのセクションになります。SECTIONが指定されておらず、
     ポイントにもセクションがない場合は、‘nil’を返します。

     CONDITIONは、以下の形式をとることができます:
        • ‘(CONDITION...)’

          上記のCONDITIONのいずれかが一致する場合に一致します。

        • ‘[CLASS...]’

          セクションのクラスが最初のCLASSまたはそのサブクラスと同じであ
          る場合に一致します。セクションの親クラスは2番目のCLASSと一致し
          ます。以下同様。

        • ‘[* CLASS...]’

          ‘[CLASS...]’に一致するセクションと、それらのすべての子セクショ
          ンを再帰的に一致させます。

        • ‘CLASS’

          セクションのクラスがCLASSまたはそのサブクラスと同じである場合
          に一致します。親セクションのクラスに関係なくです。

     各CLASSは、‘magit-section’から派生したクラスを識別するクラスシンボ
     ルである必要があります。下位互換性のために、CLASSは「タイプシンボル
     」にすることもできます。‘type’スロットの値が‘eq’の場合、セクション
     はそのようなシンボルに一致します。タイプシンボルの
     ‘magit--section-type-alist’にエントリがある場合、そのクラスがその
     alistのタイプに対応するクラスのサブクラスであれば、セクションもその
     タイプに一致します。

     注意: もちろん、正確にしたい場合を除いて、
     ‘magit-describe-section-briefly’によって出力される完全なセクション
     系統を指定する必要はないことに注意してください。

 -- Function: magit-section-value-if condition &optional section
     ポイントのセクションがCONDITIONと一致する場合は、その値を返します。

     オプションのSECTIONがnil以外の場合は、代わりにそれが一致するかどう
     かをテストします。ポイントにセクションがなく、SECTIONがnilの場合は
     、nilを返します。 セクションが一致しない場合は、nilを返します。

     CONDITIONが取ることができる形式については、‘magit-section-match’を
     参照してください。

 -- Function: magit-section-case &rest clauses
     ポイントのセクションのタイプに関する条項(clauses)から選択します。

     各句は(CONDITION BODY...)のようになります。セクションのタイプは、各
     条件と比較されます。最初の一致のBODYフォームが順番に評価され、最後
     のフォームの値が返されます。BODY内では、シンボル‘it’がポイントのセ
     クションに結び付けられています。句が成功しない場合、またはポイント
     にセクションがない場合は、nilを返します。

     CONDITIONが取ることができる形式については、‘magit-section-match’を
     参照してください。さらに、‘t’のCONDITIONは最後の節で許可され、他の
     CONDITIONが一致しない場合は、ポイントにセクションがない場合でも一致
     します。

 -- Variable: magit-root-section
     現在のバッファのルートセクション。他のすべてのセクションは、このセ
     クションの子孫です。この変数の値は‘magit-insert-section’によって設
     定されるため、変更しないでください。

diff関連のセクションには、いくつかの追加ツールがあります。

 -- Function: magit-diff-type &optional section
     別のタイプのSECTIONを返します。

     返されるタイプは、‘staged’または‘unstaged’または‘committed’または
     ‘undefined’のいずれかのシンボルです。このタイプは、すべてのセクショ
     ンに共通の一般的なタイプ(対応する‘magit-section’構造体の‘type’スロ
     ットに格納されます)と同様の目的を果たしますが、追加情報を考慮に入れ
     ます。SECTIONがdiffに関連しておらず、それを含むバッファもdiffのみの
     バッファではない場合は、nilを返します。

     現在、タイプは‘tracked’と‘untracked’のいずれかになりますが、これら
     の値は、本来あるべきすべての場所で明示的に処理されるわけではありま
     せん。考えられる修正は、ここでnilを返すことです。

     セクションは、‘diff’または‘hunk’セクション、または子のタイプが
     ‘diff’であるセクションである必要があります。オプションのSECTIONが
     nilの場合、現在のセクションのdiffタイプを返します。メジャーモードが
     ‘magit-diff-mode’であるバッファでは、SECTIONは無視され、タイプは他
     の手段を使用して決定されます。‘magit-revision-mode’バッファでは、タ
     イプは常に‘committed’です。

 -- Function: magit-diff-scope &optional section strict
     SECTIONの別のスコープまたは選択したセクション達を返します。

     diffの「スコープ」は、diffのどの部分が選択されているかを示します。
     これは、‘region’または‘hunk’または‘hunks’または‘file’または
     ‘files’または‘list’のいずれかのシンボルです。‘magit-diff-type’によ
     って返されるdiffの"type"とこれを混同しないでください。

     オプションのSECTIONがnil以外の場合は、リージョンによって選択された
     セクションを無視して、そのスコープを返します。それ以外の場合は、現
     在のセクションのスコープを返します。または、リージョンがアクティブ
     で、diff関連セクションの有効なグループを選択した場合は、これらのセ
     クションのタイプ、つまり‘hunks’または‘files’を返します。SECTION(ま
     たは現在のセクションがnil)が‘hunk’セクションであり、リージョンがそ
     のセクションの本体内で開始および終了する場合、タイプは‘region’です
     。

     オプションのSTRICTがnil以外の場合、ポイントのセクションのdiffタイプ
     が‘untracked’であるか、ポイントのセクションが実際には‘diff’ではなく
     ‘diffstat’セクションである場合は、nilを返します。


File: magit.ja.info,  Node: Refreshing Buffers,  Next: 慣習,  Prev: Section Plumbing,  Up: 配管コマンド(Plumbing)

10.3 Refreshing Buffers
=======================

新しいMagitバッファを作成したり、既存のバッファに表示されているものを変
更したりするすべてのコマンドは、‘magit-mode-setup’を呼び出すことによって
行います。 特に、この関数は、‘default-directory’(リポジトリの最上位)と
‘magit-refresh-function’と‘magit-refresh-args’のバッファローカル値を設定
します。

バッファは、‘magit-refresh-args’の値を引数として
‘magit-refresh-function’(‘magit-*-refresh-buffer’という名前の関数。‘*’の
部分は‘diff’のようなのが入ります)のローカル値である関数を呼び出すことに
よってリフレッシュされます。

 -- Macro: magit-mode-setup buffer switch-func mode refresh-func
          &optional refresh-args
     この機能は、BUFFERを表示および選択し、MODEをオンにして、最初にリフ
     レッシュします。

     この関数は、引数としてBUFFERとMODEとSWITCH-FUNCを指定して
     ‘magit-mode-display-buffer’を呼び出すことにより、BUFFERを表示し、オ
     プションでBUFFERを選択します。次に、‘magit-refresh-function’のロー
     カル値をREFRESH-FUNCに設定し、‘magit-refresh-args’のローカル値を
     REFRESH-ARGSに設定します。最後に、引数としてREFRESH-ARGSを指定して
     REFRESH-FUNCを呼び出すことにより、バッファ内容を作成します。

     BUFFERに切り替える前に、すべての引数が評価されます。

 -- Function: magit-mode-display-buffer buffer mode &optional
          switch-function
     この機能は、あるウィンドウにBUFFERを表示してそのウインドウを選択し
     ます。BUFFERは、バッファまたは文字列、つまりバッファの名前の場合が
     あります。バッファを返します。

     選択したフレームにBUFFERがすでに表示されていない限り、前のウィンド
     ウ構成をバッファローカル値として保存し、後で
     ‘magit-mode-bury-buffer’で復元できるようにします。

     バッファが表示され、SWITCH-FUNCTIONを使用してそのバッファが選択され
     ます。それが‘nil’の場合、現在のバッファのメジャーモードが
     ‘magit-mode’から派生していれば、‘pop-to-buffer’が使用されます。それ
     以外の場合は、‘switch-to-buffer’が使用されます。

 -- Variable: magit-refresh-function
     このバッファローカル変数の値は、現在のバッファをリフレッシュするた
     めに使用される関数です。‘magit-refresh-args’を引数として呼び出され
     ます。

 -- Variable: magit-refresh-args
     ‘magit-refresh-function’が現在のバッファを更新するために使用する引
     数のリスト(list)。‘magit-refresh-function’は、これらの引数を使用し
     て呼び出されます。

     通常、値は‘magit-mode-setup’を使用して設定されますが、値を変更でき
     るコマンドを提供すると便利な場合もあります。たとえば、
     ‘magit-diff-refresh’トランジェントコマンドを使用すると、どのdiffを
     表示するかを再度指定しなくても、diffの表示に使用される引数を変更で
     きますが、‘magit-diff-more-context’と‘magit-diff-less-context’と
     ‘magit-diff-default-context’は、‘-U<N>’引数のみを変更します。どちら
     の場合も、これはこの変数の値を変更してから、この
     ‘magit-refresh-function’を呼び出すことによって行われます。


File: magit.ja.info,  Node: 慣習,  Prev: Refreshing Buffers,  Up: 配管コマンド(Plumbing)

10.4 慣習
=========

こちらもご覧ください(*note 補完と確認::)。

* Menu:

* Theming Faces::            Theming Faces


File: magit.ja.info,  Node: Theming Faces,  Up: 慣習

10.4.1 Theming Faces
--------------------

デフォルトのテーマでは、ローカルブランチに青色、リモートブランチに緑色、
タグにgoldenrod色(茶色がかった黄色;訳注:#daa520)を使用します。新しいテー
マを作成するときは、おそらくその例に従う必要があります。テーマがすでに他
の色を使用している場合は、それに依ります。

以前のリリースでは、これらの reference faceには背景色とその周囲のボック
スがありました。基本的なデフォルトのfaceは、Magitバッファのノイズを大幅
に減らすために、もはやそうしていません。少なくともボックスに関しては、そ
の例に従う必要があります。(ボックスは、ハイライトオーバーレイとテキスト
プロパティの背景の間の競合を回避するために過去に使用されていました。ハイ
ライトによって他の背景色が消えることがなくなったため、これは不要になりま
した)。または、背景色やボックスを保持することもできますが、次に、それに
応じて‘magit-branch-current’を調整するために特別な注意を払う必要がありま
す。デフォルトでは、ほとんど‘magit-branch-local’のように見えますが、ボッ
クスがあります(デフォルトでは、前者がボックスを使用する唯一のfaceであり
、正確に突き出ています(stick out))。前者もボックスを使用する場合は、後者
とは別の方法で異なることを確認する必要があります。

テーマにするのが最も難しいfaceは、diff、見出し、ハイライト、およびリージ
ョンに関連するfaceです。4つのグループすべてに分類されるfaceがあります。
これを正すためにはまだしばらくのお時間を頂きたいと思います。

デフォルトのテーマの‘region’のfaceは、明るいバリエーションと暗いバリエー
ションの両方、およびEmacsやサードパーティによって配布されている他の多く
のテーマでは非常に醜いです。本当に目立つ背景色を使用するのが一般的です。
これは醜いですが、それが唯一の問題である場合は許容されます。残念ながら、
多くのテーマは前景色も設定しているため、領域内のすべてのテキストが読みや
すくなっています。そうしないと、前景色が領域の背景色に近すぎて読めない場
合があります。ただし、リージョン内のテキストでは構文の強調表示がすべて失
われることも意味します。

‘region’のfaceを正しくするために行われた作業は、テーマの一般的な品質の良
い指標であると思います。‘region’のfaceの推奨事項は、次のとおりです:
‘default’のfaceの背景色とは少し異なる背景色を使用し、前景色をまったく設
定しないでください。したがって、明るいテーマの場合、‘default’の背景色と
して明るい(おそらく色付きの)灰色を使用し、‘region’の背景としてやや暗い灰
色を使用する場合があります。これは通常、他のfaceの前景色と衝突しないよう
にするには十分なはずです。ただし、他のfaceでも背景色として明るい灰色が設
定されている場合は、それらのfaceと衝突しないようにする必要があります(た
だし、許容できる場合もあります)。

Magitは、リージョンが独自の定義で「無効」である場合にのみ‘region’の
faceを使用します。Magitバッファでは、領域を使用して複数の兄弟セクション
を選択し、それをサポートするコマンドが現在のセクションだけでなくこれらす
べてのセクションに作用するようにするか、単一のハンクセクション内の行を選
択します。 他のすべての場合、セクションは無効と見なされ、Magitはそれに基
づいて行動しません。 しかし、そのような無効なセクションは、ユーザーがポ
イントを有効にするのに十分な位置に移動していないか、非magitコマンドを使
用して領域を操作したいために発生します。例: ‘kill-region’

したがって、無効なセクションに通常の‘region’のfaceを使用するのは仕様
(feature)です。これは、Magitがそれに基づいて行動することができないことを
ユーザーに伝えます。そのfaceが少し奇妙に見えても(ただしそれほどではあり
ませんが)、セクション見出しの背景色や背景色を持つ他のものと衝突する場合
は許容されます。

Magitは現在のセクションを強調表示します。セクションにサブセクションがあ
る場合、それらすべてが強調表示されます。これは、名前に"highlight"が含ま
れているfaceを使用して行われます。ほとんどのセクションでは、
‘magit-section-highlight’が本文と見出しの両方に使用されます。‘region’の
faceと同様に、背景色を‘default’と同様に設定する必要があります。ハイライ
トの背景色は、‘region’の背景色と‘default’の背景色の両方とは異なる必要が
あります。

diff関連セクションの場合、Magitはさまざまなfaceを使用して、選択したセク
ションのさまざまな部分を強調表示します。ハンクの見出しは、他のすべてのセ
クションの見出しとは異なり、デフォルトで背景色になっていることに注意して
ください。ハンクの間に非常に目立つ区切り記号があると便利だからです。その
faceの‘magit-diff-hunk-heading’は、‘magit-diff-hunk-heading-highlight’と
‘magit-section-highlight’の両方、および‘magit-diff-context’と
‘magit-diff-context-highlight’とは異なる必要があります。デフォルトでは、
前景色を変更することでこれを行います。 背景色を変更すると複雑になり、回
避できないものはすでに十分にあります。(また、セクションの見出しは常に太
字にすることをお勧めしますが、サブセクションがあるセクションの場合のみで
す)。

diff関連の兄弟セクション、つまり複数のファイルまたはハンクを選択する有効
な領域がある場合、これらすべてのセクションの本文はそれぞれのハイライト
faceを使用しますが、見出しは代わりに ‘magit-diff-file-heading-selection’
face または ‘magit-diff-hunk-heading-selection’ face のどちらかを使用し
ます。これらのfaceは、領域がアクティブであることを明確に視覚的に示すため
に、通常のハイライトバリエーションとは異なる必要があります。

diff関連のfaceにテーマを設定するときは、オプション
‘magit-diff-refine-hunk’を‘all’に設定することから始めます。個人的には、
現在のハンクのみを改良するか、ハンクの改良をまったく使用しないことを好む
かもしれません。しかし、テーマのユーザーの中には、すべてのハンクを改良す
ることを望んでいる人がいるため、それに対応する必要があります。

(また、‘magit-diff-highlight-indentation’と
‘magit-diff-highlight-trailing’と‘magit-diff-paint-whitespace’をオンにし
て、コードに空白エラー(some whitespace errors)を挿入します。テストに使用
します。)

追加された行については、‘magit-diff-added’と
‘magit-diff-added-highlight’と‘smerge-refined-added’の3つのfaceを調整す
る必要があります。後者が前者の両方、および‘smerge-other’と‘diff-added’で
うまく機能することを確認してください。次に、削除された行、コンテキスト行
、追加された行、およびそれらによって追加された行についても同じようにしま
す。また、追加、削除、およびコンテキストのそれぞれのfaceが、強調表示され
たバリエーションと強調表示されていないバリエーションの両方でほぼ同じ彩度
を使用していることを確認してください。また、ファイルとdiffの見出しがコン
テキスト行とうまく機能することを確認します(たとえば、見た目を変えます)。
線のfaceは、前景色と背景色の両方を設定する必要があります。たとえば、追加
された行には、2つの異なる緑色を使用します。

これはハイライトされたバリエーションとハイライトされていないバリエーショ
ンの両方の前景色が同じである場合に最適です。したがって、ハイライトとハイ
ライトされていない背景、リファインされた背景、およびハイライトコンテキス
トの背景で適切に機能する色を見つける必要があります。ハンクの内部領域があ
る場合、追加行と削除行の背景色はその領域内でのみ使用されます。領域外では
、強調表示されたコンテキストの背景色が使用されます。これにより、何がステ
ージされているかを簡単に確認できます。ハンクの内部領域では、ハンクの見出
しは‘magit-diff-hunk-heading-selection’を使用して表示され、領域内にある
線の周りに追加される細い線も同様です。その背景色は、他のさまざまな関連す
る背景色と十分に区別する必要があります。

これを行うのは簡単ではありません。テーマが特定の色のセットに制限されてい
る場合は、ここで例外を作成する必要があります。そうでなければ、すべてのバ
リエーションでdiffの見栄えを良くすることは不可能です。実際には、これらの
faceのデフォルトの定義に固執したい場合があります。警告します！ 正しく行
わないと、ユーザーからはMagitのバグのように見える場合があることに注意し
てください。正しく行うか、まったく行わないでください。


File: magit.ja.info,  Node: FAQ,  Next: Debugging Tools,  Prev: 配管コマンド(Plumbing),  Up: Top

Appendix A FAQ
**************

以下の2つ節には、よくある質問が一覧表示してあります。*よくある最近*の質
問、つまりまだマニュアルに記載されていない質問のリストについては
→<https://github.com/magit/magit/wiki/FAQ>

どうぞこちらご覧下さい *note Debugging Tools::

* Menu:

* FAQ - How to ...?::    FAQ - How to ...?
* FAQ - Issues and Errors::  FAQ - Issues and Errors


File: magit.ja.info,  Node: FAQ - How to ...?,  Next: FAQ - Issues and Errors,  Up: FAQ

A.1 FAQ - How to ...?
=====================

* Menu:

* Magitの発音は？::     Magitの発音は？
* How to show git's output?::  How to show git’s output?
* How to install the gitman info manual?::  How to install the gitman info
                                              manual?
* How to show diffs for gpg-encrypted files?::  How to show diffs for
                                                  gpg-encrypted files?
* How does branching and pushing work?::  How does branching and pushing
                                            work?
* VCを無効にする必要がありますか？::  VCを無効にする必要がありますか？


File: magit.ja.info,  Node: Magitの発音は？,  Next: How to show git's output?,  Up: FAQ - How to ...?

A.1.1 Magitの発音は？
---------------------

発音は‘mu[m's] git’または‘magi{c => t}’のいずれかで問題ありません。

スローガンは "It’s Magit!  The magical Git client" なので、magiCと
magiTが同じように聞こえないことを考慮しながら、Magitをmagic(魔法)のよう
に発音するのは理にかなっています。(訳注「マジット」)

ドイツ語の"Magie"は英語の"magic"と同じ発音ではないため、ドイツ語を話す場
合は、上記の合理性を使用して前者の発音を使用することを正当化できます。
‘Mag{ie => it}’

以前の発音が好きだからと、前者の発音を使用してもかまいません。

参照 <https://magit.vc/assets/videos/magic.mp4>(訳注:2021年現在ファイル
が存在しない模様)。 こちらもご覧ください
<https://emacs.stackexchange.com/questions/13696>


File: magit.ja.info,  Node: How to show git's output?,  Next: How to install the gitman info manual?,  Prev: Magitの発音は？,  Up: FAQ - How to ...?

A.1.2 How to show git’s output?
-------------------------------

最近実行されたgitコマンドの出力を表示するには、‘$’(または、それが利用で
きない場合は‘M-x magit-process-buffer’)を押します。これにより、git呼び出
しごとのセクションを含むバッファが表示されます。いつものように‘TAB’を押
して展開または折りたたみできます。

デフォルトでは、gitの出力は、副作用の目的のために実行された場合にのみプ
ロセスバッファに挿入されます。出力が何らかの方法で消費される場合、それを
プロセスバッファに挿入することもコストがかかりすぎます。デバッグの目的で
、‘magit-git-debug’を‘t’に設定することで、とにかくそうすることができます
。


File: magit.ja.info,  Node: How to install the gitman info manual?,  Next: How to show diffs for gpg-encrypted files?,  Prev: How to show git's output?,  Up: FAQ - How to ...?

A.1.3 How to install the gitman info manual?
--------------------------------------------

Gitのmanpage達は、‘gitman’というinfoマニュアルとしてエクスポートできます
。Infoはmampageへのリンクをサポートしていないため、Magit独自のinfoマニュ
アルは実際のmanpageではなくそのマニュアルのノードにリンクしています。

残念ながら、一部のディストリビューションではデフォルトで‘gitman’マニュア
ルがインストールされていないため、入手するには別のドキュメントパッケージ
をインストールする必要があります。

Magitは、それぞれのmanpageを表示する代わりに、‘gitman’ infoマニュアルへ
のリンクを訪問する機能を追加するInfoにパッチを適用します。そのアプローチ
を好む場合は、‘magit-view-git-manual-method’の値をサポートされているパッ
ケージ‘man’または‘woman’のいずれかに設定します。例:

     (setq magit-view-git-manual-method 'man)


File: magit.ja.info,  Node: How to show diffs for gpg-encrypted files?,  Next: How does branching and pushing work?,  Prev: How to install the gitman info manual?,  Up: FAQ - How to ...?

A.1.4 How to show diffs for gpg-encrypted files?
------------------------------------------------

Gitは暗号化されたファイルのdiffの表示をサポートしていますが、そうするよ
うに指示する必要があります。MagitはGitを使用してdiffを取得するだけなので
、Gitを設定すると、Magit内に表示されるdiffにも影響します。

     git config --global diff.gpg.textconv "gpg --no-tty --decrypt"
     echo "*.gpg filter=gpg diff=gpg" > .gitattributes


File: magit.ja.info,  Node: How does branching and pushing work?,  Next: VCを無効にする必要がありますか？,  Prev: How to show diffs for gpg-encrypted files?,  Up: FAQ - How to ...?

A.1.5 How does branching and pushing work?
------------------------------------------

こちらをご覧ください *note Branching:: と
<http://emacsair.me/2016/01/18/magit-2.4>


File: magit.ja.info,  Node: VCを無効にする必要がありますか？,  Prev: How does branching and pushing work?,  Up: FAQ - How to ...?

A.1.6 VCを無効にする必要がありますか？
--------------------------------------

あなたはVC(組み込みのバージョン管理インターフェイス)を使用しない場合、あ
なたは特に、VCを使用することを推奨していたため、無効にしたくなるかもしれ
ません。

我々は、あなたがVCを無効にすることはお勧めしません。これを行うと、有効に
なっているVCに依存する便利なサードパーティパッケージ(‘diff-hl’など)が破
損します。

あなたがとにかくVCを無効にすることを選択した場合は、
‘vc-handled-backends’の値を変更することで無効にできます。


File: magit.ja.info,  Node: FAQ - Issues and Errors,  Prev: FAQ - How to ...?,  Up: FAQ

A.2 FAQ - Issues and Errors
===========================

* Menu:

* Magit is slow::            Magit is slow
* I changed several thousand files at once and now Magit is unusable::  I
                                                                          changed
                                                                          several
                                                                          thousand
                                                                          files
                                                                          at
                                                                          once
                                                                          and
                                                                          now
                                                                          Magit
                                                                          is
                                                                          unusable
* コミットに問題があります::  コミットに問題があります
* MS WindowsではMagitでpushできません::  MS
                                                   WindowsではMagitでpushできません
* 私は macOS を使用しています。その何かはシェルでは動きますが、Magitでは動きません: 私は macOS を使用しています。その何かはシェルでは動きますが、Magitでは動きません.  私は
                                                                                                                                                                                                                                             macOS
                                                                                                                                                                                                                                             を使用しています。その何かはシェルでは動きますが、Magitでは動きません:
                                                                                                                                                                                                                                             私は
                                                                                                                                                                                                                                             macOS
                                                                                                                                                                                                                                             を使用しています。その何かはシェルでは動きますが、Magitでは動きません
* ファイルを展開してdiffを表示するとファイルが消えます::  ファイルを展開してdiffを表示するとファイルが消えます
* COMMIT_EDITMSGバッファのpointが間違っています::  ‘COMMIT_EDITMSG’バッファのpointが間違っています
* モード行の情報が常に最新ではない::  モード行の情報が常に最新ではない
* 同じ名前を共有するブランチとタグは何かを壊します::  同じ名前を共有するブランチとタグは何かを壊します
* 私のGitフックはコマンドラインでは機能しますが、Magit内では機能しません::  私のGitフックはコマンドラインでは機能しますが、Magit内では機能しません
* コマンドラインからコミットする場合、git-commit-modeは使用されません::  コマンドラインからコミットする場合、‘git-commit-mode’は使用されません
* file-visitingバッファにジャンプすると、ポイントは非表示のテキスト内にあります::  file-visitingバッファにジャンプすると、ポイントは非表示のテキスト内にあります
* MS-WindowsからEmacsのTrampモードを使用するとステージできません::  MS-WindowsからEmacsのTrampモードを使用するとステージできません
* 私はポップアップのデフォルトを保存できなくなりました::  私はポップアップのデフォルトを保存できなくなりました


File: magit.ja.info,  Node: Magit is slow,  Next: I changed several thousand files at once and now Magit is unusable,  Up: FAQ - Issues and Errors

A.2.1 Magit is slow
-------------------

*note Performance:: や *note I changed several thousand files at once
and now Magit is unusable:: を参照してください。


File: magit.ja.info,  Node: I changed several thousand files at once and now Magit is unusable,  Next: コミットに問題があります,  Prev: Magit is slow,  Up: FAQ - Issues and Errors

A.2.2 I changed several thousand files at once and now Magit is unusable
------------------------------------------------------------------------

(一度に数千のファイルを変更したら、Magit が使用できなくなりました)Magit
は現在、このような状況下ではうまく機能しないと予想されます。 ちゃんと動
くと素敵ですよね。 このような条件下で満足のいくパフォーマンスを達成する
には、かなりのリファクタリングが必要になります。 これは簡単な作業ではあ
りませんが、最終的には時間を見つけて実現したいと考えています。

ただし、今のところは、コマンドラインを使用してこのコミットを完了すること
をお勧めします。こちらも参照して下さい(*note Performance::)。


File: magit.ja.info,  Node: コミットに問題があります,  Next: MS WindowsではMagitでpushできません,  Prev: I changed several thousand files at once and now Magit is unusable,  Up: FAQ - Issues and Errors

A.2.3 コミットに問題があります
------------------------------

これは、Magitが適切なemacsclient実行可能ファイルを見つけるのに問題がある
ことを意味している可能性があります(*note (with-editor)Configuring
With-Editor:: and *note (with-editor)Debugging::)。


File: magit.ja.info,  Node: MS WindowsではMagitでpushできません,  Next: 私は macOS を使用しています。その何かはシェルでは動きますが、Magitでは動きません,  Prev: コミットに問題があります,  Up: FAQ - Issues and Errors

A.2.4 MS WindowsではMagitでpushできません
-----------------------------------------

Magitにありがちな問題であることはほぼ確実です。あなたがコマンドラインで
pushできる場合、構成(configuration)の問題である可能性が限りなく高いです
。

詳細なセットアップ手順は、
<https://github.com/magit/magit/wiki/Pushing-with-Magit-from-Windows>に
あります。


File: magit.ja.info,  Node: 私は macOS を使用しています。その何かはシェルでは動きますが、Magitでは動きません,  Next: ファイルを展開してdiffを表示するとファイルが消えます,  Prev: MS WindowsではMagitでpushできません,  Up: FAQ - Issues and Errors

A.2.5 私は macOS を使用しています。その何かはシェルでは動きますが、Magitでは動きません
--------------------------------------------------------------------------------------

これは通常、Emacsがシェルと同じ環境変数を持っていないために発生します。
<https://github.com/purcell/exec-path-from-shell>をインストールして設定
してみてください。デフォルトでは、‘$PATH’を同期します。これにより、
Magitはシェルで使用しているものと同じ‘git’を見つけることができます。

SOMETHINGが「コミットおよび/またはタグ署名のためのgpg-agentを使用したパ
スフレーズキャッシング」("passphrase caching with gpg-agent for commit
and/or tag signing")である場合、あなたは‘$GPG_AGENT_INFO’も同期する必要
があります。


File: magit.ja.info,  Node: ファイルを展開してdiffを表示するとファイルが消えます,  Next: COMMIT_EDITMSGバッファのpointが間違っています,  Prev: 私は macOS を使用しています。その何かはシェルでは動きますが、Magitでは動きません,  Up: FAQ - Issues and Errors

A.2.6 ファイルを展開してdiffを表示するとファイルが消えます
----------------------------------------------------------

これはおそらく、‘diff.*’ Git変数の変更が原因です。あなたはおそらく
‘magit-git-global-arguments’を何らかの理由で設定しています。よって、あな
たはMagit内で‘magit-git-global-arguments’をカスタマイズしたのを元に戻す
(undo)だけです。


File: magit.ja.info,  Node: COMMIT_EDITMSGバッファのpointが間違っています,  Next: モード行の情報が常に最新ではない,  Prev: ファイルを展開してdiffを表示するとファイルが消えます,  Up: FAQ - Issues and Errors

A.2.7 ‘COMMIT_EDITMSG’バッファのpointが間違っています
-----------------------------------------------------

Magitも ‘git-commit‘ も、コミットメッセージの書き込みに使用されるバッフ
ァ内のポイントをいじらないので、他の何かがわるさをしているに違いありませ
ん。

あなたはfile-visitingバッファのポイントを復元するモードをグローバルに有
効にしている可能性があります。少し意外かもしれませんが、コミットメッセー
ジを書くと、実際にはファイルを編集していることになります。

したがって、どのパッケージが実行されているかを把握する必要があります。
‘saveplace’と‘pointback’と‘session’が候補になる可能性があります。以下の
スニペットが役立つかもしれません:

     (setq session-name-disable-regexp "\\(?:\\`'\\.git/[A-Z_]+\\'\\)")

     (with-eval-after-load 'pointback
       (lambda ()
         (when (or git-commit-mode git-rebase-mode)
           (pointback-mode -1))))


File: magit.ja.info,  Node: モード行の情報が常に最新ではない,  Next: 同じ名前を共有するブランチとタグは何かを壊します,  Prev: COMMIT_EDITMSGバッファのpointが間違っています,  Up: FAQ - Issues and Errors

A.2.8 モード行の情報が常に最新ではない
--------------------------------------

Magitは、モードラインに表示されている‘Git-master’のようなバージョン管理
情報については責任を負いません。「VC」とも呼ばれる組み込みの「バージョン
管理」パッケージは、その情報を更新し、より頻繁に更新するように指示できま
す:

     (setq auto-revert-check-vc-info t)

しかし、そうするとフォーマンスが悪化します。 より多くの(過度に楽観的な
)情報についてはこちらを参照して下さい(*note (emacs)VC Mode Line::)。

あなたがこの情報をモード行に表示するこをあまり気にしないなら、_不正確な
_情報を単にモード行に表示しないことを検討してください。

     (setq-default mode-line-format
                   (delete '(vc-mode vc-mode) mode-line-format))


File: magit.ja.info,  Node: 同じ名前を共有するブランチとタグは何かを壊します,  Next: 私のGitフックはコマンドラインでは機能しますが、Magit内では機能しません,  Prev: モード行の情報が常に最新ではない,  Up: FAQ - Issues and Errors

A.2.9 同じ名前を共有するブランチとタグは何かを壊します
------------------------------------------------------

または、より一般的には、あいまいなrefnameはSOMETHINGを壊します。

Magitは、refが"refs/heads/"と"refs/tags/"と"refs/remotes/"名前空間全体で
明確に名前が付けられていることを前提としています(つまり、これらのプレフ
ィックスが削除されても、すべての名前は一意のままです)。あいまいな
refnameはサポートされていないと見なし、あいまいでない命名スキームを使用
することをお勧めします。ただし、refnameがあいまいなリポジトリを使用して
いる場合は、発生した問題を報告してください。簡単な修正があるかどうかを調
査できます。


File: magit.ja.info,  Node: 私のGitフックはコマンドラインでは機能しますが、Magit内では機能しません,  Next: コマンドラインからコミットする場合、git-commit-modeは使用されません,  Prev: 同じ名前を共有するブランチとタグは何かを壊します,  Up: FAQ - Issues and Errors

A.2.10 私のGitフックはコマンドラインでは機能しますが、Magit内では機能しません
-----------------------------------------------------------------------------

Magitが‘git’を呼び出すと、‘--literal-pathspecs’を含むいくつかのグローバ
ル引数が追加されます。Magitによって開始された‘git’プロセスは、その設定を
他の‘git’プロセスに渡します。これは、‘--literal-pathspecs’引数を使用して
サブプロセスを呼び出すのではなく、環境変数‘GIT_LITERAL_PATHSPECS’を設定
することによって行われます。したがって、‘unset GIT_LITERAL_PATHSPECS’を
使用して、フックスクリプトでこの設定をオーバーライドできます。


File: magit.ja.info,  Node: コマンドラインからコミットする場合、git-commit-modeは使用されません,  Next: file-visitingバッファにジャンプすると、ポイントは非表示のテキスト内にあります,  Prev: 私のGitフックはコマンドラインでは機能しますが、Magit内では機能しません,  Up: FAQ - Issues and Errors

A.2.11 コマンドラインからコミットする場合、‘git-commit-mode’は使用されません
----------------------------------------------------------------------------

これは、‘git-commit.el’がまだロードされていないか、サーバーがまだ起動さ
れていないためです。Magitからコミットするときは常にこれらの処理が為され
ています。これを行うにはMagitをロードする必要があり、そのためには
‘git-commit’をロードしてサーバーを開始する必要があります。

あなたがコマンドラインからコミットする場合は、これらのことを自分で処理す
る必要があります。‘init.el’ファイルには以下のものが含まれている必要があ
ります:

     (require 'git-commit)
     (server-mode)

あなたは‘(require ’git-commit)‘の代わりに以下を使用することもできます:

     (load "/path/to/magit-autoloads.el")

‘git-commit’をロードすると、Magitの大部分がロードされるため、これを実行
することをお勧めします。

‘(server-mode)’には、あなたが試してみたいバリエーションもいくつかあると
思います。作者の私が個人的に使用するものは:

     (use-package server
       :config (or (server-running-p) (server-mode)))

今やあなたは以下を使用できます:

     $ emacs&
     $ EDITOR=emacsclient git commit

けれども以下は使用できません:

     $ killall emacs
     $ EDITOR="emacsclient --alternate-editor emacs" git commit

これは実際には‘emacsclient’ではなく‘emacs’を使用することになります。この
場合でも、コミットメッセージは編集できますが、‘git-commit-mode’は使用さ
れず、プロセスを終了するには‘emacs’を終了する必要があります。

これのトートロジーになりますが、‘emacs’インスタンスが実行されていなくて
も、‘emacsclient’を使用して実行中の‘emacs’インスタンスに接続できるように
する場合は、‘emacsclient’を直接使用することはできません。

代わりに、以下のようなことを行うスクリプトを作成する必要があります:

(‘--alternate-editor’を使用せずに)‘emacsclient’を使用することを試みてく
ださい。それが成功した場合は、他に何もしません。それ以外の場合は、‘emacs
&’を開始(‘init.el’は‘server-start’を呼び出す必要があります)し、
‘emacsclient’の使用を再試行します。


File: magit.ja.info,  Node: file-visitingバッファにジャンプすると、ポイントは非表示のテキスト内にあります,  Next: MS-WindowsからEmacsのTrampモードを使用するとステージできません,  Prev: コマンドラインからコミットする場合、git-commit-modeは使用されません,  Up: FAQ - Issues and Errors

A.2.12 file-visitingバッファにジャンプすると、ポイントは非表示のテキスト内にあります
------------------------------------------------------------------------------------

これは、ハンクで‘RET’と入力して、それぞれの位置にあるそれぞれのファイル
を訪問したときに発生する可能性があります。この問題の1つの解決策は、
‘global-reveal-mode’を使用することです。ポイント周辺のテキストが常に表示
されるようにします。それがあなたの好みに対してあまりにも刺激的である場合
は、代わりに‘magit-diff-visit-file-hook’を使用してテキストを表示すること
ができます。おそらく、‘reveal-post-command’を使用するか、Orgバッファ
‘org-reveal’を使用します。


File: magit.ja.info,  Node: MS-WindowsからEmacsのTrampモードを使用するとステージできません,  Next: 私はポップアップのデフォルトを保存できなくなりました,  Prev: file-visitingバッファにジャンプすると、ポイントは非表示のテキスト内にあります,  Up: FAQ - Issues and Errors

A.2.13 MS-WindowsからEmacsのTrampモードを使用するとステージできません
---------------------------------------------------------------------

Trampを使用してリモートマシンに接続し、ローカルマシンがMS Windowsを使用
している場合、Magitは個々のハンクをステージ(または適用)できない場合があ
ります。

‘tramp-tests.el’の最後で説明したように、このシナリオでは
‘process-send-eof’に問題があるようです。これについてTrampのメンテナに連
絡しました。 今のところ、これは残念ながらそれが機能せず、私たちがそれに
ついて何もできないことを意味します。詳細については、
<https://github.com/magit/magit/issues/3624>にコメントしてください。


File: magit.ja.info,  Node: 私はポップアップのデフォルトを保存できなくなりました,  Prev: MS-WindowsからEmacsのTrampモードを使用するとステージできません,  Up: FAQ - Issues and Errors

A.2.14 私はポップアップのデフォルトを保存できなくなりました
-----------------------------------------------------------

Magitは、トランジェントポップアップメニューを実装するためにMagit-Popupを
使用していました。現在は、代わりにTransientを使用しています。これは
Magit-Popupの後継です。

以前のMagit-Popupメニューでは、ポップアップバッファで‘C-c C-c’を使用して
、ユーザー設定を保存することができました(たとえば、コミット用のgpg署名キ
ーの設定)。これによりポップアップは閉じられますが、今後のポップアップの
デフォルトとして設定が保存されるのです。

トランジェントメニューに切り替えると、この機能は代わりに‘C-x C-s’を介し
て利用できるようになりました。‘C-x’プレフィックスには、Transientを使用す
る場合にも他のオプションがあり、入力すると表示されます。詳細については
<https://magit.vc/manual/transient/Saving-Values.html#Saving-Values>を参
照してください。


File: magit.ja.info,  Node: Debugging Tools,  Next: Keystroke Index,  Prev: FAQ,  Up: Top

B Debugging Tools
*****************

Magitとその依存関係には、いくつかのデバッグツールが用意されています。問
題を報告する前にこれらのツールを使用していただければ幸いです。問題を報告
するときは、関連するすべての出力を含めてください。

‘M-x magit-version’
     このコマンドは、現在使用されているMagit、Git、およびEmacsのバージョ
     ンをエコー領域に表示します。非インタラクティブでは、これは単に
     Magitバージョンを返すだけです。

‘M-x magit-emacs-Q-command’
     このコマンドは、エコー領域にデバッグシェルコマンドを表示し、それを
     キルリングに追加します。そのコマンドをシェルに貼り付けして実行しま
     す。

     このシェルコマンドは、‘magit’とその依存関係のみがロードされた状態で
     ‘emacs’を開始します。構成も他のインストール済みパッケージもロードさ
     れません。これにより、Magitに問題があるのか他の問題にあるのかを簡単
     に判断できます。

     あなたがMagitをそのGitリポジトリから実行する場合は、このコマンドの
     出力の代わりに‘make emacs-Q’を使用できるはずです。

‘M-x magit-toggle-git-debug’
     このコマンドは、追加の git エラーが報告されるかどうかを切り替えます
     。

     Magitは基本的に次の2つの理由のいずれかでgitを呼び出します: 副作用の
     ため、または標準出力を使って何かをするためです。

     gitが副作用のために実行されると、エラーメッセージを含むその出力は、
     ‘$’を使用したときに表示されるプロセスバッファに送られます。

     gitの出力が何らかの方法で消費されると、それもこのバッファに挿入する
     にはコストがかかりすぎますが、このオプションがnil以外で、gitがゼロ
     以外の終了ステータスで返される場合、少なくともこのバッファにその標
     準エラーが挿入されます。

     これは、デバッグのみを目的としています。 これを永続的に有効にしない
     でください。パフォーマンスに悪影響を及ぼす可能性があります。 また、
     git がゼロ以外の終了ステータスで終了し、エラーメッセージを出力する
     からといって、それがこと Magit に関してはエラーであるとは限らないこ
     とに注意してください。これが、通常、これらのエラーメッセージを非表
     示にするもう 1 つの理由です。 エラーメッセージが予期しない動作に関
     連しているかどうかは、ケースバイケースで判断する必要があります。

‘M-x magit-toggle-verbose-refresh’
     このコマンドは、Magitがバッファを詳細にリフレッシュするかどうかを切
     り替えます。これを有効にすると、どのセクションがボトルネックである
     かを把握するのに役立ちます。追加の出力は、‘*Messages*’バッファにあ
     ります。

‘M-x magit-debug-git-executable’
     このコマンドは、使用可能で使用されている‘git’実行可能ファイルに関す
     る情報を含むバッファを表示し、‘exec-path’の問題を調査するときに役立
     ちます。

     こちらもご覧ください(*note Git実行ファイル::)。

‘M-x with-editor-debug’
     このコマンドは、使用可能で使用されている‘emacsclient’実行可能ファイ
     ルに関する情報を含むバッファを表示し、Magit(または‘with-editor’)が
     適切な‘emacsclient’実行可能ファイルを見つけられない理由を調査すると
     きに役立ちます。

     こちらもご覧ください(*note (with-editor)Debugging::)

どうぞこちらもご覧下さい *note FAQ::


File: magit.ja.info,  Node: Keystroke Index,  Next: Function and Command Index,  Prev: Debugging Tools,  Up: Top

Appendix C Keystroke Index
**************************

 [index ]
* Menu:

* !:                                     Gitを手動で実行.     (line  12)
* ! !:                                   Gitを手動で実行.     (line  18)
* ! a:                                   Gitを手動で実行.     (line  54)
* ! b:                                   Gitを手動で実行.     (line  57)
* ! g:                                   Gitを手動で実行.     (line  60)
* ! k:                                   Gitを手動で実行.     (line  51)
* ! m:                                   Gitを手動で実行.     (line  63)
* ! p:                                   Gitを手動で実行.     (line  26)
* ! s:                                   Gitを手動で実行.     (line  35)
* ! S:                                   Gitを手動で実行.     (line  39)
* $:                                     Viewing Git Output.  (line  17)
* +:                                     Log Buffer.          (line  65)
* + <1>:                                 Refreshing Diffs.    (line  60)
* -:                                     Log Buffer.          (line  68)
* - <1>:                                 Refreshing Diffs.    (line  56)
* 0:                                     Refreshing Diffs.    (line  64)
* 1:                                     Section Visibility.  (line  25)
* 2:                                     Section Visibility.  (line  25)
* 3:                                     Section Visibility.  (line  25)
* 4:                                     Section Visibility.  (line  25)
* 5:                                     Repository List.     (line 111)
* ::                                     Gitを手動で実行.     (line  26)
* =:                                     Log Buffer.          (line  60)
* >:                                     Sparse checkouts.    (line  16)
* > a:                                   Sparse checkouts.    (line  39)
* > d:                                   Sparse checkouts.    (line  50)
* > e:                                   Sparse checkouts.    (line  22)
* > r:                                   Sparse checkouts.    (line  44)
* > s:                                   Sparse checkouts.    (line  33)
* ^:                                     Section Movement.    (line  26)
* a:                                     Applying.            (line  36)
* A:                                     Cherry Picking.      (line   9)
* A A:                                   Cherry Picking.      (line  19)
* A a:                                   Cherry Picking.      (line  25)
* A A <1>:                               Cherry Picking.      (line  87)
* A a <1>:                               Cherry Picking.      (line  94)
* A d:                                   Cherry Picking.      (line  53)
* A h:                                   Cherry Picking.      (line  43)
* A n:                                   Cherry Picking.      (line  64)
* A s:                                   Cherry Picking.      (line  74)
* A s <1>:                               Cherry Picking.      (line  90)
* B:                                     Bisecting.           (line   9)
* b:                                     Blaming.             (line  98)
* b <1>:                                 Branch Commands.     (line  14)
* b <2>:                                 Editing Rebase Sequences.
                                                              (line  70)
* B B:                                   Bisecting.           (line  18)
* B b:                                   Bisecting.           (line  36)
* b b:                                   Branch Commands.     (line  52)
* b C:                                   Branch Commands.     (line  34)
* b c:                                   Branch Commands.     (line  68)
* B g:                                   Bisecting.           (line  40)
* B k:                                   Bisecting.           (line  50)
* b k:                                   Branch Commands.     (line 147)
* b l:                                   Branch Commands.     (line  74)
* B m:                                   Bisecting.           (line  44)
* b m:                                   Branch Commands.     (line 153)
* b n:                                   Branch Commands.     (line  59)
* B r:                                   Bisecting.           (line  55)
* B s:                                   Bisecting.           (line  29)
* b s:                                   Branch Commands.     (line  97)
* b S:                                   Branch Commands.     (line 125)
* b x:                                   Branch Commands.     (line 131)
* c:                                     Blaming.             (line 124)
* C:                                     Cloning Repository.  (line  22)
* c <1>:                                 コミット開始.        (line   9)
* c <2>:                                 Editing Rebase Sequences.
                                                              (line  59)
* C >:                                   Cloning Repository.  (line  42)
* c a:                                   コミット開始.        (line  20)
* c A:                                   コミット開始.        (line  65)
* C b:                                   Cloning Repository.  (line  49)
* C C:                                   Cloning Repository.  (line  31)
* c c:                                   コミット開始.        (line  16)
* C d:                                   Cloning Repository.  (line  61)
* C e:                                   Cloning Repository.  (line  67)
* c e:                                   コミット開始.        (line  23)
* c f:                                   コミット開始.        (line  43)
* c F:                                   コミット開始.        (line  51)
* C m:                                   Cloning Repository.  (line  53)
* C s:                                   Cloning Repository.  (line  35)
* c s:                                   コミット開始.        (line  54)
* c S:                                   コミット開始.        (line  62)
* c w:                                   コミット開始.        (line  33)
* C-<return>:                            Visiting Files and Blobs from a Diff.
                                                              (line  50)
* C-<tab>:                               Section Visibility.  (line  13)
* C-c C-a:                               Commit Pseudo Headers.
                                                              (line  17)
* C-c C-b:                               Log Buffer.          (line  22)
* C-c C-b <1>:                           Refreshing Diffs.    (line  79)
* C-c C-c:                               トランジェントコマンド.
                                                              (line  20)
* C-c C-c <1>:                           Select from Log.     (line  19)
* C-c C-c <2>:                           Editing Commit Messages.
                                                              (line  18)
* C-c C-c <3>:                           Editing Rebase Sequences.
                                                              (line   7)
* C-c C-d:                               Refreshing Diffs.    (line  71)
* C-c C-d <1>:                           Editing Commit Messages.
                                                              (line  54)
* C-c C-e:                               Commands Available in Diffs.
                                                              (line  26)
* C-c C-f:                               Log Buffer.          (line  25)
* C-c C-f <1>:                           Refreshing Diffs.    (line  82)
* C-c C-i:                               Commit Pseudo Headers.
                                                              (line  14)
* C-c C-k:                               Select from Log.     (line  23)
* C-c C-k <1>:                           Editing Commit Messages.
                                                              (line  23)
* C-c C-k <2>:                           Editing Rebase Sequences.
                                                              (line  12)
* C-c C-n:                               Log Buffer.          (line  28)
* C-c C-o:                               Commit Pseudo Headers.
                                                              (line  32)
* C-c C-p:                               Commit Pseudo Headers.
                                                              (line  35)
* C-c C-r:                               Commit Pseudo Headers.
                                                              (line  21)
* C-c C-s:                               Commit Pseudo Headers.
                                                              (line  25)
* C-c C-t:                               Commands Available in Diffs.
                                                              (line  16)
* C-c C-t <1>:                           Commit Pseudo Headers.
                                                              (line  28)
* C-c C-w:                               Using the Revision Stack.
                                                              (line   7)
* C-c M-g:                               Commands for Buffers Visiting Files.
                                                              (line  24)
* C-c M-g B:                             Blaming.             (line  19)
* C-c M-g b:                             Blaming.             (line  32)
* C-c M-g B <1>:                         Commands for Buffers Visiting Files.
                                                              (line  91)
* C-c M-g B b:                           Blaming.             (line  32)
* C-c M-g B e:                           Blaming.             (line  65)
* C-c M-g B f:                           Blaming.             (line  56)
* C-c M-g B r:                           Blaming.             (line  47)
* C-c M-g c:                             Commands for Buffers Visiting Files.
                                                              (line  41)
* C-c M-g D:                             Commands for Buffers Visiting Files.
                                                              (line  47)
* C-c M-g d:                             Commands for Buffers Visiting Files.
                                                              (line  58)
* C-c M-g e:                             Blaming.             (line  65)
* C-c M-g e <1>:                         Commands for Buffers Visiting Files.
                                                              (line 104)
* C-c M-g f:                             Blaming.             (line  56)
* C-c M-g L:                             Commands for Buffers Visiting Files.
                                                              (line  67)
* C-c M-g l:                             Commands for Buffers Visiting Files.
                                                              (line  78)
* C-c M-g p:                             Commands for Buffers Visiting Files.
                                                              (line 113)
* C-c M-g r:                             Blaming.             (line  47)
* C-c M-g s:                             Commands for Buffers Visiting Files.
                                                              (line  33)
* C-c M-g t:                             Commands for Buffers Visiting Files.
                                                              (line  84)
* C-c M-g u:                             Commands for Buffers Visiting Files.
                                                              (line  37)
* C-c M-i:                               Commit Pseudo Headers.
                                                              (line  39)
* C-c M-s:                               Editing Commit Messages.
                                                              (line  33)
* C-w:                                   Common Commands.     (line  22)
* C-x g:                                 Status Buffer.       (line  22)
* C-x u:                                 Editing Rebase Sequences.
                                                              (line  77)
* d:                                     Diffing.             (line  21)
* D:                                     Refreshing Diffs.    (line  12)
* d c:                                   Diffing.             (line  64)
* d d:                                   Diffing.             (line  28)
* D f:                                   Refreshing Diffs.    (line  41)
* D F:                                   Refreshing Diffs.    (line  45)
* D g:                                   Refreshing Diffs.    (line  19)
* d p:                                   Diffing.             (line  57)
* d r:                                   Diffing.             (line  31)
* D r:                                   Refreshing Diffs.    (line  37)
* d s:                                   Diffing.             (line  49)
* D s:                                   Refreshing Diffs.    (line  23)
* d t:                                   Diffing.             (line  69)
* D t:                                   Refreshing Diffs.    (line  34)
* d u:                                   Diffing.             (line  54)
* d w:                                   Diffing.             (line  44)
* D w:                                   Refreshing Diffs.    (line  28)
* DEL:                                   Log Buffer.          (line  51)
* DEL <1>:                               Commands Available in Diffs.
                                                              (line  57)
* DEL <2>:                               Blaming.             (line  87)
* DEL <3>:                               Editing Rebase Sequences.
                                                              (line  25)
* e:                                     Ediffing.            (line  11)
* E:                                     Ediffing.            (line  24)
* e <1>:                                 Editing Rebase Sequences.
                                                              (line  45)
* E c:                                   Ediffing.            (line 110)
* E i:                                   Ediffing.            (line 102)
* E m:                                   Ediffing.            (line  38)
* E m <1>:                               Ediffing.            (line  53)
* E r:                                   Ediffing.            (line  30)
* E s:                                   Ediffing.            (line  93)
* E t:                                   Ediffing.            (line  85)
* E u:                                   Ediffing.            (line  98)
* E w:                                   Ediffing.            (line 106)
* E z:                                   Ediffing.            (line 114)
* f:                                     Repository List.     (line 106)
* f <1>:                                 Editing Rebase Sequences.
                                                              (line  52)
* f <2>:                                 Fetching.            (line  11)
* F:                                     Pulling.             (line  11)
* f a:                                   Fetching.            (line  51)
* f C:                                   Branch Commands.     (line  34)
* F C:                                   Branch Commands.     (line  34)
* f e:                                   Fetching.            (line  39)
* F e:                                   Pulling.             (line  31)
* f m:                                   Fetching.            (line  54)
* f o:                                   Fetching.            (line  43)
* f p:                                   Fetching.            (line  18)
* F p:                                   Pulling.             (line  17)
* f r:                                   Fetching.            (line  47)
* f u:                                   Fetching.            (line  25)
* F u:                                   Pulling.             (line  24)
* g:                                     Automatic Refreshing of Magit Buffers.
                                                              (line  25)
* G:                                     Automatic Refreshing of Magit Buffers.
                                                              (line  34)
* H:                                     Section Types and Values.
                                                              (line  14)
* I:                                     Creating Repository. (line   7)
* j:                                     Log Buffer.          (line  32)
* j <1>:                                 Commands Available in Diffs.
                                                              (line  44)
* k:                                     Viewing Git Output.  (line  23)
* k <1>:                                 Applying.            (line  42)
* k <2>:                                 Editing Rebase Sequences.
                                                              (line  56)
* k <3>:                                 Stashing.            (line  89)
* l:                                     Logging.             (line  28)
* L:                                     Refreshing Logs.     (line  12)
* L <1>:                                 Log Buffer.          (line   7)
* L <2>:                                 Log Margin.          (line  49)
* l <1>:                                 Editing Rebase Sequences.
                                                              (line  94)
* l a:                                   Logging.             (line  63)
* l b:                                   Logging.             (line  59)
* L d:                                   Log Margin.          (line  64)
* L g:                                   Refreshing Logs.     (line  19)
* l h:                                   Logging.             (line  40)
* l H:                                   Reflog.              (line  18)
* l l:                                   Logging.             (line  35)
* l L:                                   Logging.             (line  56)
* L L:                                   Log Margin.          (line  58)
* L l:                                   Log Margin.          (line  61)
* l o:                                   Logging.             (line  50)
* l O:                                   Reflog.              (line  15)
* l r:                                   Reflog.              (line  12)
* L s:                                   Refreshing Logs.     (line  23)
* L t:                                   Refreshing Logs.     (line  34)
* l u:                                   Logging.             (line  43)
* L w:                                   Refreshing Logs.     (line  28)
* m:                                     Repository List.     (line 100)
* m <1>:                                 Merging.             (line  10)
* M:                                     Remote Commands.     (line  14)
* m a:                                   Merging.             (line  45)
* m a <1>:                               Merging.             (line  85)
* M a:                                   Remote Commands.     (line  51)
* M C:                                   Remote Commands.     (line  34)
* m e:                                   Merging.             (line  33)
* m i:                                   Merging.             (line  56)
* M k:                                   Remote Commands.     (line  63)
* m m:                                   Merging.             (line  20)
* m m <1>:                               Merging.             (line  81)
* m n:                                   Merging.             (line  39)
* m p:                                   Merging.             (line  74)
* M p:                                   Remote Commands.     (line  66)
* M P:                                   Remote Commands.     (line  70)
* M r:                                   Remote Commands.     (line  55)
* m s:                                   Merging.             (line  67)
* M u:                                   Remote Commands.     (line  59)
* M-1:                                   Section Visibility.  (line  31)
* M-2:                                   Section Visibility.  (line  31)
* M-3:                                   Section Visibility.  (line  31)
* M-4:                                   Section Visibility.  (line  31)
* M-<tab>:                               Section Visibility.  (line  16)
* M-n:                                   Section Movement.    (line  22)
* M-n <1>:                               Editing Commit Messages.
                                                              (line  41)
* M-n <2>:                               Editing Rebase Sequences.
                                                              (line  39)
* M-p:                                   Section Movement.    (line  18)
* M-p <1>:                               Editing Commit Messages.
                                                              (line  36)
* M-p <2>:                               Editing Rebase Sequences.
                                                              (line  36)
* M-w:                                   Blaming.             (line 117)
* M-w <1>:                               Common Commands.     (line  37)
* MM:                                    Editing Rebase Sequences.
                                                              (line 103)
* Mt:                                    Editing Rebase Sequences.
                                                              (line 110)
* n:                                     Section Movement.    (line  15)
* n <1>:                                 Blaming.             (line 101)
* N:                                     Blaming.             (line 104)
* n <2>:                                 Editing Rebase Sequences.
                                                              (line  33)
* n <3>:                                 Minor Mode for Buffers Visiting Blobs.
                                                              (line  16)
* o:                                     submodule用トランジェントコマンド.
                                                              (line   7)
* O:                                     Subtree.             (line   9)
* o a:                                   submodule用トランジェントコマンド.
                                                              (line  22)
* o d:                                   submodule用トランジェントコマンド.
                                                              (line  46)
* O e:                                   Subtree.             (line  41)
* O e p:                                 Subtree.             (line  55)
* O e s:                                 Subtree.             (line  59)
* o f:                                   submodule用トランジェントコマンド.
                                                              (line  52)
* O i:                                   Subtree.             (line  14)
* O i a:                                 Subtree.             (line  27)
* O i c:                                 Subtree.             (line  31)
* O i f:                                 Subtree.             (line  37)
* O i m:                                 Subtree.             (line  34)
* o l:                                   submodule用トランジェントコマンド.
                                                              (line  49)
* o p:                                   submodule用トランジェントコマンド.
                                                              (line  33)
* o r:                                   submodule用トランジェントコマンド.
                                                              (line  27)
* o s:                                   submodule用トランジェントコマンド.
                                                              (line  41)
* o u:                                   submodule用トランジェントコマンド.
                                                              (line  37)
* p:                                     Section Movement.    (line  11)
* p <1>:                                 Blaming.             (line 107)
* P:                                     Blaming.             (line 110)
* p <2>:                                 Editing Rebase Sequences.
                                                              (line  30)
* P <1>:                                 Pushing.             (line  11)
* p <3>:                                 Minor Mode for Buffers Visiting Blobs.
                                                              (line  13)
* P C:                                   Branch Commands.     (line  34)
* P e:                                   Pushing.             (line  34)
* P m:                                   Pushing.             (line  50)
* P o:                                   Pushing.             (line  38)
* P p:                                   Pushing.             (line  18)
* P r:                                   Pushing.             (line  42)
* P t:                                   Pushing.             (line  58)
* P T:                                   Pushing.             (line  65)
* P u:                                   Pushing.             (line  26)
* q:                                     Quitting Windows.    (line   7)
* q <1>:                                 Log Buffer.          (line  16)
* q <2>:                                 Blaming.             (line 113)
* q <3>:                                 Minor Mode for Buffers Visiting Blobs.
                                                              (line  19)
* r:                                     Rebasing.            (line  10)
* r <1>:                                 Editing Rebase Sequences.
                                                              (line  42)
* r a:                                   Rebasing.            (line 115)
* r e:                                   Rebasing.            (line  45)
* r e <1>:                               Rebasing.            (line 111)
* r f:                                   Rebasing.            (line  82)
* r i:                                   Rebasing.            (line  79)
* r k:                                   Rebasing.            (line  94)
* r m:                                   Rebasing.            (line  86)
* r p:                                   Rebasing.            (line  30)
* r r:                                   Rebasing.            (line 100)
* r s:                                   Rebasing.            (line  51)
* r s <1>:                               Rebasing.            (line 107)
* r u:                                   Rebasing.            (line  37)
* r w:                                   Rebasing.            (line  90)
* RET:                                   Repository List.     (line  97)
* RET <1>:                               References Buffer.   (line 151)
* RET <2>:                               Visiting Files and Blobs from a Diff.
                                                              (line   9)
* RET <3>:                               Blaming.             (line  76)
* RET <4>:                               Editing Rebase Sequences.
                                                              (line  16)
* s:                                     Staging and Unstaging.
                                                              (line  31)
* S:                                     Staging and Unstaging.
                                                              (line  39)
* s <1>:                                 Editing Rebase Sequences.
                                                              (line  48)
* S-<tab>:                               Section Visibility.  (line  19)
* SPC:                                   Log Buffer.          (line  42)
* SPC <1>:                               Commands Available in Diffs.
                                                              (line  54)
* SPC <2>:                               Blaming.             (line  79)
* SPC <3>:                               Editing Rebase Sequences.
                                                              (line  20)
* t:                                     Editing Rebase Sequences.
                                                              (line  98)
* t <1>:                                 Tagging.             (line   9)
* T:                                     Notes.               (line   9)
* T a:                                   Notes.               (line  48)
* T c:                                   Notes.               (line  45)
* t k:                                   Tagging.             (line  39)
* T m:                                   Notes.               (line  37)
* t p:                                   Tagging.             (line  45)
* T p:                                   Notes.               (line  30)
* t r:                                   Tagging.             (line  21)
* T r:                                   Notes.               (line  23)
* t t:                                   Tagging.             (line  16)
* T T:                                   Notes.               (line  16)
* TAB:                                   Section Visibility.  (line  10)
* u:                                     Repository List.     (line 103)
* u <1>:                                 Staging and Unstaging.
                                                              (line  47)
* U:                                     Staging and Unstaging.
                                                              (line  55)
* v:                                     Applying.            (line  49)
* V:                                     Reverting.           (line   7)
* V A:                                   Reverting.           (line  32)
* V a:                                   Reverting.           (line  39)
* V s:                                   Reverting.           (line  35)
* V V:                                   Reverting.           (line  17)
* V v:                                   Reverting.           (line  23)
* W:                                     Plain Patches.       (line   7)
* w:                                     Maildir Patches.     (line   9)
* w a:                                   Plain Patches.       (line  23)
* w a <1>:                               Maildir Patches.     (line  25)
* w a <2>:                               Maildir Patches.     (line  40)
* W c:                                   Plain Patches.       (line  14)
* w m:                                   Maildir Patches.     (line  22)
* W s:                                   Plain Patches.       (line  30)
* w s:                                   Maildir Patches.     (line  36)
* w w:                                   Maildir Patches.     (line  16)
* w w <1>:                               Maildir Patches.     (line  33)
* x:                                     Editing Rebase Sequences.
                                                              (line  62)
* x <1>:                                 Resetting.           (line   9)
* X f:                                   Resetting.           (line  46)
* X h:                                   Resetting.           (line  25)
* X i:                                   Resetting.           (line  35)
* X k:                                   Resetting.           (line  30)
* X m:                                   Resetting.           (line  15)
* X s:                                   Resetting.           (line  20)
* X w:                                   Resetting.           (line  41)
* X w <1>:                               Wip Modes.           (line  66)
* Y:                                     Cherries.            (line  18)
* y:                                     References Buffer.   (line   7)
* y <1>:                                 Editing Rebase Sequences.
                                                              (line  74)
* y c:                                   References Buffer.   (line  24)
* y o:                                   References Buffer.   (line  29)
* y r:                                   References Buffer.   (line  33)
* y y:                                   References Buffer.   (line  20)
* z:                                     Stashing.            (line   9)
* Z:                                     Worktree.            (line   9)
* z a:                                   Stashing.            (line  59)
* z b:                                   Stashing.            (line  77)
* z B:                                   Stashing.            (line  81)
* Z b:                                   Worktree.            (line  15)
* Z c:                                   Worktree.            (line  18)
* z f:                                   Stashing.            (line  86)
* Z g:                                   Worktree.            (line  28)
* z i:                                   Stashing.            (line  22)
* z I:                                   Stashing.            (line  47)
* z k:                                   Stashing.            (line  70)
* Z k:                                   Worktree.            (line  24)
* z l:                                   Stashing.            (line  93)
* Z m:                                   Worktree.            (line  21)
* z p:                                   Stashing.            (line  64)
* z v:                                   Stashing.            (line  74)
* z w:                                   Stashing.            (line  27)
* z W:                                   Stashing.            (line  52)
* z x:                                   Stashing.            (line  34)
* z z:                                   Stashing.            (line  16)
* z Z:                                   Stashing.            (line  41)


File: magit.ja.info,  Node: Function and Command Index,  Next: Variable Index,  Prev: Keystroke Index,  Up: Top

Appendix D Function and Command Index
*************************************

 [index ]
* Menu:

* bug-reference-mode:                    Commit Mode and Hooks.
                                                              (line  49)
* f (magit-repolist-fetch):              Repository List.     (line 106)
* forward-line:                          Editing Rebase Sequences.
                                                              (line  33)
* git-commit-ack:                        Commit Pseudo Headers.
                                                              (line  17)
* git-commit-cc:                         Commit Pseudo Headers.
                                                              (line  32)
* git-commit-check-style-conventions:    Commit Message Conventions.
                                                              (line  38)
* git-commit-insert-pseudo-header:       Commit Pseudo Headers.
                                                              (line  14)
* git-commit-next-message:               Editing Commit Messages.
                                                              (line  41)
* git-commit-prev-message:               Editing Commit Messages.
                                                              (line  36)
* git-commit-propertize-diff:            Commit Mode and Hooks.
                                                              (line  41)
* git-commit-reported:                   Commit Pseudo Headers.
                                                              (line  35)
* git-commit-review:                     Commit Pseudo Headers.
                                                              (line  21)
* git-commit-save-message:               Editing Commit Messages.
                                                              (line  33)
* git-commit-save-message <1>:           Commit Mode and Hooks.
                                                              (line  26)
* git-commit-setup-changelog-support:    Commit Mode and Hooks.
                                                              (line  29)
* git-commit-signoff:                    Commit Pseudo Headers.
                                                              (line  25)
* git-commit-suggested:                  Commit Pseudo Headers.
                                                              (line  39)
* git-commit-test:                       Commit Pseudo Headers.
                                                              (line  28)
* git-commit-turn-on-auto-fill:          Commit Mode and Hooks.
                                                              (line  33)
* git-commit-turn-on-flyspell:           Commit Mode and Hooks.
                                                              (line  37)
* git-rebase-backward-line:              Editing Rebase Sequences.
                                                              (line  30)
* git-rebase-break:                      Editing Rebase Sequences.
                                                              (line  70)
* git-rebase-edit:                       Editing Rebase Sequences.
                                                              (line  45)
* git-rebase-exec:                       Editing Rebase Sequences.
                                                              (line  62)
* git-rebase-fixup:                      Editing Rebase Sequences.
                                                              (line  52)
* git-rebase-insert:                     Editing Rebase Sequences.
                                                              (line  74)
* git-rebase-kill-line:                  Editing Rebase Sequences.
                                                              (line  56)
* git-rebase-label:                      Editing Rebase Sequences.
                                                              (line  94)
* git-rebase-merge:                      Editing Rebase Sequences.
                                                              (line 103)
* git-rebase-merge-toggle-editmsg:       Editing Rebase Sequences.
                                                              (line 110)
* git-rebase-move-line-down:             Editing Rebase Sequences.
                                                              (line  39)
* git-rebase-move-line-up:               Editing Rebase Sequences.
                                                              (line  36)
* git-rebase-pick:                       Editing Rebase Sequences.
                                                              (line  59)
* git-rebase-reset:                      Editing Rebase Sequences.
                                                              (line  98)
* git-rebase-reword:                     Editing Rebase Sequences.
                                                              (line  42)
* git-rebase-show-commit:                Editing Rebase Sequences.
                                                              (line  16)
* git-rebase-show-or-scroll-down:        Editing Rebase Sequences.
                                                              (line  25)
* git-rebase-show-or-scroll-up:          Editing Rebase Sequences.
                                                              (line  20)
* git-rebase-squash:                     Editing Rebase Sequences.
                                                              (line  48)
* git-rebase-undo:                       Editing Rebase Sequences.
                                                              (line  77)
* ido-enter-magit-status:                Status Buffer.       (line  92)
* magit-add-section-hook:                Section Hooks.       (line  20)
* magit-after-save-refresh-status:       Automatic Refreshing of Magit Buffers.
                                                              (line  53)
* magit-am:                              Maildir Patches.     (line   9)
* magit-am-abort:                        Maildir Patches.     (line  40)
* magit-am-apply-maildir:                Maildir Patches.     (line  22)
* magit-am-apply-patches:                Maildir Patches.     (line  16)
* magit-am-continue:                     Maildir Patches.     (line  33)
* magit-am-skip:                         Maildir Patches.     (line  36)
* magit-apply:                           Applying.            (line  36)
* magit-bisect:                          Bisecting.           (line   9)
* magit-bisect-bad:                      Bisecting.           (line  36)
* magit-bisect-good:                     Bisecting.           (line  40)
* magit-bisect-mark:                     Bisecting.           (line  44)
* magit-bisect-reset:                    Bisecting.           (line  55)
* magit-bisect-run:                      Bisecting.           (line  29)
* magit-bisect-skip:                     Bisecting.           (line  50)
* magit-bisect-start:                    Bisecting.           (line  18)
* magit-blame:                           Blaming.             (line  19)
* magit-blame <1>:                       Blaming.             (line  98)
* magit-blame <2>:                       Commands for Buffers Visiting Files.
                                                              (line  91)
* magit-blame-addition:                  Blaming.             (line  32)
* magit-blame-copy-hash:                 Blaming.             (line 117)
* magit-blame-cycle-style:               Blaming.             (line 124)
* magit-blame-echo:                      Blaming.             (line  65)
* magit-blame-next-chunk:                Blaming.             (line 101)
* magit-blame-next-chunk-same-commit:    Blaming.             (line 104)
* magit-blame-previous-chunk:            Blaming.             (line 107)
* magit-blame-previous-chunk-same-commit: Blaming.            (line 110)
* magit-blame-quit:                      Blaming.             (line 113)
* magit-blame-removal:                   Blaming.             (line  47)
* magit-blame-reverse:                   Blaming.             (line  56)
* magit-blob-next:                       Minor Mode for Buffers Visiting Blobs.
                                                              (line  16)
* magit-blob-previous:                   Commands for Buffers Visiting Files.
                                                              (line 113)
* magit-blob-previous <1>:               Minor Mode for Buffers Visiting Blobs.
                                                              (line  13)
* magit-branch:                          Branch Commands.     (line  14)
* magit-branch-and-checkout:             Branch Commands.     (line  68)
* magit-branch-checkout:                 Branch Commands.     (line  74)
* magit-branch-configure:                Branch Commands.     (line  34)
* magit-branch-create:                   Branch Commands.     (line  59)
* magit-branch-delete:                   Branch Commands.     (line 147)
* magit-branch-or-checkout:              Branch Commands.     (line 263)
* magit-branch-orphan:                   Branch Commands.     (line 259)
* magit-branch-rename:                   Branch Commands.     (line 153)
* magit-branch-reset:                    Branch Commands.     (line 131)
* magit-branch-shelve:                   Auxiliary Branch Commands.
                                                              (line   9)
* magit-branch-spinoff:                  Branch Commands.     (line  97)
* magit-branch-spinout:                  Branch Commands.     (line 125)
* magit-branch-unshelve:                 Auxiliary Branch Commands.
                                                              (line  19)
* magit-builtin-completing-read:         補完フレームワークのサポート.
                                                              (line  41)
* magit-bundle:                          Bundle.              (line   8)
* magit-call-git:                        Calling Git for Effect.
                                                              (line  27)
* magit-call-process:                    Calling Git for Effect.
                                                              (line  30)
* magit-cancel-section:                  Creating Sections.   (line  71)
* magit-checkout:                        Branch Commands.     (line  52)
* magit-cherry:                          Cherries.            (line  18)
* magit-cherry-apply:                    Cherry Picking.      (line  25)
* magit-cherry-copy:                     Cherry Picking.      (line  19)
* magit-cherry-donate:                   Cherry Picking.      (line  53)
* magit-cherry-harvest:                  Cherry Picking.      (line  43)
* magit-cherry-pick:                     Cherry Picking.      (line   9)
* magit-cherry-spinoff:                  Cherry Picking.      (line  74)
* magit-cherry-spinout:                  Cherry Picking.      (line  64)
* magit-clone:                           Cloning Repository.  (line  22)
* magit-clone-bare:                      Cloning Repository.  (line  49)
* magit-clone-mirror:                    Cloning Repository.  (line  53)
* magit-clone-regular:                   Cloning Repository.  (line  31)
* magit-clone-shallow:                   Cloning Repository.  (line  35)
* magit-clone-shallow-exclude:           Cloning Repository.  (line  67)
* magit-clone-shallow-since:             Cloning Repository.  (line  61)
* magit-clone-sparse:                    Cloning Repository.  (line  42)
* magit-commit:                          コミット開始.        (line   9)
* magit-commit <1>:                      Commands for Buffers Visiting Files.
                                                              (line  41)
* magit-commit-amend:                    コミット開始.        (line  20)
* magit-commit-augment:                  コミット開始.        (line  65)
* magit-commit-create:                   コミット開始.        (line  16)
* magit-commit-extend:                   コミット開始.        (line  23)
* magit-commit-fixup:                    コミット開始.        (line  43)
* magit-commit-instant-fixup:            コミット開始.        (line  51)
* magit-commit-instant-squash:           コミット開始.        (line  62)
* magit-commit-reword:                   コミット開始.        (line  33)
* magit-commit-squash:                   コミット開始.        (line  54)
* magit-completing-read:                 補完フレームワークのサポート.
                                                              (line  57)
* magit-copy-buffer-revision:            Common Commands.     (line  37)
* magit-copy-section-value:              Common Commands.     (line  22)
* magit-current-section:                 Section Selection.   (line   6)
* magit-cycle-margin-style:              Log Margin.          (line  61)
* magit-debug-git-executable:            Git実行ファイル.     (line  54)
* magit-debug-git-executable <1>:        Debugging Tools.     (line  58)
* magit-define-section-jumper:           Creating Sections.   (line  76)
* magit-describe-section:                Section Types and Values.
                                                              (line  14)
* magit-describe-section-briefly:        Section Types and Values.
                                                              (line  17)
* magit-describe-section-briefly <1>:    Matching Sections.   (line   7)
* magit-diff:                            Diffing.             (line  21)
* magit-diff <1>:                        Commands for Buffers Visiting Files.
                                                              (line  47)
* magit-diff-buffer-file:                Commands for Buffers Visiting Files.
                                                              (line  58)
* magit-diff-default-context:            Refreshing Diffs.    (line  64)
* magit-diff-dwim:                       Diffing.             (line  28)
* magit-diff-edit-hunk-commit:           Commands Available in Diffs.
                                                              (line  26)
* magit-diff-flip-revs:                  Refreshing Diffs.    (line  41)
* magit-diff-less-context:               Refreshing Diffs.    (line  56)
* magit-diff-more-context:               Refreshing Diffs.    (line  60)
* magit-diff-paths:                      Diffing.             (line  57)
* magit-diff-range:                      Diffing.             (line  31)
* magit-diff-refresh:                    Refreshing Diffs.    (line  12)
* magit-diff-refresh <1>:                Refreshing Diffs.    (line  19)
* magit-diff-save-default-arguments:     Refreshing Diffs.    (line  28)
* magit-diff-scope:                      Matching Sections.   (line 108)
* magit-diff-set-default-arguments:      Refreshing Diffs.    (line  23)
* magit-diff-show-or-scroll-down:        Log Buffer.          (line  51)
* magit-diff-show-or-scroll-down <1>:    Blaming.             (line  87)
* magit-diff-show-or-scroll-up:          Log Buffer.          (line  42)
* magit-diff-show-or-scroll-up <1>:      Blaming.             (line  79)
* magit-diff-staged:                     Diffing.             (line  49)
* magit-diff-switch-range-type:          Refreshing Diffs.    (line  37)
* magit-diff-toggle-file-filter:         Refreshing Diffs.    (line  45)
* magit-diff-toggle-refine-hunk:         Refreshing Diffs.    (line  34)
* magit-diff-trace-definition:           Commands Available in Diffs.
                                                              (line  16)
* magit-diff-type:                       Matching Sections.   (line  87)
* magit-diff-unstaged:                   Diffing.             (line  54)
* magit-diff-visit-file:                 Visiting Files and Blobs from a Diff.
                                                              (line   9)
* magit-diff-visit-file-other-frame:     Visiting Files and Blobs from a Diff.
                                                              (line  69)
* magit-diff-visit-file-other-window:    Visiting Files and Blobs from a Diff.
                                                              (line  68)
* magit-diff-visit-file-worktree:        Visiting Files and Blobs from a Diff.
                                                              (line  50)
* magit-diff-visit-worktree-file-other-frame: Visiting Files and Blobs from a Diff.
                                                              (line  71)
* magit-diff-visit-worktree-file-other-window: Visiting Files and Blobs from a Diff.
                                                              (line  70)
* magit-diff-while-committing:           Refreshing Diffs.    (line  71)
* magit-diff-while-committing <1>:       Editing Commit Messages.
                                                              (line  54)
* magit-diff-working-tree:               Diffing.             (line  44)
* magit-disable-section-inserter:        Per-Repository Configuration.
                                                              (line  32)
* magit-discard:                         Applying.            (line  42)
* magit-dispatch:                        トランジェントコマンド.
                                                              (line  20)
* magit-display-buffer:                  バッファの切り替え.  (line   6)
* magit-display-buffer-fullcolumn-most-v1: バッファの切り替え.
                                                              (line  70)
* magit-display-buffer-fullframe-status-topleft-v1: バッファの切り替え.
                                                              (line  61)
* magit-display-buffer-fullframe-status-v1: バッファの切り替え.
                                                              (line  56)
* magit-display-buffer-same-window-except-diff-v1: バッファの切り替え.
                                                              (line  50)
* magit-display-buffer-traditional:      バッファの切り替え.  (line  43)
* magit-display-repository-buffer:       Common Commands.     (line   9)
* magit-ediff:                           Ediffing.            (line  24)
* magit-ediff-compare:                   Ediffing.            (line  30)
* magit-ediff-dwim:                      Ediffing.            (line  11)
* magit-ediff-resolve-all:               Ediffing.            (line  53)
* magit-ediff-resolve-rest:              Ediffing.            (line  38)
* magit-ediff-show-commit:               Ediffing.            (line 110)
* magit-ediff-show-staged:               Ediffing.            (line 102)
* magit-ediff-show-stash:                Ediffing.            (line 114)
* magit-ediff-show-unstaged:             Ediffing.            (line  98)
* magit-ediff-show-working-tree:         Ediffing.            (line 106)
* magit-ediff-stage:                     Ediffing.            (line  93)
* magit-edit-line-commit:                Commands for Buffers Visiting Files.
                                                              (line 104)
* magit-emacs-Q-command:                 Debugging Tools.     (line  16)
* magit-fetch:                           Fetching.            (line  11)
* magit-fetch-all:                       Fetching.            (line  51)
* magit-fetch-branch:                    Fetching.            (line  43)
* magit-fetch-from-pushremote:           Fetching.            (line  18)
* magit-fetch-from-upstream:             Fetching.            (line  25)
* magit-fetch-modules:                   submodule用トランジェントコマンド.
                                                              (line  52)
* magit-fetch-other:                     Fetching.            (line  39)
* magit-fetch-refspec:                   Fetching.            (line  47)
* magit-file-checkout:                   Resetting.           (line  46)
* magit-file-checkout <1>:               Commands for Buffers Visiting Files.
                                                              (line 128)
* magit-file-delete:                     Commands for Buffers Visiting Files.
                                                              (line 121)
* magit-file-dispatch:                   Commands for Buffers Visiting Files.
                                                              (line  24)
* magit-file-rename:                     Commands for Buffers Visiting Files.
                                                              (line 118)
* magit-file-untrack:                    Commands for Buffers Visiting Files.
                                                              (line 124)
* magit-find-file:                       General-Purpose Visit Commands.
                                                              (line  10)
* magit-find-file-other-frame:           General-Purpose Visit Commands.
                                                              (line  20)
* magit-find-file-other-window:          General-Purpose Visit Commands.
                                                              (line  15)
* magit-generate-buffer-name-default-function: バッファの名付け.
                                                              (line  16)
* magit-get-section:                     Matching Sections.   (line  14)
* magit-git:                             Calling Git for Effect.
                                                              (line  44)
* magit-git-command:                     Gitを手動で実行.     (line  26)
* magit-git-command-topdir:              Gitを手動で実行.     (line  18)
* magit-git-exit-code:                   Getting a Value from Git.
                                                              (line  10)
* magit-git-failure:                     Getting a Value from Git.
                                                              (line  17)
* magit-git-false:                       Getting a Value from Git.
                                                              (line  25)
* magit-git-insert:                      Getting a Value from Git.
                                                              (line  29)
* magit-git-items:                       Getting a Value from Git.
                                                              (line  41)
* magit-git-lines:                       Getting a Value from Git.
                                                              (line  37)
* magit-git-mergetool:                   Gitを手動で実行.     (line  63)
* magit-git-mergetool <1>:               Ediffing.            (line  85)
* magit-git-str:                         Getting a Value from Git.
                                                              (line  74)
* magit-git-string:                      Getting a Value from Git.
                                                              (line  32)
* magit-git-success:                     Getting a Value from Git.
                                                              (line  13)
* magit-git-true:                        Getting a Value from Git.
                                                              (line  21)
* magit-git-wash:                        Calling Git for Effect.
                                                              (line  48)
* magit-go-backward:                     Log Buffer.          (line  22)
* magit-go-backward <1>:                 Refreshing Diffs.    (line  79)
* magit-go-forward:                      Log Buffer.          (line  25)
* magit-go-forward <1>:                  Refreshing Diffs.    (line  82)
* magit-hunk-set-window-start:           Section Movement.    (line  44)
* magit-ido-completing-read:             補完フレームワークのサポート.
                                                              (line  46)
* magit-init:                            Creating Repository. (line   7)
* magit-insert-am-sequence:              Status Sections.     (line  25)
* magit-insert-assumed-unchanged-files:  Status Sections.     (line 101)
* magit-insert-bisect-log:               Status Sections.     (line  40)
* magit-insert-bisect-output:            Status Sections.     (line  33)
* magit-insert-bisect-rest:              Status Sections.     (line  37)
* magit-insert-diff-filter-header:       Status Header Sections.
                                                              (line  35)
* magit-insert-error-header:             Status Header Sections.
                                                              (line  26)
* magit-insert-head-branch-header:       Status Header Sections.
                                                              (line  38)
* magit-insert-heading:                  Creating Sections.   (line  45)
* magit-insert-ignored-files:            Status Sections.     (line  85)
* magit-insert-local-branches:           References Sections. (line  16)
* magit-insert-merge-log:                Status Sections.     (line  17)
* magit-insert-modules:                  Status Module Sections.
                                                              (line  12)
* magit-insert-modules-overview:         Status Module Sections.
                                                              (line  30)
* magit-insert-modules-unpulled-from-pushremote: Status Module Sections.
                                                              (line  46)
* magit-insert-modules-unpulled-from-upstream: Status Module Sections.
                                                              (line  41)
* magit-insert-modules-unpushed-to-pushremote: Status Module Sections.
                                                              (line  56)
* magit-insert-modules-unpushed-to-upstream: Status Module Sections.
                                                              (line  51)
* magit-insert-push-branch-header:       Status Header Sections.
                                                              (line  46)
* magit-insert-rebase-sequence:          Status Sections.     (line  21)
* magit-insert-recent-commits:           Status Sections.     (line 114)
* magit-insert-remote-branches:          References Sections. (line  19)
* magit-insert-remote-header:            Status Header Sections.
                                                              (line  59)
* magit-insert-repo-header:              Status Header Sections.
                                                              (line  56)
* magit-insert-section:                  Creating Sections.   (line   6)
* magit-insert-sequencer-sequence:       Status Sections.     (line  29)
* magit-insert-skip-worktree-files:      Status Sections.     (line  95)
* magit-insert-staged-changes:           Status Sections.     (line  55)
* magit-insert-stashes:                  Status Sections.     (line  58)
* magit-insert-status-headers:           Status Header Sections.
                                                              (line  12)
* magit-insert-tags:                     References Sections. (line  23)
* magit-insert-tags-header:              Status Header Sections.
                                                              (line  50)
* magit-insert-tracked-files:            Status Sections.     (line  82)
* magit-insert-unpulled-cherries:        Status Sections.     (line 124)
* magit-insert-unpulled-from-pushremote: Status Sections.     (line  68)
* magit-insert-unpulled-from-upstream:   Status Sections.     (line  64)
* magit-insert-unpulled-or-recent-commits: Status Sections.   (line 107)
* magit-insert-unpushed-cherries:        Status Sections.     (line 131)
* magit-insert-unpushed-to-pushremote:   Status Sections.     (line  76)
* magit-insert-unpushed-to-upstream:     Status Sections.     (line  72)
* magit-insert-unstaged-changes:         Status Sections.     (line  51)
* magit-insert-untracked-files:          Status Sections.     (line  43)
* magit-insert-upstream-branch-header:   Status Header Sections.
                                                              (line  42)
* magit-insert-user-header:              Status Header Sections.
                                                              (line  66)
* magit-jump-to-diffstat-or-diff:        Commands Available in Diffs.
                                                              (line  44)
* magit-kill-this-buffer:                Minor Mode for Buffers Visiting Blobs.
                                                              (line  19)
* magit-list-repositories:               Repository List.     (line   6)
* magit-list-submodules:                 Listing Submodules.  (line  13)
* magit-list-submodules <1>:             submodule用トランジェントコマンド.
                                                              (line  49)
* magit-log:                             Logging.             (line  28)
* magit-log <1>:                         Commands for Buffers Visiting Files.
                                                              (line  67)
* magit-log-all:                         Logging.             (line  63)
* magit-log-all-branches:                Logging.             (line  59)
* magit-log-branches:                    Logging.             (line  56)
* magit-log-buffer-file:                 Commands for Buffers Visiting Files.
                                                              (line  78)
* magit-log-bury-buffer:                 Log Buffer.          (line  16)
* magit-log-current:                     Logging.             (line  35)
* magit-log-double-commit-limit:         Log Buffer.          (line  65)
* magit-log-half-commit-limit:           Log Buffer.          (line  68)
* magit-log-head:                        Logging.             (line  40)
* magit-log-maybe-show-more-commits:     Section Movement.    (line  56)
* magit-log-maybe-update-blob-buffer:    Section Movement.    (line  69)
* magit-log-maybe-update-revision-buffer: Section Movement.   (line  63)
* magit-log-move-to-parent:              Log Buffer.          (line  28)
* magit-log-move-to-revision:            Log Buffer.          (line  32)
* magit-log-other:                       Logging.             (line  50)
* magit-log-refresh:                     Refreshing Logs.     (line  12)
* magit-log-refresh <1>:                 Refreshing Logs.     (line  19)
* magit-log-refresh <2>:                 Log Buffer.          (line   7)
* magit-log-related:                     Logging.             (line  43)
* magit-log-save-default-arguments:      Refreshing Logs.     (line  28)
* magit-log-select-pick:                 Select from Log.     (line  19)
* magit-log-select-quit:                 Select from Log.     (line  23)
* magit-log-set-default-arguments:       Refreshing Logs.     (line  23)
* magit-log-toggle-commit-limit:         Log Buffer.          (line  60)
* magit-log-trace-definition:            Commands for Buffers Visiting Files.
                                                              (line  84)
* magit-margin-settings:                 Log Margin.          (line  49)
* magit-maybe-set-dedicated:             バッファの切り替え.  (line  91)
* magit-merge:                           Merging.             (line  10)
* magit-merge <1>:                       Merging.             (line  81)
* magit-merge-abort:                     Merging.             (line  85)
* magit-merge-absorb:                    Merging.             (line  45)
* magit-merge-editmsg:                   Merging.             (line  33)
* magit-merge-into:                      Merging.             (line  56)
* magit-merge-nocommit:                  Merging.             (line  39)
* magit-merge-plain:                     Merging.             (line  20)
* magit-merge-preview:                   Merging.             (line  74)
* magit-merge-squash:                    Merging.             (line  67)
* magit-mode-bury-buffer:                Quitting Windows.    (line   7)
* magit-mode-display-buffer:             Refreshing Buffers.  (line  31)
* magit-mode-quit-window:                Quitting Windows.    (line  32)
* magit-mode-setup:                      Refreshing Buffers.  (line  17)
* magit-notes:                           Notes.               (line   9)
* magit-notes-edit:                      Notes.               (line  16)
* magit-notes-merge:                     Notes.               (line  37)
* magit-notes-merge-abort:               Notes.               (line  48)
* magit-notes-merge-commit:              Notes.               (line  45)
* magit-notes-prune:                     Notes.               (line  30)
* magit-notes-remove:                    Notes.               (line  23)
* magit-patch:                           Plain Patches.       (line   7)
* magit-patch-apply:                     Plain Patches.       (line  23)
* magit-patch-apply <1>:                 Maildir Patches.     (line  25)
* magit-patch-create:                    Plain Patches.       (line  14)
* magit-patch-save:                      Plain Patches.       (line  30)
* magit-pop-revision-stack:              Using the Revision Stack.
                                                              (line   7)
* magit-process:                         Viewing Git Output.  (line  17)
* magit-process-file:                    Getting a Value from Git.
                                                              (line  56)
* magit-process-git:                     Getting a Value from Git.
                                                              (line  50)
* magit-process-kill:                    Viewing Git Output.  (line  23)
* magit-pull:                            Pulling.             (line  11)
* magit-pull-branch:                     Pulling.             (line  31)
* magit-pull-from-pushremote:            Pulling.             (line  17)
* magit-pull-from-upstream:              Pulling.             (line  24)
* magit-push:                            Pushing.             (line  11)
* magit-push-current:                    Pushing.             (line  34)
* magit-push-current-to-pushremote:      Pushing.             (line  18)
* magit-push-current-to-upstream:        Pushing.             (line  26)
* magit-push-implicitly:                 Pushing.             (line  81)
* magit-push-matching:                   Pushing.             (line  50)
* magit-push-other:                      Pushing.             (line  38)
* magit-push-refspecs:                   Pushing.             (line  42)
* magit-push-tag:                        Pushing.             (line  65)
* magit-push-tags:                       Pushing.             (line  58)
* magit-push-to-remote:                  Pushing.             (line  98)
* magit-rebase:                          Rebasing.            (line  10)
* magit-rebase-abort:                    Rebasing.            (line 115)
* magit-rebase-autosquash:               Rebasing.            (line  82)
* magit-rebase-branch:                   Rebasing.            (line  45)
* magit-rebase-continue:                 Rebasing.            (line 100)
* magit-rebase-edit:                     Rebasing.            (line 111)
* magit-rebase-edit-commit:              Rebasing.            (line  86)
* magit-rebase-interactive:              Rebasing.            (line  79)
* magit-rebase-onto-pushremote:          Rebasing.            (line  30)
* magit-rebase-onto-upstream:            Rebasing.            (line  37)
* magit-rebase-remove-commit:            Rebasing.            (line  94)
* magit-rebase-reword-commit:            Rebasing.            (line  90)
* magit-rebase-skip:                     Rebasing.            (line 107)
* magit-rebase-subset:                   Rebasing.            (line  51)
* magit-reflog-current:                  Reflog.              (line  12)
* magit-reflog-head:                     Reflog.              (line  18)
* magit-reflog-other:                    Reflog.              (line  15)
* magit-refresh:                         Automatic Refreshing of Magit Buffers.
                                                              (line  25)
* magit-refresh-all:                     Automatic Refreshing of Magit Buffers.
                                                              (line  34)
* magit-refs-set-show-commit-count:      References Buffer.   (line  33)
* magit-region-sections:                 Section Selection.   (line   9)
* magit-region-values:                   Section Selection.   (line  34)
* magit-remote:                          Remote Commands.     (line  14)
* magit-remote-add:                      Remote Commands.     (line  51)
* magit-remote-configure:                Remote Commands.     (line  34)
* magit-remote-prune:                    Remote Commands.     (line  66)
* magit-remote-prune-refspecs:           Remote Commands.     (line  70)
* magit-remote-remove:                   Remote Commands.     (line  63)
* magit-remote-rename:                   Remote Commands.     (line  55)
* magit-remote-set-url:                  Remote Commands.     (line  59)
* magit-repolist-column-branch:          Repository List.     (line  49)
* magit-repolist-column-branches:        Repository List.     (line  56)
* magit-repolist-column-flag:            Repository List.     (line  62)
* magit-repolist-column-ident:           Repository List.     (line  39)
* magit-repolist-column-path:            Repository List.     (line  43)
* magit-repolist-column-stashes:         Repository List.     (line  59)
* magit-repolist-column-unpulled-from-pushremote: Repository List.
                                                              (line  82)
* magit-repolist-column-unpulled-from-upstream: Repository List.
                                                              (line  78)
* magit-repolist-column-unpushed-to-pushremote: Repository List.
                                                              (line  90)
* magit-repolist-column-unpushed-to-upstream: Repository List.
                                                              (line  86)
* magit-repolist-column-upstream:        Repository List.     (line  52)
* magit-repolist-column-version:         Repository List.     (line  46)
* magit-repolist-find-file-other-frame:  Repository List.     (line 111)
* magit-repolist-mark:                   Repository List.     (line 100)
* magit-repolist-status:                 Repository List.     (line  97)
* magit-repolist-unmark:                 Repository List.     (line 103)
* magit-reset-hard:                      Resetting.           (line  25)
* magit-reset-index:                     Staging and Unstaging.
                                                              (line  85)
* magit-reset-index <1>:                 Resetting.           (line  35)
* magit-reset-keep:                      Resetting.           (line  30)
* magit-reset-mixed:                     Resetting.           (line  15)
* magit-reset-quickly:                   Resetting.           (line   9)
* magit-reset-soft:                      Resetting.           (line  20)
* magit-reset-worktree:                  Resetting.           (line  41)
* magit-reset-worktree <1>:              Wip Modes.           (line  66)
* magit-restore-window-configuration:    Quitting Windows.    (line  22)
* magit-reverse:                         Applying.            (line  49)
* magit-reverse-in-index:                Staging and Unstaging.
                                                              (line  63)
* magit-revert:                          Reverting.           (line   7)
* magit-revert-and-commit:               Reverting.           (line  17)
* magit-revert-no-commit:                Reverting.           (line  23)
* magit-run:                             Gitを手動で実行.     (line  12)
* magit-run-git:                         Calling Git for Effect.
                                                              (line  33)
* magit-run-git-async:                   Calling Git for Effect.
                                                              (line  57)
* magit-run-git-gui:                     Gitを手動で実行.     (line  60)
* magit-run-git-with-editor:             Calling Git for Effect.
                                                              (line  70)
* magit-run-git-with-input:              Calling Git for Effect.
                                                              (line  36)
* magit-run-gitk:                        Gitを手動で実行.     (line  51)
* magit-run-gitk-all:                    Gitを手動で実行.     (line  54)
* magit-run-gitk-branches:               Gitを手動で実行.     (line  57)
* magit-save-window-configuration:       バッファの切り替え.  (line  82)
* magit-section-backward:                Section Movement.    (line  11)
* magit-section-backward-siblings:       Section Movement.    (line  18)
* magit-section-case:                    Matching Sections.   (line  66)
* magit-section-cycle:                   Section Visibility.  (line  13)
* magit-section-cycle-diffs:             Section Visibility.  (line  16)
* magit-section-cycle-global:            Section Visibility.  (line  19)
* magit-section-forward:                 Section Movement.    (line  15)
* magit-section-forward-siblings:        Section Movement.    (line  22)
* magit-section-hide:                    Section Visibility.  (line  41)
* magit-section-hide-children:           Section Visibility.  (line  53)
* magit-section-ident:                   Matching Sections.   (line  10)
* magit-section-match:                   Matching Sections.   (line  18)
* magit-section-set-window-start:        Section Movement.    (line  50)
* magit-section-show:                    Section Visibility.  (line  38)
* magit-section-show-children:           Section Visibility.  (line  48)
* magit-section-show-headings:           Section Visibility.  (line  44)
* magit-section-show-level-1:            Section Visibility.  (line  25)
* magit-section-show-level-1-all:        Section Visibility.  (line  31)
* magit-section-show-level-2:            Section Visibility.  (line  25)
* magit-section-show-level-2-all:        Section Visibility.  (line  31)
* magit-section-show-level-3:            Section Visibility.  (line  25)
* magit-section-show-level-3-all:        Section Visibility.  (line  31)
* magit-section-show-level-4:            Section Visibility.  (line  25)
* magit-section-show-level-4-all:        Section Visibility.  (line  31)
* magit-section-toggle:                  Section Visibility.  (line  10)
* magit-section-toggle-children:         Section Visibility.  (line  56)
* magit-section-up:                      Section Movement.    (line  26)
* magit-section-value-if:                Matching Sections.   (line  56)
* magit-sequence-abort:                  Cherry Picking.      (line  94)
* magit-sequence-abort <1>:              Reverting.           (line  39)
* magit-sequence-continue:               Cherry Picking.      (line  87)
* magit-sequence-continue <1>:           Reverting.           (line  32)
* magit-sequence-skip:                   Cherry Picking.      (line  90)
* magit-sequence-skip <1>:               Reverting.           (line  35)
* magit-shell-command:                   Gitを手動で実行.     (line  39)
* magit-shell-command-topdir:            Gitを手動で実行.     (line  35)
* magit-show-commit:                     Diffing.             (line  64)
* magit-show-commit <1>:                 Blaming.             (line  76)
* magit-show-refs:                       References Buffer.   (line   7)
* magit-show-refs-current:               References Buffer.   (line  24)
* magit-show-refs-head:                  References Buffer.   (line  20)
* magit-show-refs-other:                 References Buffer.   (line  29)
* magit-snapshot-both:                   Stashing.            (line  41)
* magit-snapshot-index:                  Stashing.            (line  47)
* magit-snapshot-worktree:               Stashing.            (line  52)
* magit-sparse-checkout:                 Sparse checkouts.    (line  16)
* magit-sparse-checkout-add:             Sparse checkouts.    (line  39)
* magit-sparse-checkout-disable:         Sparse checkouts.    (line  50)
* magit-sparse-checkout-enable:          Sparse checkouts.    (line  22)
* magit-sparse-checkout-reapply:         Sparse checkouts.    (line  44)
* magit-sparse-checkout-set:             Sparse checkouts.    (line  33)
* magit-stage:                           Staging and Unstaging.
                                                              (line  31)
* magit-stage-file:                      Staging from File-Visiting Buffers.
                                                              (line  12)
* magit-stage-file <1>:                  Commands for Buffers Visiting Files.
                                                              (line  33)
* magit-stage-modified:                  Staging and Unstaging.
                                                              (line  39)
* magit-start-git:                       Calling Git for Effect.
                                                              (line  81)
* magit-start-process:                   Calling Git for Effect.
                                                              (line 100)
* magit-stash:                           Stashing.            (line   9)
* magit-stash-apply:                     Stashing.            (line  59)
* magit-stash-both:                      Stashing.            (line  16)
* magit-stash-branch:                    Stashing.            (line  77)
* magit-stash-branch-here:               Stashing.            (line  81)
* magit-stash-clear:                     Stashing.            (line  89)
* magit-stash-drop:                      Stashing.            (line  70)
* magit-stash-format-patch:              Stashing.            (line  86)
* magit-stash-index:                     Stashing.            (line  22)
* magit-stash-keep-index:                Stashing.            (line  34)
* magit-stash-list:                      Stashing.            (line  93)
* magit-stash-pop:                       Stashing.            (line  64)
* magit-stash-show:                      Diffing.             (line  69)
* magit-stash-show <1>:                  Stashing.            (line  74)
* magit-stash-worktree:                  Stashing.            (line  27)
* magit-stashes-maybe-update-stash-buffer: Section Movement.  (line  89)
* magit-status:                          Status Buffer.       (line  22)
* magit-status-maybe-update-blob-buffer: Section Movement.    (line  84)
* magit-status-maybe-update-revision-buffer: Section Movement.
                                                              (line  74)
* magit-status-maybe-update-stash-buffer: Section Movement.   (line  79)
* magit-status-quick:                    Status Buffer.       (line  68)
* magit-submodule:                       submodule用トランジェントコマンド.
                                                              (line   7)
* magit-submodule-add:                   submodule用トランジェントコマンド.
                                                              (line  22)
* magit-submodule-fetch:                 Fetching.            (line  54)
* magit-submodule-populate:              submodule用トランジェントコマンド.
                                                              (line  33)
* magit-submodule-register:              submodule用トランジェントコマンド.
                                                              (line  27)
* magit-submodule-synchronize:           submodule用トランジェントコマンド.
                                                              (line  41)
* magit-submodule-unpopulate:            submodule用トランジェントコマンド.
                                                              (line  46)
* magit-submodule-update:                submodule用トランジェントコマンド.
                                                              (line  37)
* magit-subtree:                         Subtree.             (line   9)
* magit-subtree-add:                     Subtree.             (line  27)
* magit-subtree-add-commit:              Subtree.             (line  31)
* magit-subtree-export:                  Subtree.             (line  41)
* magit-subtree-import:                  Subtree.             (line  14)
* magit-subtree-merge:                   Subtree.             (line  34)
* magit-subtree-pull:                    Subtree.             (line  37)
* magit-subtree-push:                    Subtree.             (line  55)
* magit-subtree-split:                   Subtree.             (line  59)
* magit-switch-to-repository-buffer:     Common Commands.     (line   6)
* magit-switch-to-repository-buffer-other-frame: Common Commands.
                                                              (line   8)
* magit-switch-to-repository-buffer-other-window: Common Commands.
                                                              (line   7)
* magit-tag:                             Tagging.             (line   9)
* magit-tag-create:                      Tagging.             (line  16)
* magit-tag-delete:                      Tagging.             (line  39)
* magit-tag-prune:                       Tagging.             (line  45)
* magit-tag-release:                     Tagging.             (line  21)
* magit-toggle-buffer-lock:              Modes and Buffers.   (line  19)
* magit-toggle-git-debug:                Debugging Tools.     (line  29)
* magit-toggle-margin:                   Refreshing Logs.     (line  34)
* magit-toggle-margin <1>:               Log Margin.          (line  58)
* magit-toggle-margin-details:           Log Margin.          (line  64)
* magit-toggle-verbose-refresh:          Debugging Tools.     (line  52)
* magit-unstage:                         Staging and Unstaging.
                                                              (line  47)
* magit-unstage-all:                     Staging and Unstaging.
                                                              (line  55)
* magit-unstage-file:                    Staging from File-Visiting Buffers.
                                                              (line  20)
* magit-unstage-file <1>:                Commands for Buffers Visiting Files.
                                                              (line  37)
* magit-version:                         Git実行ファイル.     (line  59)
* magit-version <1>:                     Debugging Tools.     (line  11)
* magit-visit-ref:                       References Buffer.   (line 151)
* magit-wip-commit:                      Wip Modes.           (line  87)
* magit-wip-log:                         Wip Modes.           (line  48)
* magit-wip-log-current:                 Wip Modes.           (line  56)
* magit-worktree:                        Worktree.            (line   9)
* magit-worktree-branch:                 Worktree.            (line  18)
* magit-worktree-checkout:               Worktree.            (line  15)
* magit-worktree-delete:                 Worktree.            (line  24)
* magit-worktree-move:                   Worktree.            (line  21)
* magit-worktree-status:                 Worktree.            (line  28)
* scroll-down:                           Commands Available in Diffs.
                                                              (line  57)
* scroll-up:                             Commands Available in Diffs.
                                                              (line  54)
* with-editor-cancel:                    Editing Commit Messages.
                                                              (line  23)
* with-editor-cancel <1>:                Editing Rebase Sequences.
                                                              (line  12)
* with-editor-debug:                     Debugging Tools.     (line  65)
* with-editor-finish:                    Editing Commit Messages.
                                                              (line  18)
* with-editor-finish <1>:                Editing Rebase Sequences.
                                                              (line   7)
* with-editor-usage-message:             Commit Mode and Hooks.
                                                              (line  52)


File: magit.ja.info,  Node: Variable Index,  Prev: Function and Command Index,  Up: Top

Appendix E Variable Index
*************************

 [index ]
* Menu:

* auto-revert-buffer-list-filter:        Automatic Reverting of File-Visiting Buffers.
                                                              (line  78)
* auto-revert-interval:                  Automatic Reverting of File-Visiting Buffers.
                                                              (line  74)
* auto-revert-mode:                      Automatic Reverting of File-Visiting Buffers.
                                                              (line  62)
* auto-revert-stop-on-user-input:        Automatic Reverting of File-Visiting Buffers.
                                                              (line  70)
* auto-revert-use-notify:                Automatic Reverting of File-Visiting Buffers.
                                                              (line  51)
* auto-revert-verbose:                   Automatic Reverting of File-Visiting Buffers.
                                                              (line  97)
* branch.autoSetupMerge:                 Branch Git Variables.
                                                              (line  71)
* branch.autoSetupRebase:                Branch Git Variables.
                                                              (line  83)
* branch.NAME.description:               Branch Git Variables.
                                                              (line  43)
* branch.NAME.merge:                     Branch Git Variables.
                                                              (line  11)
* branch.NAME.pushRemote:                Branch Git Variables.
                                                              (line  31)
* branch.NAME.rebase:                    Branch Git Variables.
                                                              (line  21)
* branch.NAME.remote:                    Branch Git Variables.
                                                              (line  16)
* core.notesRef:                         Notes.               (line  54)
* git-commit-fill-column:                Commit Message Conventions.
                                                              (line  17)
* git-commit-finish-query-functions:     Commit Message Conventions.
                                                              (line  21)
* git-commit-known-pseudo-headers:       Commit Pseudo Headers.
                                                              (line  10)
* git-commit-major-mode:                 Commit Mode and Hooks.
                                                              (line  12)
* git-commit-post-finish-hook:           Commit Mode and Hooks.
                                                              (line  55)
* git-commit-setup-hook:                 Commit Mode and Hooks.
                                                              (line  21)
* git-commit-style-convention-checks:    Commit Message Conventions.
                                                              (line  42)
* git-commit-summary-max-length:         Commit Message Conventions.
                                                              (line  13)
* git-rebase-auto-advance:               Editing Rebase Sequences.
                                                              (line  80)
* git-rebase-confirm-cancel:             Editing Rebase Sequences.
                                                              (line  86)
* git-rebase-show-instructions:          Editing Rebase Sequences.
                                                              (line  83)
* global-auto-revert-mode:               Automatic Reverting of File-Visiting Buffers.
                                                              (line  23)
* magit-auto-revert-immediately:         Automatic Reverting of File-Visiting Buffers.
                                                              (line  33)
* magit-auto-revert-mode:                Automatic Reverting of File-Visiting Buffers.
                                                              (line  18)
* magit-auto-revert-tracked-only:        Automatic Reverting of File-Visiting Buffers.
                                                              (line  56)
* magit-bisect-show-graph:               Bisecting.           (line  60)
* magit-blame-disable-modes:             Blaming.             (line 149)
* magit-blame-echo-style:                Blaming.             (line 135)
* magit-blame-goto-chunk-hook:           Blaming.             (line 154)
* magit-blame-read-only:                 Blaming.             (line 145)
* magit-blame-styles:                    Blaming.             (line 130)
* magit-blame-time-format:               Blaming.             (line 141)
* magit-branch-adjust-remote-upstream-alist: Branch Commands. (line 206)
* magit-branch-direct-configure:         Branch Commands.     (line  22)
* magit-branch-prefer-remote-upstream:   Branch Commands.     (line 162)
* magit-branch-read-upstream-first:      Branch Commands.     (line 157)
* magit-buffer-name-format:              バッファの名付け.    (line  25)
* magit-bury-buffer-function:            Quitting Windows.    (line  13)
* magit-cherry-margin:                   Cherries.            (line  21)
* magit-clone-always-transient:          Cloning Repository.  (line  13)
* magit-clone-default-directory:         Cloning Repository.  (line  90)
* magit-clone-name-alist:                Cloning Repository.  (line 100)
* magit-clone-set-remote-head:           Cloning Repository.  (line  72)
* magit-clone-set-remote.pushDefault:    Cloning Repository.  (line  81)
* magit-clone-url-format:                Cloning Repository.  (line 119)
* magit-commit-ask-to-stage:             コミット開始.        (line  72)
* magit-commit-diff-inhibit-same-window: コミット開始.        (line 106)
* magit-commit-extend-override-date:     コミット開始.        (line  79)
* magit-commit-reword-override-date:     コミット開始.        (line  83)
* magit-commit-show-diff:                コミット開始.        (line  76)
* magit-commit-squash-confirm:           コミット開始.        (line  87)
* magit-completing-read-function:        補完フレームワークのサポート.
                                                              (line  28)
* magit-define-global-key-bindings:      Default Bindings.    (line   6)
* magit-diff-adjust-tab-width:           Diff Options.        (line  19)
* magit-diff-buffer-file-locked:         Commands for Buffers Visiting Files.
                                                              (line  61)
* magit-diff-extra-stat-arguments:       Diff Options.        (line 116)
* magit-diff-hide-trailing-cr-characters: Diff Options.       (line  83)
* magit-diff-highlight-hunk-region-functions: Diff Options.   (line  86)
* magit-diff-highlight-indentation:      Diff Options.        (line  68)
* magit-diff-highlight-trailing:         Diff Options.        (line  64)
* magit-diff-paint-whitespace:           Diff Options.        (line  41)
* magit-diff-paint-whitespace-lines:     Diff Options.        (line  55)
* magit-diff-refine-hunk:                Diff Options.        (line   6)
* magit-diff-refine-ignore-whitespace:   Diff Options.        (line  15)
* magit-diff-unmarked-lines-keep-foreground: Diff Options.    (line 110)
* magit-diff-visit-previous-blob:        Visiting Files and Blobs from a Diff.
                                                              (line  37)
* magit-direct-use-buffer-arguments:     Transient Arguments and Buffer Variables.
                                                              (line  67)
* magit-display-buffer-function:         バッファの切り替え.  (line  25)
* magit-display-buffer-noselect:         バッファの切り替え.  (line  17)
* magit-dwim-selection:                  補完と確認.          (line  38)
* magit-ediff-dwim-resolve-function:     Ediffing.            (line 117)
* magit-ediff-dwim-show-on-hunks:        Ediffing.            (line 123)
* magit-ediff-quit-hook:                 Ediffing.            (line 137)
* magit-ediff-show-stash-with-index:     Ediffing.            (line 131)
* magit-generate-buffer-name-function:   バッファの名付け.    (line   6)
* magit-git-debug:                       Viewing Git Output.  (line  26)
* magit-git-debug <1>:                   Getting a Value from Git.
                                                              (line  67)
* magit-git-executable:                  Git実行ファイル.     (line  26)
* magit-git-global-arguments:            Global Git Arguments.
                                                              (line   6)
* magit-keep-region-overlay:             選択範囲.            (line  48)
* magit-list-refs-sortby:                追加の補完オプション.
                                                              (line   6)
* magit-log-auto-more:                   Log Buffer.          (line  70)
* magit-log-buffer-file-locked:          Commands for Buffers Visiting Files.
                                                              (line  86)
* magit-log-margin:                      Log Margin.          (line  12)
* magit-log-margin-show-committer-date:  Log Margin.          (line  41)
* magit-log-section-commit-count:        Status Sections.     (line 118)
* magit-log-select-margin:               Select from Log.     (line  26)
* magit-log-show-refname-after-summary:  Log Buffer.          (line  75)
* magit-log-trace-definition-function:   Commands Available in Diffs.
                                                              (line  19)
* magit-module-sections-hook:            Status Module Sections.
                                                              (line  19)
* magit-module-sections-nested:          Status Module Sections.
                                                              (line  22)
* magit-no-confirm:                      アクションの確認.    (line  17)
* magit-pop-revision-stack-format:       Using the Revision Stack.
                                                              (line  32)
* magit-post-commit-hook:                コミット開始.        (line  95)
* magit-post-display-buffer-hook:        バッファの切り替え.  (line  87)
* magit-pre-display-buffer-hook:         バッファの切り替え.  (line  78)
* magit-prefer-remote-upstream:          Branch Git Variables.
                                                              (line 107)
* magit-prefix-use-buffer-arguments:     Transient Arguments and Buffer Variables.
                                                              (line  59)
* magit-process-extreme-logging:         Viewing Git Output.  (line  54)
* magit-process-raise-error:             Calling Git for Effect.
                                                              (line 126)
* magit-pull-or-fetch:                   Fetching.            (line  58)
* magit-reflog-margin:                   Reflog.              (line  20)
* magit-refresh-args:                    Refreshing Buffers.  (line  51)
* magit-refresh-buffer-hook:             Automatic Refreshing of Magit Buffers.
                                                              (line  41)
* magit-refresh-function:                Refreshing Buffers.  (line  46)
* magit-refresh-status-buffer:           Automatic Refreshing of Magit Buffers.
                                                              (line  45)
* magit-refs-filter-alist:               References Buffer.   (line 131)
* magit-refs-focus-column-width:         References Buffer.   (line  74)
* magit-refs-margin:                     References Buffer.   (line  87)
* magit-refs-margin-for-tags:            References Buffer.   (line 108)
* magit-refs-pad-commit-counts:          References Buffer.   (line  46)
* magit-refs-primary-column-width:       References Buffer.   (line  64)
* magit-refs-sections-hook:              References Sections. (line  13)
* magit-refs-show-commit-count:          References Buffer.   (line  36)
* magit-refs-show-remote-prefix:         References Buffer.   (line  58)
* magit-remote-add-set-remote.pushDefault: Remote Commands.   (line  87)
* magit-remote-direct-configure:         Remote Commands.     (line  22)
* magit-remote-git-executable:           Git実行ファイル.     (line  32)
* magit-repolist-columns:                Repository List.     (line  13)
* magit-repository-directories:          Status Buffer.       (line  56)
* magit-revision-filter-files-on-follow: Revision Buffer.     (line  51)
* magit-revision-insert-related-refs:    Revision Buffer.     (line   6)
* magit-revision-show-gravatars:         Revision Buffer.     (line  15)
* magit-revision-use-hash-sections:      Revision Buffer.     (line  30)
* magit-root-section:                    Matching Sections.   (line  80)
* magit-save-repository-buffers:         Automatic Saving of File-Visiting Buffers.
                                                              (line  12)
* magit-section-cache-visibility:        Section Visibility.  (line  82)
* magit-section-initial-visibility-alist: Section Visibility. (line  65)
* magit-section-movement-hook:           Section Movement.    (line  40)
* magit-section-set-visibility-hook:     Section Visibility.  (line  92)
* magit-section-show-child-count:        Section Options.     (line   9)
* magit-section-visibility-indicator:    Section Visibility.  (line 108)
* magit-shell-command-verbose-prompt:    Gitを手動で実行.     (line  44)
* magit-stashes-margin:                  Stashing.            (line  95)
* magit-status-headers-hook:             Status Header Sections.
                                                              (line  17)
* magit-status-margin:                   Status Options.      (line   9)
* magit-status-refresh-hook:             Status Options.      (line   6)
* magit-status-sections-hook:            Status Sections.     (line  10)
* magit-submodule-list-columns:          Listing Submodules.  (line  20)
* magit-this-process:                    Calling Git for Effect.
                                                              (line 122)
* magit-uniquify-buffer-names:           バッファの名付け.    (line  71)
* magit-unstage-committed:               Staging and Unstaging.
                                                              (line  57)
* magit-update-other-window-delay:       Section Movement.    (line  94)
* magit-visit-ref-behavior:              References Buffer.   (line 160)
* magit-wip-after-apply-mode:            Legacy Wip Modes.    (line  17)
* magit-wip-after-apply-mode-lighter:    Legacy Wip Modes.    (line  52)
* magit-wip-after-save-local-mode-lighter: Legacy Wip Modes.  (line  49)
* magit-wip-after-save-mode:             Legacy Wip Modes.    (line  12)
* magit-wip-before-change-mode:          Legacy Wip Modes.    (line  29)
* magit-wip-before-change-mode-lighter:  Legacy Wip Modes.    (line  55)
* magit-wip-initial-backup-mode:         Legacy Wip Modes.    (line  33)
* magit-wip-initial-backup-mode-lighter: Legacy Wip Modes.    (line  58)
* magit-wip-merge-branch:                Wip Graph.           (line   6)
* magit-wip-mode:                        Wip Modes.           (line  30)
* magit-wip-mode-lighter:                Wip Modes.           (line 101)
* magit-wip-namespace:                   Wip Modes.           (line  94)
* notes.displayRef:                      Notes.               (line  58)
* pull.rebase:                           Branch Git Variables.
                                                              (line  50)
* remote.NAME.fetch:                     Remote Git Variables.
                                                              (line  15)
* remote.NAME.push:                      Remote Git Variables.
                                                              (line  24)
* remote.NAME.pushurl:                   Remote Git Variables.
                                                              (line  19)
* remote.NAME.tagOpts:                   Remote Git Variables.
                                                              (line  28)
* remote.NAME.url:                       Remote Git Variables.
                                                              (line  11)
* remote.pushDefault:                    Branch Git Variables.
                                                              (line  63)



Tag Table:
Node: Top790
Node: Introduction15407
Node: Installation21970
Node: Installing from Melpa22479
Node: Installing from the Git Repository23838
Node: Post-Installation Tasks27295
Node: Getting Started28984
Node: Interface Concepts36824
Node: Modes and Buffers37905
Node: バッファの切り替え40701
Node: バッファの名付け46922
Node: Quitting Windows51057
Node: Automatic Refreshing of Magit Buffers53460
Node: Automatic Saving of File-Visiting Buffers57352
Node: Automatic Reverting of File-Visiting Buffers58851
Node: Risk of Reverting Automatically65497
Node: Sections68621
Node: Section Movement70013
Node: Section Visibility76090
Node: Section Hooks84100
Node: Section Types and Values87469
Node: Section Options89390
Node: トランジェントコマンド89975
Node: Transient Arguments and Buffer Variables91862
Node: Completion Confirmation(確認補完)とSelection(選択範囲)101470
Node: アクションの確認102173
Node: 補完と確認112817
Node: 選択範囲117066
Node: ハンク内部リージョン120976
Node: 補完フレームワークのサポート122439
Node: 追加の補完オプション128498
Node: Mouse Support129269
Node: Running Git130066
Node: Viewing Git Output130447
Node: Git Process Status134107
Node: Gitを手動で実行135314
Node: Git実行ファイル139032
Node: Global Git Arguments143079
Node: Inspecting144162
Node: Status Buffer145654
Node: Status Sections152231
Node: Status Header Sections159851
Node: Status Module Sections163145
Node: Status Options166545
Node: Repository List168410
Node: Logging174287
Node: Refreshing Logs178540
Node: Log Buffer180543
Node: Log Margin186425
Node: Select from Log190614
Node: Reflog193489
Node: Cherries195566
Node: Diffing198010
Node: Refreshing Diffs202437
Node: Commands Available in Diffs207135
Node: Diff Options210471
Node: Revision Buffer217474
Node: Ediffing221761
Node: References Buffer230480
Node: References Sections244174
Node: Bisecting245388
Node: Visiting Files and Blobs248663
Node: General-Purpose Visit Commands249379
Node: Visiting Files and Blobs from a Diff250651
Node: Blaming255306
Node: Manipulating263687
Node: Creating Repository264332
Node: Cloning Repository265053
Node: Staging and Unstaging273679
Node: Staging from File-Visiting Buffers279738
Node: Applying281484
Node: Committing284679
Node: コミット開始285489
Node: Editing Commit Messages292910
Node: Using the Revision Stack296672
Node: Commit Pseudo Headers300559
Node: Commit Mode and Hooks302295
Node: Commit Message Conventions306260
Node: Branching308986
Node: The Two Remotes309317
Node: Branch Commands313114
Node: Branch Git Variables330853
Node: Auxiliary Branch Commands337826
Node: Merging339273
Node: Resolving Conflicts344763
Node: Rebasing351709
Node: Editing Rebase Sequences358671
Node: Information About In-Progress Rebase364298
Ref: Information About In-Progress Rebase-Footnote-1375776
Node: Cherry Picking376537
Node: Reverting382680
Node: Resetting384936
Node: Stashing387627
Node: Transferring394386
Node: Remotes394761
Node: Remote Commands394966
Node: Remote Git Variables400527
Node: Fetching402228
Node: Pulling406019
Node: Pushing407665
Node: Plain Patches413923
Node: Maildir Patches416251
Node: Miscellaneous418477
Node: Tagging419172
Node: Notes421962
Node: Submodules425149
Node: Listing Submodules425486
Node: submodule用トランジェントコマンド428126
Node: Subtree431820
Node: Worktree435046
Node: Sparse checkouts436576
Node: Bundle440498
Node: Common Commands441081
Node: Wip Modes444292
Node: Wip Graph450978
Node: Legacy Wip Modes453862
Node: Commands for Buffers Visiting Files457431
Node: Minor Mode for Buffers Visiting Blobs465387
Node: Customizing466400
Node: Per-Repository Configuration468405
Node: 基本設定471098
Node: Safety471557
Node: Performance473975
Ref: Log Performance478285
Ref: Diff Performance480044
Ref: Refs Buffer Performance481757
Ref: Committing Performance482543
Node: Microsoft Windows Performance483691
Node: MacOS Performance485195
Ref: MacOS Performance-Footnote-1486046
Node: Default Bindings486185
Node: 配管コマンド(Plumbing)489130
Node: Calling Git490345
Node: Getting a Value from Git492357
Node: Calling Git for Effect497126
Node: Section Plumbing505181
Node: Creating Sections505507
Node: Section Selection511000
Node: Matching Sections513196
Node: Refreshing Buffers520954
Node: 慣習524920
Node: Theming Faces525156
Node: FAQ535824
Node: FAQ - How to ...?536375
Node: Magitの発音は？537124
Node: How to show git's output?538157
Node: How to install the gitman info manual?539185
Node: How to show diffs for gpg-encrypted files?540460
Node: How does branching and pushing work?541163
Node: VCを無効にする必要がありますか？541545
Node: FAQ - Issues and Errors542405
Node: Magit is slow546944
Node: I changed several thousand files at once and now Magit is unusable547266
Node: コミットに問題があります548317
Node: MS WindowsではMagitでpushできません548855
Node: 私は macOS を使用しています。その何かはシェルでは動きますが、Magitでは動きません549559
Node: ファイルを展開してdiffを表示するとファイルが消えます550768
Node: COMMIT_EDITMSGバッファのpointが間違っています551554
Node: モード行の情報が常に最新ではない552937
Node: 同じ名前を共有するブランチとタグは何かを壊します554144
Node: 私のGitフックはコマンドラインでは機能しますが、Magit内では機能しません555297
Node: コマンドラインからコミットする場合、git-commit-modeは使用されません556435
Node: file-visitingバッファにジャンプすると、ポイントは非表示のテキスト内にあります559492
Node: MS-WindowsからEmacsのTrampモードを使用するとステージできません560715
Node: 私はポップアップのデフォルトを保存できなくなりました561894
Node: Debugging Tools563301
Node: Keystroke Index567589
Node: Function and Command Index602221
Node: Variable Index654799

End Tag Table


Local Variables:
coding: utf-8
End:
