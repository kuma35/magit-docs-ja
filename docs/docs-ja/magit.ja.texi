\input texinfo    @c -*- texinfo -*-
@c ===========================================================================
@c
@c This file was generated with po4a. Translate the source file.
@c
@c ===========================================================================

@c %**start of header
@setfilename magit.info
@settitle Magit User Manual
@c %**end of header
@documentencoding UTF-8
@documentlanguage en

@copying
@quotation
Copyright (C) 2015-2022 Jonas Bernoulli <jonas@@bernoul.li>

You can redistribute this document and/or modify it under the terms of the
GNU General Public License as published by the Free Software Foundation,
either version 3 of the License, or (at your option) any later version.

This document is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE@.  See the GNU General Public License for
more details.

@end quotation
@end copying

@dircategory Magit文書翻訳
@direntry
* Magit(ja): (magit.ja).     MagitでEmacsのGitを使用する。
@end direntry

@finalout
@titlepage
@title Magit User Manual
@subtitle for version 3.3.0-git
@author Jonas Bernoulli
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@ifnottex
@node Top
@top Magit User Manual

Magitは、バージョン管理システムGitへのインターフェースであり、Emacsパッケージとして実装されています。Magitは完全なGit磁器を目指しています。MagitがすべてのGitコマンドをラップして改善するとは(まだ)主張できませんが、経験豊富なGitユーザーでさえEmacs内から直接毎日のバージョン管理タスクのほとんどすべてを実行できるほど十分に完全です。多くの優れたGitクライアントが存在しますが、磁器と呼ばれるのはMagitとGit自体だけです。(訳注:低レベルのを配管(plumbing)コマンド、よりユーザーフレンドリーなのを磁器(porcelain)コマンドと称する)

@noindent
This manual is for Magit version 3.3.0-git.

@insertcopying
@end ifnottex

@menu
* Introduction::             Introduction
* Installation::             Installation
* Getting Started::          Getting Started
* Interface Concepts::       Interface Concepts
* Inspecting::               Inspecting
* Manipulating::             Manipulating
* Transferring::             Transferring
* Miscellaneous::            Miscellaneous
* Customizing::              Customizing
* 配管コマンド(Plumbing)::  配管コマンド(Plumbing)
* FAQ::                      FAQ
* Debugging Tools::          Debugging Tools
* Keystroke Index::          Keystroke Index
* Function and Command Index::  Function and Command Index
* Variable Index::           Variable Index

@detailmenu
--- The Detailed Node Listing ---



Installation



* Installing from Melpa::    Installing from Melpa
* Installing from the Git Repository::  Installing from the Git Repository
* Post-Installation Tasks::  Post-Installation Tasks

Interface Concepts



* Modes and Buffers::        Modes and Buffers
* Sections::                 Sections
* トランジェントコマンド::  トランジェントコマンド
* Transient Arguments and Buffer Variables::  Transient Arguments and Buffer 
                                                Variables
* Completion(補完)とConfirmation(確認)とSelection(選択範囲): Completion Confirmation(確認補完)とSelection(選択範囲).  Completion(補完)とConfirmation(確認)とSelection(選択範囲): 
                                                                                                                                           Completion 
                                                                                                                                           Confirmation(確認補完)とSelection(選択範囲)
* Mouse Support::            Mouse Support
* Running Git::              Running Git

Modes and Buffers



* バッファの切り替え::  バッファの切り替え
* バッファの名付け::  バッファの名付け
* Quitting Windows::         Quitting Windows
* Automatic Refreshing of Magit Buffers::  Automatic Refreshing of Magit 
                                             Buffers
* Automatic Saving of File-Visiting Buffers::  Automatic Saving of 
                                                 File-Visiting Buffers
* Automatic Reverting of File-Visiting Buffers::  Automatic Reverting of 
                                                    File-Visiting Buffers



Sections



* Section Movement::         Section Movement
* Section Visibility::       Section Visibility
* Section Hooks::            Section Hooks
* Section Types and Values::  Section Types and Values
* Section Options::          Section Options



Completion(補完)とConfirmation(確認)とSelection(選択範囲)



* アクションの確認::  アクションの確認
* 補完と確認::          補完と確認
* 選択範囲::             選択範囲
* ハンク内部リージョン::  ハンク内部リージョン
* 補完フレームワークのサポート::  補完フレームワークのサポート
* 追加の補完オプション::  追加の補完オプション



Running Git



* Viewing Git Output::       Viewing Git Output
* Git Process Status::       Git Process Status
* Gitを手動で実行::    Gitを手動で実行
* Git実行ファイル::    Git実行ファイル
* Global Git Arguments::     Global Git Arguments



Inspecting



* Status Buffer::            Status Buffer
* Repository List::          Repository List
* Logging::                  Logging
* Diffing::                  Diffing
* Ediffing::                 Ediffing
* References Buffer::        References Buffer
* Bisecting::                Bisecting
* Visiting Files and Blobs::  Visiting Files and Blobs
* Blaming::                  Blaming

Status Buffer



* Status Sections::          Status Sections
* Status Header Sections::   Status Header Sections
* Status Module Sections::   Status Module Sections
* Status Options::           Status Options



Logging



* Refreshing Logs::          Refreshing Logs
* Log Buffer::               Log Buffer
* Log Margin::               Log Margin
* Select from Log::          Select from Log
* Reflog::                   Reflog
* Cherries::                 Cherries



Diffing



* Refreshing Diffs::         Refreshing Diffs
* Commands Available in Diffs::  Commands Available in Diffs
* Diff Options::             Diff Options
* Revision Buffer::          Revision Buffer



References Buffer



* References Sections::      References Sections



Visiting Files and Blobs



* General-Purpose Visit Commands::  General-Purpose Visit Commands
* Visiting Files and Blobs from a Diff::  Visiting Files and Blobs from a 
                                            Diff



Manipulating



* Creating Repository::      Creating Repository
* Cloning Repository::       Cloning Repository
* Staging and Unstaging::    Staging and Unstaging
* Applying::                 Applying
* Committing::               Committing
* Branching::                Branching
* Merging::                  Merging
* Resolving Conflicts::      Resolving Conflicts
* Rebasing::                 Rebasing
* Cherry Picking::           Cherry Picking
* Resetting::                Resetting
* Stashing::                 Stashing

Staging and Unstaging



* Staging from File-Visiting Buffers::  Staging from File-Visiting Buffers



Committing



* コミット開始::       コミット開始
* Editing Commit Messages::  Editing Commit Messages



Branching



* The Two Remotes::          The Two Remotes
* Branch Commands::          Branch Commands
* Branch Git Variables::     Branch Git Variables
* Auxiliary Branch Commands::  Auxiliary Branch Commands



Rebasing



* Editing Rebase Sequences::  Editing Rebase Sequences
* Information About In-Progress Rebase::  Information About In-Progress 
                                            Rebase



Cherry Picking



* Reverting::                Reverting



Transferring



* Remotes::                  Remotes
* Fetching::                 Fetching
* Pulling::                  Pulling
* Pushing::                  Pushing
* Plain Patches::            Plain Patches
* Maildir Patches::          Maildir Patches

Remotes



* Remote Commands::          Remote Commands
* Remote Git Variables::     Remote Git Variables



Miscellaneous



* Tagging::                  Tagging
* Notes::                    Notes
* Submodules::               Submodules
* Subtree::                  Subtree
* Worktree::                 Worktree
* Sparse checkouts::         Sparse checkouts
* Bundle::                   Bundle
* Common Commands::          Common Commands
* Wip Modes::                Wip Modes
* Commands for Buffers Visiting Files::  Commands for Buffers Visiting Files
* Minor Mode for Buffers Visiting Blobs::  Minor Mode for Buffers Visiting 
                                             Blobs

Submodules



* Listing Submodules::       Listing Submodules
* submodule用トランジェントコマンド::  submodule用トランジェントコマンド



Wip Modes



* Wip Graph::                Wip Graph
* Legacy Wip Modes::         Legacy Wip Modes



Customizing



* Per-Repository Configuration::  Per-Repository Configuration
* 基本設定::             基本設定

基本設定



* Safety::                   Safety
* Performance::              Performance
* Default Bindings::         Default Bindings



配管コマンド(Plumbing)



* Calling Git::              Calling Git
* Section Plumbing::         Section Plumbing
* Refreshing Buffers::       Refreshing Buffers
* 慣習::                   慣習

Calling Git



* Getting a Value from Git::  Getting a Value from Git
* Calling Git for Effect::   Calling Git for Effect



Section Plumbing



* Creating Sections::        Creating Sections
* Section Selection::        Section Selection
* Matching Sections::        Matching Sections



慣習



* Theming Faces::            Theming Faces



FAQ



* FAQ - How to @dots{}?::    FAQ - How to @dots{}?
* FAQ - Issues and Errors::  FAQ - Issues and Errors

FAQ - How to @dots{}?



* Magitの発音は？::     Magitの発音は？
* How to show git's output?::  How to show git's output?
* How to install the gitman info manual?::  How to install the gitman info 
                                              manual?
* How to show diffs for gpg-encrypted files?::  How to show diffs for 
                                                  gpg-encrypted files?
* How does branching and pushing work?::  How does branching and pushing 
                                            work?
* VCを無効にする必要がありますか？::  VCを無効にする必要がありますか？



FAQ - Issues and Errors



* Magit is slow::            Magit is slow
* I changed several thousand files at once and now Magit is unusable::  I 
                                                                          changed 
                                                                          several 
                                                                          thousand 
                                                                          files 
                                                                          at 
                                                                          once 
                                                                          and 
                                                                          now 
                                                                          Magit 
                                                                          is 
                                                                          unusable
* コミットに問題があります::  コミットに問題があります
* MS WindowsではMagitでpushできません::  MS 
                                                   WindowsではMagitでpushできません
* 私は macOS を使用しています。その何かはシェルでは動きますが、Magitでは動きません: 私は macOS を使用しています。その何かはシェルでは動きますが、Magitでは動きません.  私は 
                                                                                                                                                                                                                                             macOS 
                                                                                                                                                                                                                                             を使用しています。その何かはシェルでは動きますが、Magitでは動きません: 
                                                                                                                                                                                                                                             私は 
                                                                                                                                                                                                                                             macOS 
                                                                                                                                                                                                                                             を使用しています。その何かはシェルでは動きますが、Magitでは動きません
* ファイルを展開してdiffを表示するとファイルが消えます::  ファイルを展開してdiffを表示するとファイルが消えます
* @code{COMMIT_EDITMSG}バッファのpointが間違っています::  @code{COMMIT_EDITMSG}バッファのpointが間違っています
* モード行の情報が常に最新ではない::  モード行の情報が常に最新ではない
* 同じ名前を共有するブランチとタグは何かを壊します::  同じ名前を共有するブランチとタグは何かを壊します
* 私のGitフックはコマンドラインでは機能しますが、Magit内では機能しません::  私のGitフックはコマンドラインでは機能しますが、Magit内では機能しません
* コマンドラインからコミットする場合、@code{git-commit-mode}は使用されません::  コマンドラインからコミットする場合、@code{git-commit-mode}は使用されません
* file-visitingバッファにジャンプすると、ポイントは非表示のテキスト内にあります::  file-visitingバッファにジャンプすると、ポイントは非表示のテキスト内にあります
* MS-WindowsからEmacsのTrampモードを使用するとステージできません::  MS-WindowsからEmacsのTrampモードを使用するとステージできません
* 私はポップアップのデフォルトを保存できなくなりました::  私はポップアップのデフォルトを保存できなくなりました



@end detailmenu
@end menu

@node Introduction
@chapter Introduction

Magitは、バージョン管理システムGitへのインターフェースであり、Emacsパッケージとして実装されています。Magitは完全なGit磁器を目指しています。MagitがすべてのGitコマンドをラップして改善するとは(まだ)主張できませんが、経験豊富なGitユーザーでさえEmacs内から直接毎日のバージョン管理タスクのほとんどすべてを実行できるほど十分に完全です。多くの優れたGitクライアントが存在しますが、磁器と呼ばれるのはMagitとGit自体だけです。(訳注:低レベルのを配管(plumbing)コマンド、よりユーザーフレンドリーなのを磁器(porcelain)コマンドと称する)

ステージやその他の変更の適用は、Git磁器の最も重要な機能の1つであり、ここでMagitは、Git自体を含む他のどれよりも優れています。Git独自のステージインターフェース(@code{git
add --patch})は非常に扱いにくいため、多くのユーザーは例外的な場合にのみ使用します。
Magitでは、ハンクまたはハンクの一部をステージすることは、ファイルに加えられたすべての変更をステージするのと同じくらい簡単です。(訳注:ハンク(hunk)
大きなかたまり。関数単位とかじゃないけどファイル全体でもないようなかたまりのこと)

Magitのインターフェースの最も目に見える部分は、現在のリポジトリに関する情報を表示するステータスバッファです。そのコンテンツは、いくつかのGitコマンドを実行し、それらの出力に対して操作可能にしたもので作成されます。
特に、現在のブランチに関する情報を表示し、プルされていない変更(unpulled changes)とプッシュされていない変更(unpushed
changes)を一覧表示し、ステージされた変更(staged changes)とステージされていない変更(unstaged
changes)を表示するセクションを含みます。煩雑な表示に思えるえるかもしれませんが、セクションは折りたたみ可能であるため、そんなことはありません。

変更をステージ(stage)またはステージ解除(unstage)するには、変更にカーソルを置き、@code{s}または@code{u}と入力します。変更対象はファイルやハンクで、領域がアクティブな場合(つまり選択がある場合)、それは複数ファイルやハンク、あるいはハンクの一部分かもしれません。これらのコマンド(および他の多くのコマンド)が作用する1つまたは複数の変更が強調表示されます。

Magitは、ステージとステージ解除に加えて、他のいくつかの適用バリエーション("apply variants")も実装しています。
変更を破棄または元に戻すか、作業ツリーに適用できます。Git自身の磁器は、ステージとステージ解除でのみこれをサポートしており、@code{git
diff ... | ??? | git apply ...}を使用して、コマンドラインで単一のハンクを破棄、revert、または適用します。
実際、これはまさにMagitが内部で行っていることです(これが適用バリエーション("apply variants")という用語につながるものです)。

MagitはGitの専門家だけのものではありませんが、GitやEmacsでの経験があることを前提としています。
そうは言っても、多くのMagitユーザーは、Magitを使用することで、Gitの機能と、Gitを最大限に活用する方法を悟ったといっています。他のユーザーは、Magitをもっと早く手に入れることができるように、もっと早くEmacsに切り替えたいと願っていました。

Magitを最大限に活用するにはEmacsの基本機能を知っている必要がありますが、他のエディターを好むユーザーにとっても、十分なEmacsスキルを習得するのに時間はかからず、それだけの価値があります。
Vimユーザーは、@uref{https://github.com/emacs-evil/evil, Evil}「Extensible VI Layer
for Emacs」、および@uref{https://github.com/syl20bnr/spacemacs, Spacemacs}「Emacs
starter-kit focused on Evil」を試してみることをお勧めします。

Magitは、一貫性のある効率的なGit磁器を提供します。短い学習期間の後、コマンドラインよりも高速に毎日のバージョン管理タスクのほとんどを実行できるようになります。また、過去には気が遠くなるように思われた機能も使い始めるでしょう。

MagitはGitを完全に包含しています。多くのGUIクライアントのように些細なものをラップするだけでなく、シンプルでありながら柔軟なインターフェイスを使用して、多くの高度な機能を公開します。
もちろん、Magitは、ロギング、クローン作成、プッシュ、および通常は見事な方法により失敗することはないその他のコマンドをサポートしています。ただし、1つのステップで完了できないことが多いタスクもサポートします。Magitは、これらのタスクを開始するコマンドを提供するだけでなく、途中で状況に応じた情報を表示し、競合の解決と再開後の作業に役立つコマンドを提供することにより、マージ、リベース、チェリーピッキング、revert、blameなどのタスクを完全にサポートします。

Magitはラップすることにより、多くの場合、少なくとも次のGit磁器コマンドを改善します: @code{add}, @code{am},
@code{bisect}, @code{blame}, @code{branch}, @code{checkout}, @code{cherry},
@code{cherry-pick}, @code{clean}, @code{clone}, @code{commit},
@code{config}, @code{describe}, @code{diff}, @code{fetch},
@code{format-patch}, @code{init}, @code{log}, @code{merge},
@code{merge-tree}, @code{mv}, @code{notes}, @code{pull}, @code{rebase},
@code{reflog}, @code{remote}, @code{request-pull}, @code{reset},
@code{revert}, @code{rm}, @code{show}, @code{stash}, @code{submodule},
@code{subtree}, @code{tag}, @code{worktree.}
そして、さらに多くのMagit磁器コマンドがGit配管コマンドの上に実装されています。

@node Installation
@chapter Installation

Magitは、Emacsのパッケージマネージャーを使用してインストールすることも、開発リポジトリから手動でインストールすることもできます。

@menu
* Installing from Melpa::    Installing from Melpa
* Installing from the Git Repository::  Installing from the Git Repository
* Post-Installation Tasks::  Post-Installation Tasks
@end menu

@node Installing from Melpa
@section Installing from Melpa

MagitはMelpaおよびMelpa-Stableから入手できます。まだEmacsのパッケージマネージャーを使用したことがない場合は、Emacsマニュアルのドキュメントを読んで慣れてください(@ref{Packages,,,emacs,})。次に、アーカイブの1つを@code{package-archives}に追加します:

@itemize
@item
Melpaを使うなら:
@end itemize

@lisp
(require 'package)
(add-to-list 'package-archives
             '("melpa" . "http://melpa.org/packages/") t)
@end lisp

@itemize
@item
Melpa-Stableを使うなら:
@end itemize

@lisp
(require 'package)
(add-to-list 'package-archives
             '("melpa-stable" . "http://stable.melpa.org/packages/") t)
@end lisp

あなたの好きな方のアーカイブを追加したら、以下を使用してローカルパッケージリストを更新する必要があります:

@example
M-x package-refresh-contents RET
@end example

それが完了したら、以下を使用してMagitとその依存関係にあるパッケージをインストールできます:

@example
M-x package-install RET magit RET
@end example

なお、インストール後にしなければならない作業があります。こちらを参照して下さい(@ref{Post-Installation Tasks})。

@node Installing from the Git Repository
@section Installing from the Git Repository

Magitは、MelpaおよびMelpa-Stableから入手できる、@code{dash}と@code{transient}と@code{with-editor}ライブラリに依存しています。@code{M-x
package-install RET <package>
RET}を使用してインストールします。もちろん、それぞれのリポジトリから手動でインストールすることもできます。

次に、Magitリポジトリのクローンを作成します:

@example
$ git clone https://github.com/magit/magit.git ~/.emacs.d/site-lisp/magit
$ cd ~/.emacs.d/site-lisp/magit
@end example

次に、ライブラリをコンパイルして、infoマニュアルを生成します:

@example
$ make
@end example

Melpaや@code{/path/to/magit/../<package>}から@code{dash}と@code{transient}と@code{with-editor}をインストールした場合は、以下のようにして@code{make}にそれらの場所を指示します。これを行うには、@code{make}を実行する前に、以下の内容のファイル@code{/path/to/magit/config.mk}を作成します:

@example
LOAD_PATH  = -L ~/.emacs.d/site-lisp/magit/lisp
LOAD_PATH += -L ~/.emacs.d/site-lisp/dash
LOAD_PATH += -L ~/.emacs.d/site-lisp/transient/lisp
LOAD_PATH += -L ~/.emacs.d/site-lisp/with-editor
@end example

最後に、以下をEmacsのinitファイルに追加します:

@lisp
(add-to-list 'load-path "~/.emacs.d/site-lisp/magit/lisp")
(require 'magit)

(with-eval-after-load 'info
  (info-initialize)
  (add-to-list 'Info-directory-list
               "~/.emacs.d/site-lisp/magit/Documentation/"))
@end lisp

依存関係パッケージも手動でインストールした場合は、もちろん、上記Lispコードより前に以下を挿入して、Emacsにも依存関係について通知する必要があります:

@lisp
(add-to-list 'load-path "~/.emacs.d/site-lisp/dash")
(add-to-list 'load-path "~/.emacs.d/site-lisp/transient/lisp")
(add-to-list 'load-path "~/.emacs.d/site-lisp/with-editor")
@end lisp

注意:
@code{lisp}サブディレクトリをリポジトリのトップレベルではなく@code{load-path}に追加する必要があり、@code{load-path}の要素はスラッシュで終わっているべきではありません。逆に@code{Info-directory-list}の要素はスラッシュで終わっているべきです。

@code{magit}機能をrequireする代わりに、ファイル@code{magit-autoloads.el}をロードすることにより、autoload定義のみをロードできます。

@lisp
(load "/path/to/magit/lisp/magit-autoloads")
@end lisp

クローンしたリポジトリのMagitを@code{load-path}に追加してクローンしたリポジトリから直接実行する代わりに、@code{sudo
make install}を使用して他のディレクトリにインストールし、そこからの@code{load-path}を設定することをお勧めします。

Magitを更新するには、以下を使用します:

@example
$ git pull
$ make
@end example

代わりに@code{make clean all}を実行する必要がある場合があります。

使用可能なすべてのターゲットを表示するには、@code{make help}を使用します。

なお、インストール後にしなければならない作業があります。こちらを参照して下さい(@ref{Post-Installation Tasks})。

@node Post-Installation Tasks
@section Post-Installation Tasks

Magitインストール後、あなたが使用していると思っている、MagitとGitとEmacsのリリースを、実際に使用していることを確認する必要があります。なお、@code{load-path}に編集前の古い値を使用していないことを確実するために、Magitを再起動する前にEmacsを再起動することをお勧めします。

@example
M-x magit-version RET
@end example

次のようなものが表示される必要があります

@example
Magit 2.8.0, Git 2.10.2, Emacs 25.1.1, gnu/linux
@end example

取り急ぎ、多くのユーザーがカスタマイズを検討するオプションついて知りたいなら、こちらを参照するといいでしょう(@ref{基本設定})

このマニュアルにあるGit manpageへの相互参照をたどることができるようにするには、@code{gitman}
infoマニュアルを手動でインストールするか、@code{Info-follow-nearest-node}でアドバイスして実際のmanpageを開く必要がある場合もあります。
(@ref{How to install the gitman info manual?})

あなたがMagitを完全に初めて触る場合は→(@ref{Getting Started})

問題が発生した場合は(@ref{FAQ})や(@ref{Debugging Tools})を参照して下さい。

そして最後になりましたが、私がMagitに取り組み続けることができるように、寄付を検討してください。@uref{https://magit.vc/donations}を参照してください。さまざまな寄付オプションがあります。

@node Getting Started
@chapter Getting Started

この短いチュートリアルでは、多くのマジシャン(Magitian)が日常的に使用する最も重要な機能について説明します。それは表面を引っ掻く程度ですが、あなたが始めるのに十分なはずです。

重要:
このチュートリアルのためだけにリポジトリのクローンを作成するのが最も安全です。または、既存のローカルリポジトリを使用することもできますが、その場合は、作業を続行する前に、コミットされていないすべての変更をコミットする必要があります。

@code{C-x g}と入力して、ステータスバッファと呼ばれる専用バッファ内の現在のGitリポジトリに関する情報を表示します。

ほとんどのMagitコマンドは、通常、ステータスバッファから呼び出されます。これは、Magitを使用してGitと対話するための主要なインターフェースと見なすことができます。他の多くのMagitバッファが特定の時間に存在する可能性がありますが、多くの場合、これらはこのバッファから作成されます。

リポジトリの状態に応じて、このバッファには、"Staged changes"、"Unstaged changes"、"Unmerged into
origin/master"、"Unpushed to origin/master"、その他のタイトルのセクションが含まれる場合があります。

(@code{git reset --hard
PRE-MAGIT-STATE}を実行することで)簡単に戻ることができる安全な状態から開始しているため、現在、ステージされた変更(staged
changes)またはステージされてない変更(unstaged
changes)はありません。いくつかのファイルを編集し、変更を保存します。それから@code{C-x
g}と入力して、ステータスバッファに戻り、同時にリフレッシュします(ステータスバッファ、またはそのためのMagitバッファが現在のバッファである場合は、@code{g}だけを使用してリフレッシュすることもできます)。

@code{p}と@code{n}を使用してセクション間を移動します。一部のセクションの本文は非表示になっていることに注意してください。@code{TAB}と入力して、ポイントでセクションを展開または折りたたみます。@code{C-tab}を使用して、現在のセクションとその子の表示を循環させることもできます。"Unstaged
changes"という名前のセクション内のファイルセクションに移動し、@code{s}と入力して、そのファイルに加えた変更をステージします。
そのファイルは"Staged changes"の下に表れます。

Magitは、完全なファイルだけでなく、個々のハンクをステージ(stage)およびステージ解除(unstage)できます。ステージしたファイルに移動し、@code{TAB}を使用して展開し、@code{n}を使用してハンクのいずれかに移動し、@code{u}と入力してステージを解除します。ステージ(@code{s})コマンドとステージ解除(@code{u})コマンドがポイントでの変更に対してどのように動作するかに注意してください。他の多くのコマンドも同じように動作します。

ハンクの一部だけをステージ解除(unstage)/ステージ(stage)することもできます。ハンクセクションの本体内(@code{C-n}を使用してそこに移動する)で、@code{C-SPC}を使用してマークを設定し、追加または削除された行がすべてリージョン内に収まるまで下に移動します。そして、もう一度@code{s}と入力してステージします。

複数のファイルを一度にステージ解除(unstage)/ステージ(stage)することも可能です。ファイルセクションに移動し、@code{C-SPC}と入力し、@code{n}を使用して次のファイルに移動し、次に@code{s}を使用して両方のファイルをステージします。これが機能するには、マークとポイントの両方が兄弟セクションの見出しにある必要があることに注意してください。リージョンが他のバッファと同じように見える場合、ユニットとして機能できるMagitセクションは選択されません。

そしてもちろん、変更をコミットする必要があります。@code{c}と入力します。ここで、フレームの下部にあるバッファで使用可能なコミットコマンドと引数を示しています。各コマンドと引数には、それを呼び出す/設定するキーがプレフィックスとして付けられます。ここではこれについて気にする必要はありません。「通常の」コミットを作成します。これは、@code{c}をもう一度入力することで実行されます。

これで、2つの新しいバッファが表示されます。1つはコミットメッセージを書き込むためのもので、もう1つはコミットしようとしている変更とのdiffを示します。メッセージを書き込んでから、@code{C-c
C-c}と入力して、実際にコミットを作成します。

ランダムな変更をコミットしただけなので、作成したばかりのコミットをプッシュしたくない場合がありますが、そうでない場合は、@code{P}と入力して、使用可能なすべてのプッシュコマンドと引数を表示してからプッシュできます。@code{p}は、ローカルブランチと同じ名前のブランチにpush-remoteとして構成されたremoteにプッシュします。(push-remoteがまだ構成されていない場合は、最初にプッシュするためのremoteを求められます。)

これまで、commit、push、およびlogメニューコマンドについて説明してきました。これらはおそらくあなたが最も使用するメニューの1つですが、他にもたくさんあります。他のすべてのメニュー(およびさまざまなapplyコマンドやその他の重要なコマンド)を一覧表示するメニューを表示するには、@code{h}と入力します。
いくつか試してみてください。(このようなメニューは、トランジェントプレフィックスコマンド(一時的接頭辞コマンド)または単にトランジェントとも呼ばれます。）

そのメニューのキーバインディングは、ステータスバッファを含むがこれに限定されない、Magitバッファのバインディングに対応します。したがって、@code{h
d}と入力してdiffメニューを表示できますが、「d」が「diff」を表すことを思い出したら、通常は@code{d}と入力するだけです。ただし、この「プレフィックスのプレフィックス」は、すべてのバインディングを記憶した後でも、Magit以外のバッファからMagitコマンドに簡単にアクセスできるため便利です。グローバルバインディングは@code{C-x
M-g}です。

file visitingバッファでは、@code{C-c
M-g}は、訪問したファイルのみに作用する機能コマンド群である同様のメニューを表示します(@ref{Commands for Buffers
Visiting Files})。

Magit は、コンテキストメニューやその他マウスコマンドも提供します。 @ref{Mouse Support} を参照してください。

今すぐでなくて構いませんが、Magitを使い続ける場合は、次の節も読むことを強くお勧めします。

@node Interface Concepts
@chapter Interface Concepts

@menu
* Modes and Buffers::        Modes and Buffers
* Sections::                 Sections
* トランジェントコマンド::  トランジェントコマンド
* Transient Arguments and Buffer Variables::  Transient Arguments and Buffer 
                                                Variables
* Completion(補完)とConfirmation(確認)とSelection(選択範囲): Completion Confirmation(確認補完)とSelection(選択範囲).  Completion(補完)とConfirmation(確認)とSelection(選択範囲): 
                                                                                                                                           Completion 
                                                                                                                                           Confirmation(確認補完)とSelection(選択範囲)
* Mouse Support::            Mouse Support
* Running Git::              Running Git
@end menu

@node Modes and Buffers
@section Modes and Buffers

Magitはいくつかのメジャーモードを提供します。
これらのモードのそれぞれについて、通常、リポジトリごとに1つのバッファのみが存在します。個別のモードとそのためのバッファは、コミット、diff、ログ、およびその他のいくつかのもののために存在します。

これらの特別な目的のバッファに加えて、@strong{ステータスバッファ}と呼ばれる概要バッファもあります。ユーザーがGitコマンドを呼び出すか、他のバッファを作成または訪問するのは、通常、このバッファからです。

このマニュアルでは、「Magitバッファ」についてよく話します。つまり、メジャーモードが@code{magit-mode}から派生するバッファを意味します。

@table @asis
@item @kbd{M-x magit-toggle-buffer-lock}
@findex magit-toggle-buffer-lock
このコマンドは、現在のバッファをその値にロックします。バッファがすでにロックされている場合は、ロックを解除します。

バッファをその値にロックすると、別の値を表示するためにバッファが再利用されるのを防ぐことができます。ロックされたバッファの名前にはその値が含まれているため、他のロックされたバッファやロックされていないバッファと区別することができます。

すべてのMagitバッファをそれらの値にロックできるわけではありません。たとえば、ステータスバッファをロックすることは意味がありません。

リポジトリごとに特定のメジャーモードを使用するロック解除されたバッファは1つだけです。したがって、バッファがロック解除されていて、そのモードとリポジトリ用に別のロック解除されたバッファがすでに存在する場合、前者のバッファは代わりに削除され、後者がその場所に表示されます。
@end table

@menu
* バッファの切り替え::  バッファの切り替え
* バッファの名付け::  バッファの名付け
* Quitting Windows::         Quitting Windows
* Automatic Refreshing of Magit Buffers::  Automatic Refreshing of Magit 
                                             Buffers
* Automatic Saving of File-Visiting Buffers::  Automatic Saving of 
                                                 File-Visiting Buffers
* Automatic Reverting of File-Visiting Buffers::  Automatic Reverting of 
                                                    File-Visiting Buffers
@end menu

@node バッファの切り替え
@subsection バッファの切り替え

@defun magit-display-buffer buffer &optional display-function
この関数は@code{display-buffer}のラッパーであり、Magitバッファを表示するために使用されます。一部のウィンドウにBUFFERを表示し、@code{display-buffer}とは異なり、@code{magit-display-buffer-noselect}が@code{nil}の場合、そのウィンドウも選択します。また、以下に説明するフックを実行します。

オプションのDISPLAY-FUNCTIONがnil以外の場合、それはバッファを表示するために使用されます。通常、これは@code{nil}であり、@code{magit-display-buffer-function}で指定された関数が使用されます。
@end defun

@defvar magit-display-buffer-noselect
これがnil以外の場合、@code{magit-display-buffer}はバッファのみを表示し、ウィンドウの選択も行いません。この変数はグローバルに設定しないでください。「もう一方のウィンドウ」(the
other
window)を自動的に更新するコードによって、制限されることのみを目的としています。これは、たとえば、ログバッファ内に移動したときにリビジョンバッファが更新されるときに使用されます。
@end defvar

@defopt magit-display-buffer-function
ここで指定された関数は、@code{magit-display-buffer}によって呼び出され、1つの引数、つまりバッファを使用して、そのバッファを実際に表示します。この関数は、最初にそのバッファを使用し、2番目の引数として表示アクションのリストを使用して@code{display-buffer}を呼び出す必要があります。

Magitは、このオプションに適した値である、以下にリストされているいくつかの関数を提供します。あなたが別のルールを使用したい場合は、これらの関数の1つのコピーから始めて、あなたの必要に応じて調整(adjust)することをお勧めします。

@code{display-buffer}のラッパーを使用する代わりに、その関数自体をここで使用できます。その場合、代わりに@code{display-buffer-alist}に追加して表示アクションを指定する必要があります。

表示アクションについてはこちらを参照して下さい(@ref{Choosing Window,,,elisp,})。
@end defopt

@defun magit-display-buffer-traditional buffer
この関数は、オプション@code{magit-display-buffer-function}の現在のデフォルト値です。そのオプションとこの関数が追加される前は、動作はコードベース全体の多くの場所でハードコーディングされていましたが、現在はすべてのルールがこの1つの関数に含まれています(上記の「noselect」特殊ケースを除く)。
@end defun

@defun magit-display-buffer-same-window-except-diff-v1
この関数は、現在選択されているウィンドウにほとんどのバッファを表示します。バッファのモードが@code{magit-diff-mode}または@code{magit-process-mode}から派生している場合、別のウィンドウに表示されます。
@end defun

@defun magit-display-buffer-fullframe-status-v1
この関数は、ステータスバッファを表示するときにフレーム全体を埋めます(fill)。それ以外の場合は、@code{magit-display-buffer-traditional}のように動作します。
@end defun

@defun magit-display-buffer-fullframe-status-topleft-v1
この関数は、ステータスバッファを表示するときにフレーム全体を埋めます(fill)。@code{magit-display-buffer-fullframe-status-v1}と同じように動作しますが、@code{magit-diff-mode}または@code{magit-process-mode}から派生したバッファが、現在のバッファの下部または右側ではなく、上部または左側に表示される点が異なります。その結果、Magitバッファは、@code{magit-display-buffer-traditional}が使用されている場合と同じ側にポップアップする傾向があります。
@end defun

@defun magit-display-buffer-fullcolumn-most-v1
この関数は、ほとんどのバッファを表示して、フレームの高さ全体を埋める(fill)ようにします。
ただし、(1)バッファのモードが@code{magit-process-mode}から派生している場合、または(2)バッファのモードが@code{magit-diff-mode}から派生している場合、現在のバッファのモードが@code{magit-log-mode}または@code{magit-cherry-mode}から派生している場合、バッファは別のウィンドウに表示されます。
@end defun

@defopt magit-pre-display-buffer-hook
このフックは、バッファを表示する前に@code{magit-display-buffer}によって実行されます。
@end defopt

@defun magit-save-window-configuration
この関数は、現在のウィンドウ構成を保存します。後でバッファが隠される(bury)と、@code{magit-restore-window-configuration}によって復元される可能性があります。
@end defun

@defopt magit-post-display-buffer-hook
このフックは、バッファを表示した後、@code{magit-display-buffer}によって実行されます。
@end defopt

@defun magit-maybe-set-dedicated
この関数は、バッファを表示するために新しいウィンドウを作成する必要があるかどうか、または既存のウィンドウが再利用されたかどうかを記憶しています。
この情報は、後で@code{magit-mode-quit-window}によって使用され、最後のMagitバッファが隠された(bury)ときにウィンドウを削除する必要があるかどうかを判断します。
@end defun

@node バッファの名付け
@subsection バッファの名付け

@defopt magit-generate-buffer-name-function
Magitバッファの名前を生成するために使用される関数。

このような関数は、オプション@code{magit-uniquify-buffer-names}と@code{magit-buffer-name-format}を考慮に入れる必要があります。そうでない場合は、doc-stringに明確に記載する必要があります。また、オプション@code{magit-buffer-name-format}のdoc-stringに記載されている以外の%-sequencesをサポートしている場合は、独自のdoc-stringで追加を説明する必要があります。
@end defopt

@defun magit-generate-buffer-name-default-function mode
この関数は、メジャーモードが「mode」であり、かつ、@code{default-directory}が配置されているリポジトリに関する情報を表示するバッファに適したバッファ名を返します。

この関数は@code{magit-buffer-name-format}を使用し、そのオプションの文書に記載されているすべての %シーケンス
をサポートします。また、オプション@code{magit-uniquify-buffer-names}も尊重します。
@end defun

@defopt magit-buffer-name-format
Magitバッファに名前を付けるために使用されるフォーマット文字列。

少なくとも以下の%シーケンスがサポートされています:

@itemize
@item
@code{%m}

メジャーモードの名前ですが、@code{-mode}接尾辞部分が削除されています。

@item
@code{%M}

@code{%m}に似ていますが、@code{magit-status-mode}を@code{magit}と省略します。

@item
@code{%v}

バッファがロックされている時のカッコ内の値。またはバッファが値にロックされていない場合は空文字列。

@item
@code{%V}

@code{%v}と同様ですが、空文字列でない限り、文字列の前にスペースが付きます。

@item
@code{%t}

リポジトリの作業ツリーの最上位ディレクトリ、または@code{magit-uniquify-buffer-names}がnil以外の場合はその省略形。

@item
@code{%x}

@code{magit-uniquify-buffer-names}がnilの場合"*"、それ以外の場合は空の文字列。@code
{uniquify}パッケージの制限により、バッファ名はパスで終わる必要があります。

@item
@code{%T}

廃止されました。代わりに"%t%x"を使用してください。@code{%t}と同様ですが、@code{magit-uniquify-buffer-names}がnilの場合にのみ、アスタリスクを追加します。
@end itemize

値には、常に、@code{%m}または@code{%M}と、@code{%v}または@code{%V}と、@code{%t}(または廃止された@code{%T})が含まれているべきです。@code{magit-uniquify-buffer-names}がnil以外の場合、値は
@code{%t}または@code{%t%x}(または廃止された@code{%T})で終わる必要があります。issue #2841 を参照してください。
@end defopt

@defopt magit-uniquify-buffer-names
このオプションは、Magitバッファ達の名前を一意化(uniquify)するかどうかを制御します。名前が一意化されていない場合は、対応するリポジトリの作業ツリーの最上位のフルパスが含まれます。一意化されている場合は、最上位のベース名で終了します。それが他のバッファに使用されている名前と競合する場合は、競合しなくなるまで、これらすべてのバッファの名前が調整されます。

これは、@code{uniquify}パッケージを使用して行われます。そのオプションをカスタマイズして、バッファ名の一意化(uniquify)方法を制御します。
@end defopt

@node Quitting Windows
@subsection Quitting Windows

@table @asis
@item @kbd{q} (@code{magit-mode-bury-buffer})
@kindex q
@findex magit-mode-bury-buffer
このコマンドは現在のMagitバッファを隠し(bury)ます。

プレフィックス引数を付けると、代わりにバッファを強制終了します。プレフィックス引数を2つ付けると、現在のプロジェクトに関連付けられている他のすべてのMagitバッファも強制終了します。
@end table

@defopt magit-bury-buffer-function
現在のバッファを実際に隠す(bury)かまたは強制終了(kill)するために使用される関数。

@code{magit-mode-bury-buffer}は、この関数を1つの引数で呼び出します。引数がnil以外の場合、関数は現在のバッファを強制終了(kill)する必要があります。そうでなければ、それは生きたまま隠さなければなりません。現在のデフォルト値は@code{magit-restore-window-configuration}です。
@end defopt

@defun magit-restore-window-configuration kill-buffer
@code{quit-window}を使用して現在のバッファを隠す(bury)か、強制終了(kill)します。これは、最初にKILL-BUFFERを使用し、2番目の引数として選択したウィンドウを使用して呼び出されます。

それから、選択したフレームに現在のバッファが表示される直前に存在していたウィンドウ構成を復元します。残念ながら、それはまた、選択したフレームに表示されているすべてのバッファでポイントが調整されることを意味します。
@end defun

@defun magit-mode-quit-window kill-buffer
@code{quit-window}を使用して現在のバッファを隠す(bury)か、強制終了(kill)します。これは、最初にKILL-BUFFERを使用し、2番目の引数として選択したウィンドウを使用して呼び出されます。

それから、ウィンドウが元々Magitバッファを表示するために作成され、隠されていた(buried)バッファがウィンドウに表示された最後の残りのMagitバッファであった場合、それは削除されます。
@end defun

@node Automatic Refreshing of Magit Buffers
@subsection Automatic Refreshing of Magit Buffers

現在のリポジトリの状態を変更する可能性のあるコマンドを実行した後で、現在のMagitバッファと対応するステータスバッファがリフレッシュされます。ステータスバッファは、以下のようにフックを追加することで、バッファがそれぞれのリポジトリ内のファイルに保存されるたびに自動的にリフレッシュできます:

@lisp
(with-eval-after-load 'magit-mode
  (add-hook 'after-save-hook 'magit-after-save-refresh-status t))
@end lisp

Magitバッファ達を自動的にリフレッシュすると、表示される情報はほとんどの場合最新であることが保証されますが、大きなリポジトリで顕著な遅延が発生する可能性があります。他のMagitバッファ達は、遅延を最小限に抑えるためにリフレッシュされません。また、リフレッシュすることが望ましくない場合があるためです。

バッファは明示的にリフレッシュすることもできます。これは、Magitの外部でリポジトリに変更が加えられた後、まだリフレッシュされてない、最新ではなかったバッファで役立ちます。

@table @asis
@item @kbd{g} (@code{magit-refresh})
@kindex g
@findex magit-refresh
このコマンドは、メジャーモードが@code{magit-mode}および対応するステータスバッファから派生している場合、現在のバッファをリフレッシュします。

オプション@code{magit-revert-buffers}がそれを要求する場合、現在のリポジトリで追跡されているファイルを訪問するすべての変更されていないバッファもrvertします。

@item @kbd{G} (@code{magit-refresh-all})
@kindex G
@findex magit-refresh-all
このコマンドは、現在のリポジトリに属するすべてのMagitバッファをリフレッシュし、現在のリポジトリで追跡されているファイルに訪問するすべての変更されていないバッファをrevertします。

@code{magit-revert-buffers}がnilの場合でも、file-visitingバッファは常にrevertされます。
@end table

@defopt magit-refresh-buffer-hook
このフックは、現在リフレッシュ中にリフレッシュされた各Magitバッファ(通常は現在のバッファとステータスバッファ)で実行されます。
@end defopt

@defopt magit-refresh-status-buffer
このオプションがnil以外の場合、現在のMagitバッファに加えて、副作用としてgitを実行した後、ステータスバッファが自動的にリフレッシュされます。これは、常に自動的にリフレッシュされます。

パフォーマンスを向上させるために他のすべてのオプションを使い果たした後でのみ、これをnilに設定してください。
@end defopt

@defun magit-after-save-refresh-status
この関数は、@code{after-save-hook}に追加することを目的としています。その後、リポジトリ内のファイルにバッファが保存されるたびに、対応するステータスバッファがリフレッシュされます。

Magitバッファのリフレッシュは、その内容を最初から再作成することによって行われることに注意してください。これは、大規模なリポジトリでは遅くなる可能性があります。あなたがMagitのパフォーマンスに満足できない場合、明らかにこの関数をそのフックに追加すべきではありません。
@end defun

@node Automatic Saving of File-Visiting Buffers
@subsection Automatic Saving of File-Visiting Buffers

file-visitingバッファは、デフォルトで特定の時点で保存されます。これは、Magitバッファが常に最新であることを保証するものではありませんが、Emacsでのみファイルを編集し、かつ、Magitのみを使用してGitと対話する場合には、かなり自信があります。それが疑わしい場合や外部での変更後は、@code{g}(@code{magit-refresh})と入力して、明示的に保存およびリフレッシュします。

@defopt magit-save-repository-buffers
このオプションは、特定のイベントの前にfile-visitingバッファを保存するかどうかを制御します。

これがnil以外の場合、現在のリポジトリに属するすべての変更されたfile-visitingバッファは、コマンドを実行する前、新しいMagitバッファを作成する前、およびそのようなバッファを明示的にリフレッシュする前に保存できます。これが@code{dontask}の場合、これはユーザーの介入なしに実行されます。@code{t}の場合、ユーザーは各保存を確認する必要があります。
@end defopt

@node Automatic Reverting of File-Visiting Buffers
@subsection Automatic Reverting of File-Visiting Buffers

デフォルトでは、Magitは、Gitリポジトリで追跡されているファイルがディスク上で変更された後、それらを訪問しているバッファを自動的にrevertします。Magitを使用する場合、Gitを実行してディスク上のファイルを変更することがよくあります。つまり、それは「Emacsの外部」であるため、バッファを自動的にrevertするのはかなり重要な機能です。

たとえば、ステータスバッファの変更を破棄する場合、@code{git apply --reverse
...}を実行することでそれが行われ、Emacsはファイルが「ディスク上で変更された」と見なします。
Magitがバッファを自動的にrevertしなかった場合は、変更を続行する前に、訪問中のバッファに@code{M-x revert-buffer RET
RET}と入力する必要があります。

@defopt magit-auto-revert-mode
このモードを有効にすると、追跡中のファイル(tracked
files)を訪問したバッファは、訪問したファイルがディスク上で変更された後、自動的にrevertされます。
@end defopt

@defopt global-auto-revert-mode
このモードを有効にすると、訪問したファイル(visited
file)がディスク上で変更された後、file-visitingバッファが自動的にrevertされます。

追跡中のファイル(tracked
files)を訪問するバッファを自動的にrevertする場合は、追跡中のファイルを訪問するバッファだけでなく、任意のバッファをrevertすることもできます。その場合は、@code{magit-auto-revert-mode}の@emph{代わり}にこのモードを有効にしてください。
@end defopt

@defopt magit-auto-revert-immediately
このオプションは、Magitがバッファをすぐにrevertするかどうかを制御します。

これがnil以外で、@code{global-auto-revert-mode}または@code{magit-auto-revert-mode}のいずれかが有効になっている場合、Magitは、副作用のためにGitを実行した後、@code{auto-revert-buffers}を明示的に呼び出すことにより、すぐにバッファをrevertします。

@code{auto-revert-use-notify}がnil以外の場合(およびファイル通知が実際にサポートされている場合)、復帰はとにかくすぐに行われるため、@code{magit-auto-revert-immediately}をnil以外にする必要はありません。

@code{magit-auto-revert-immediately}と@code{auto-revert-use-notify}が両方とも@code{nil}の場合、ユーザーが非アクティブになってから@code{auto-revert-interval}秒後にrevertが発生します。それは望ましくありません。
@end defopt

@defopt auto-revert-use-notify
このオプションは、ファイル通知機能を使用するかどうかを制御します。残念ながら、ファイル通知を使用できないシステムでも、この変数のデフォルトは@code{t}であることに注意してください。
@end defopt

@defopt magit-auto-revert-tracked-only
このオプションは、@code{magit-auto-revert-mode}が追跡されているファイル(tracked
files)のみをrevertするか、追跡されていないファイル(untracked
files)やGitの制御ディレクトリ内にあるファイルを含むGitリポジトリ内にあるすべてのファイルをrevertするかを制御します。
@end defopt

@defopt auto-revert-mode
グローバルモード@code{magit-auto-revert-mode}は、適切なバッファでこのローカルモードをオンにすることで機能します(ただし、@code{global-auto-revert-mode}の実装は異なります)。手動でオンまたはオフにすることもできます。これは、以前は追跡されてなかったファイルが今現在追跡されていることにMagitが気付かない場合、またはその逆の場合に必要になることがあります。
@end defopt

@defopt auto-revert-stop-on-user-input
このオプションは、ユーザーが入力するまで@code{auto-revert-interval}秒間、自動revertを一時停止(suspend)するかどうかを制御します。
@end defopt

@defopt auto-revert-interval
このオプションは、一時停止された自動revertを再開する前にEmacsが待機する秒数を制御します。
@end defopt

@defopt auto-revert-buffer-list-filter
このオプションは、@code{auto-revert-buffers}がバッファをrevertするかどうかを決定するために使用する追加のフィルターを指定します。

このオプションはMagitによって提供され、@code{auto-revert-buffers}にもそれを尊重するようにアドバイスします。ローカルモード@code{auto-revert-mode}を自分でオンにしないMagitユーザーは、値を@code{magit-auto-revert-repository-buffer-p}に設定するのが最適です。

ただし、ローカルモードを直接使用するユーザーの邪魔にならないように、デフォルトはnilです。Magitコマンドの実行中に遅延が発生した場合は、Magitが提供する述語(predicate)の1つを使用することを検討する必要があります。特に、Trampも使用している場合はそうです。

Magitがオンにしないバッファで@code{auto-revert-mode}をオンにするユーザーは、フィルターを使用しないでください。@code{global-auto-revert-mode}をオンにするユーザーは、グローバルモードが有効になっている場合は無視されるため、このオプションについて心配する必要はありません。
@end defopt

@defopt auto-revert-verbose
このオプションは、バッファがrevertされたときにEmacsがレポートするかどうかを制御します。
@end defopt

@code{auto-revert-}接頭辞が付いたオプションは、@code{auto-revert}という名前のカスタムグループにあります。他のMagit固有のオプションは、@code{magit}グループにあります。

@menu
* Risk of Reverting Automatically::  Risk of Reverting Automatically
@end menu

@node Risk of Reverting Automatically
@unnumberedsubsubsec Risk of Reverting Automatically

大多数のユーザーにとって、ディスク上で変更された後にfile-visitingバッファを自動的revertすることは無害です。

バッファが変更された場合(つまり、まだ保存されていない変更が含まれている場合)、Emacsは自動的にバッファをrevertすることを拒否します。以前に変更されたバッファを保存すると、Gitはコミットされていない変更と見なします。その後、Gitは、これらの変更が失われる原因となるコマンドの実行を拒否します。言い換えれば、失われる可能性のあるものがある場合、GitまたはEmacsのいずれかが変更の破棄を拒否します。

ただし、あなたがfile-visitingバッファを一種その場しのぎ(ad
hoc)の「ステージ領域」として使用する場合、自動revertによってデータが失われる可能性があります。
これまでのところ、このようなワークフローを使用しているユーザーは私が知っている限りでは1人だけです。

例：あなたはバッファ内のファイルを訪問して編集し、変更を保存します。それから、Emacsの外部で(または少なくともMagitを使用しないか、バッファを保存することにより)、ディスク上のファイルを再度変更します。この時点で、バッファは中間バージョンがまだ存在する唯一の場所です。変更をディスクに保存しましたが、それ以降は上書きされています。一方、Emacsはバッファが変更されていないと見なし(最後に訪問したファイルに保存してから変更を加えていないため)、自動的にrevertされることに異議を唱えません。この時点で、自動revertモードが開始されます。バッファが変更されているかどうかがチェックされ、変更されていないため、バッファがrevertされます。中間バージョンは失われます。(実際には、いまだ、@code{undo}コマンドを使用して元に戻る(get
it back)ことができます。)

あなたのワークフローがバッファに中間バージョンを保持するEmacsに依存している場合は、すべての自動revertモードを無効にする必要があります。ただし、このようなワークフローは、自動revertモードを使用しなくても危険であるため、回避する必要があることを考慮してください。Emacsがクラッシュしたり、誤ってEmacsを終了したりすると、バッファの内容も失われます。中間バージョンがまだ含まれている自動保存ファイルはなく(バッファを保存したときに削除されたため)、バッファを保存するかどうかを尋ねられることはありません(変更されていないため)。

@node Sections
@section Sections

Magitバッファはネストされたセクションに編成され、Orgモードでセクションが処理されるのと同様に、折りたたんだり展開したりできます。各セクションにもタイプがあり、一部のセクションにも値があります。セクションタイプごとに、そのタイプのすべてのセクションで共有されるローカルキーマップを作成することもできます。

セクションの値とタイプを利用して、多くのコマンドが現在のセクションで動作します。または、リージョンがアクティブで同じタイプのセクションを選択すると、選択されたすべてのセクションが操作されます。(タイプの違いのみよって動作が異なるだけではなく)特定のセクションタイプに対してのみ意味のあるコマンドは、通常、セクションタイプのキーマップにバインドされます。

@menu
* Section Movement::         Section Movement
* Section Visibility::       Section Visibility
* Section Hooks::            Section Hooks
* Section Types and Values::  Section Types and Values
* Section Options::          Section Options
@end menu

@node Section Movement
@subsection Section Movement

セクション内を移動するには、グローバルバインディングが隠蔽されていない通常のキー(@code{C-p}, @code{C-n}, @code{C-b},
@code{C-f} 等)を使用します。 別のセクションに移動するには、以下のコマンドを使用します。

@table @asis
@item @kbd{p} (@code{magit-section-backward})
@kindex p
@findex magit-section-backward
セクションの先頭じゃない場合は、現在のセクションの先頭に移動します。セクションの先頭では、前の表示セクションの先頭に移動します。

@item @kbd{n} (@code{magit-section-forward})
@kindex n
@findex magit-section-forward
次の表示セクションの先頭に移動します。

@item @kbd{M-p} (@code{magit-section-backward-siblings})
@kindex M-p
@findex magit-section-backward-siblings
前の兄弟セクションの先頭に移動します。 前の兄弟セクションがない場合は、代わりに親セクションに移動します。

@item @kbd{M-n} (@code{magit-section-forward-siblings})
@kindex M-n
@findex magit-section-forward-siblings
次の兄弟セクションの先頭に移動します。 次の兄弟セクションがない場合は、代わりに親セクションに移動します。

@item @kbd{^} (@code{magit-section-up})
@kindex ^
@findex magit-section-up
現在のセクションの親の先頭に移動します。
@end table

上記のコマンドはすべて、フック@code{magit-section-movement-hook}を呼び出します。以下にリストされている関数のいずれかをこのフックのメンバーとして使用できます。

あなたは、Magitが@code{add-hook}を使用して追加する関数のいくつかを削除したいと思うかもしれません。その際は、まだ追加されていない関数を削除しようとしないようにする必要があります。以下に例を示します。

@lisp
(with-eval-after-load 'magit-diff
  (remove-hook 'magit-section-movement-hook
               'magit-hunk-set-window-start))
@end lisp

@defvar magit-section-movement-hook
このフックは、上記のすべての移動コマンドににおいて、目的地に到着した後に実行されます。
@end defvar

@defun magit-hunk-set-window-start
このフック関数は、@code{hunk}セクションであれば、現在のセクションの先頭が表示されるようにします。それ以外の場合は何もしません。

@code{magit-diff}をロードすると、この関数がフックに追加されます。
@end defun

@defun magit-section-set-window-start
このフック機能により、セクションのタイプに関係なく、現在のセクションの先頭が表示されます。これを@code{magit-section-movement-hook}に追加する場合は、ハンクのみのバリエーション(hunk-only
variant)を順番に削除する必要があります。
@end defun

@defun magit-log-maybe-show-more-commits
このフック関数はログバッファでのみ効果があり、そして@code{point}は"show
more"(もっと見る)セクションにあります。その場合は、表示されているコミットの数が2倍になります。

@code{magit-log}をロードすると、この関数がフックに追加されます。
@end defun

@defun magit-log-maybe-update-revision-buffer
ログバッファ内を移動する場合、同じフレームの別のウィンドウにすでに表示されている場合、この関数はリビジョンバッファを更新します。

@code{magit-log}をロードすると、この関数がフックに追加されます。
@end defun

@defun magit-log-maybe-update-blob-buffer
ログバッファ内を移動し、同じフレームの別のウィンドウにblobバッファが表示される場合、この関数は代わりに、そのウィンドウ内のポイントでのコミットのblobバッファを表示します。
@end defun

@defun magit-status-maybe-update-revision-buffer
ステータスバッファ内を移動するとき、同じフレームの別のウィンドウにすでに表示されている場合、この関数はリビジョンバッファを更新します。
@end defun

@defun magit-status-maybe-update-stash-buffer
ステータスバッファ内を移動するとき、同じフレームの別のウィンドウにすでに表示されている場合、この関数はスタッシュバッファを更新します。
@end defun

@defun magit-status-maybe-update-blob-buffer
ステータスバッファ内を移動し、同じフレームの別のウィンドウにblobバッファが表示される場合、この関数は代わりに、そのウィンドウ内のポイントでのコミットのblobバッファを表示します。
@end defun

@defun magit-stashes-maybe-update-stash-buffer
スタッシュを一覧表示するバッファ内を移動する場合、同じフレームの別のウィンドウにすでに表示されている場合、この関数はスタッシュバッファを更新します。
@end defun

@defopt magit-update-other-window-delay
他のウィンドウを自動的に更新する前に遅延します。

特定のバッファ内を移動する場合、別のウィンドウに表示されている特定の他のバッファをオプションで更新して、その時点のセクションに関する情報を表示することができます。

キーを押したままにして複数のセクションを移動すると、途中でセクションごとにそのバッファが更新されます。これを防ぐために、リビジョンバッファの更新は遅延され、このオプションはそれがどのくらいの長さかを制御します。最適なエクスペリエンスを得るには、この遅延やキーボードの繰り返し速度、およびグラフィカル環境やオペレーティングシステムの遅延を調整する必要がある場合があります。
@end defopt

@node Section Visibility
@subsection Section Visibility

Magitには、セクションの表示を変更するための多くのコマンドが用意されていますが、開始するために必要なのは次の2つだけです。

@table @asis
@item @kbd{@key{TAB}} (@code{magit-section-toggle})
@kindex TAB
@findex magit-section-toggle
現在のセクションの本体の表示を切り替えます。

@item @kbd{C-<tab>} (@code{magit-section-cycle})
@kindex C-<tab>
@findex magit-section-cycle
現在のセクションとその子の表示を循環させます。

@item @kbd{M-<tab>} (@code{magit-section-cycle-diffs})
@kindex M-<tab>
@findex magit-section-cycle-diffs
現在のバッファ内のdiff-relatedセクションの表示を循環させます。

@item @kbd{S-<tab>} (@code{magit-section-cycle-global})
@kindex S-<tab>
@findex magit-section-cycle-global
現在のバッファ内のすべてのセクションの表示を循環させます。

@item @kbd{1} (@code{magit-section-show-level-1})
@itemx @kbd{2} (@code{magit-section-show-level-2})
@itemx @kbd{3} (@code{magit-section-show-level-3})
@itemx @kbd{4} (@code{magit-section-show-level-4})
@kindex 1
@kindex 2
@kindex 3
@kindex 4
@findex magit-section-show-level-1
@findex magit-section-show-level-2
@findex magit-section-show-level-3
@findex magit-section-show-level-4
レベルNまでの現在のセクションを囲むセクションを表示します。

@item @kbd{M-1} (@code{magit-section-show-level-1-all})
@itemx @kbd{M-2} (@code{magit-section-show-level-2-all})
@itemx @kbd{M-3} (@code{magit-section-show-level-3-all})
@itemx @kbd{M-4} (@code{magit-section-show-level-4-all})
@kindex M-1
@kindex M-2
@kindex M-3
@kindex M-4
@findex magit-section-show-level-1-all
@findex magit-section-show-level-2-all
@findex magit-section-show-level-3-all
@findex magit-section-show-level-4-all
レベルNまでのすべてのセクションを表示します。
@end table

上記のコマンドを実装するために使用される一部の関数は、コマンド自体としても公開されます。デフォルトでは、これらのコマンドに結び付けられているキーはありません。これらのコマンドは、一般的にあまり役に立たないと認識されているためです。しかし、あなたにとっては有益かもしれません。

@deffn Command magit-section-show
現在のセクションのボディを表示します。
@end deffn

@deffn Command magit-section-hide
現在のセクションのボディを非表示にします。
@end deffn

@deffn Command magit-section-show-headings
現在のセクションの子の見出しを再帰的に表示します。見出しのみを表示します。以前に表示されたテキストのみのボディは非表示になります。
@end deffn

@deffn Command magit-section-show-children
現在のセクションの子の体を再帰的に表示します。プレフィックス引数を使用すると、現在のセクションのレベルまで子を表示し、より深い子を非表示にします。
@end deffn

@deffn Command magit-section-hide-children
現在のセクションの子のボディを再帰的に非表示にします。
@end deffn

@deffn Command magit-section-toggle-children
現在のセクションの子のボディの可視性を切り替えます(toggle)。
@end deffn

バッファが最初に作成されると、一部のセクションは展開されて表示されますが、他のセクションは展開されません。これはハードコーディングされています。バッファがリフレッシュされると、以前の可視性が保持されます。特定のセクションの初期可視性は、フック@code{magit-section-set-visibility-hook}を使用して上書きすることもできます。

@defopt magit-section-initial-visibility-alist
このオプションを使用して、セクションの初期可視性をオーバーライドできます。将来的には、デフォルトの定義にも使用されますが、現在、セクションのデフォルトはハードコーディングされています。

値は単一のalistです。各要素は、セクションタイプまたは系統(lineage)をそのようなセクションの初期可視状態にマップします。状態は、@code{show}または@code{hide}のいずれか、またはこれらのシンボルの1つを返す関数である必要があります。セクションを唯一の引数として関数が呼び出されます。

コマンド@code{magit-describe-section-briefly}を使用して、セクションの系統(lineage)またはタイプを判別します。出力のベクター(vector)はセクション系統(section
lineage)であり、タイプはそのベクター(vector)の最初の要素です。ワイルドカードを使用できます。@code{magit-section-match}を参照してください。
@end defopt

@defopt magit-section-cache-visibility
このオプションは、セクションが消えて後で再び表示された場合に、以前の可視性状態を復元するセクションを制御します。値はブール値またはセクションタイプのリストです。tの場合、すべてのセクションの可視性がキャッシュされます。それ以外の場合、これは、タイプがリストされたタイプの1つと一致するセクションに対してのみ実行されます。

これには、関数@code
{magit-section-cached-visibility}が@code{magit-section-set-visibility-hook}のメンバーである必要があります。
@end defopt

@defvar magit-section-set-visibility-hook
このフックは、最初にバッファを作成するとき、および既存のバッファをリフレッシュするときに実行され、現在挿入されているセクションの可視性を判別するために使用されます。

各関数は1つの引数で呼び出され、セクションが挿入されます。@code{hide}または@code{show}を返すか、可視性を未定義の@code{nil}のままにする必要があります。可視性を決定する関数がなく、バッファがリフレッシュされている場合、可視性は保持されます。
または、バッファが作成されている場合は、ハードコードされたデフォルトが使用されます。

通常、これは初期の可視性を設定するためにのみ使用する必要があり、リフレッシュ中は使用しないでください。@code{magit-insert-section--oldroot}がnil以外の場合、バッファはリフレッシュ済で、これらの関数はすぐに@code{nil}を返す必要があります。
@end defvar

@defopt magit-section-visibility-indicator
このオプションは、セクションを展開/折りたたむことができるかどうか、および表示(indicate)方法を制御します。

nilの場合、可視性インジケータは表示されません。それ以外の場合、値は以下の2つの形式のいずれかである必要があります:

@itemize
@item
@code{(EXPANDABLE-BITMAP . COLLAPSIBLE-BITMAP)}

両方の値は、値がフリンジビットマップ(fringe
bitmaps)である変数である必要があります。この場合、展開または折りたたむことができるすべてのセクションは、左フリンジ(left
fringe)にインジケーターを取得します。

インジケーターの周囲に追加のパディングを提供するには、@code{magit-mode-hook}で@code{left-fringe-width}を設定します。例:

@lisp
(add-hook 'magit-mode-hook (lambda ()
                             (setq left-fringe-width 20)))
@end lisp

@item
@code{(STRING . BOOLEAN)}

この場合、折りたたまれたすべてのセクションの見出しの最後にSTRING(通常は省略記号)が表示されます。展開されたセクションにはインジケーターが表示されません。cdrは、これらの省略記号の外観がセクションの強調表示を考慮に入れるかどうかを制御します。そうしないとパフォーマンスに影響を与える可能性がありますが、そうしないと少し醜いです。
@end itemize
@end defopt

@node Section Hooks
@subsection Section Hooks

どのセクションが特定のバッファーに挿入されるかは、フックで制御されます。これには、ステータス(status)と参照(refs)バッファが含まれます。他のバッファの場合、例えば
logおよびdiffバッファ、これは不可能です。コマンド@code
{magit-describe-section}を使用して、ポイントにセクションを挿入する原因となったフック(存在する場合)を確認できます。

ユーザーがセクションをカスタマイズできるバッファの場合、@code{magit-TYPE-sections-hook}というフック変数が存在します。このフックは、@code{magit-add-section-hook}を使用して変更する必要があります。@code{add-hooks}またはカスタムインターフェイス(Custom
interface)の使用は避けてください。

使用可能なさまざまなセクションフック変数については、このマニュアルの後半で、適切なセクションインサーター関数とともに説明します。

@defun magit-add-section-hook hook function &optional at append local
セクションフックFOOKの値に関数FUNCTIONを追加します。

オプションのAPPENDがnil以外の場合を除き、フックリストの最初にFUNCTIONを追加します。APPENDがnil以外の場合、最後にFUNCTIONを追加します。
FUNCTIONがすでにメンバーである場合は、それを新しい場所に移動します。

オプションのATがnil以外で、フックリストのメンバーである場合は、代わりにその脇にFUNCTIONを追加します。
APPENDに応じて、ATの前または後に追加するか、ATをFUNCTIONに置き換えます。APPENDがシンボル@code{replace}の場合、ATをFUNCTIONに置き換えます。APPENDがその他のゼロ以外の値の場合は、ATの直後にFUNCTIONを配置します。nilの場合は、ATの直前にFUNCTIONを配置します。FUNCTIONがすでにリストのメンバーであるが、ATがメンバーでない場合は、FUNCTIONを既に存在する場所に残します。

オプションのLOCALがnil以外の場合は、フックのグローバル値ではなく、バッファローカル値を変更します。
これにより、デフォルト値をコピーしてフックがローカルになります。次に、そのコピーが変更されます。

HOOKはシンボルであるべきです。HOOKが無効の場合、最初にnilに設定されます。HOOKの値は単一のフック関数であってはなりません。FUNCTIONは、引数をとらず、ポイントに1つまたは複数のセクションを挿入して、ポイントを前方に移動する関数である必要があります。FUNCTIONは、そうする意味がない場合に、セクションを挿入しないことを選択する場合があります。それは他の副作用のために乱用されるべきではありません。
@end defun

セクションフックから関数を削除するには、@code{remove-hook}を使用します。

@node Section Types and Values
@subsection Section Types and Values

各セクションには、例えば@code{hunk}、@code{file}、@code{commit}などのタイプがあります。特定のセクションタイプのインスタンスにも値があります。たとえば、タイプ@code{file}のセクションの値は、ファイル名です。

ユーザーは通常、セクションのタイプと値について心配する必要はありませんが、それらを知っていると便利な場合があります。

@table @asis
@item @kbd{H} (@code{magit-describe-section})
@kindex H
@findex magit-describe-section
このコマンドは、別のバッファ内のポイントのセクションに関する情報を表示します。
@end table

@deffn Command magit-describe-section-briefly
このコマンドは、エコー領域のポイントのセクションに関する情報を@code{#<magit-section VALUE [TYPE
PARENT-TYPE...] BEGINNING-END>}として表示します。
@end deffn

多くのコマンドは、ポイントのある場所でのセクションのタイプに応じて異なる動作をしたり、何らかの形でそのセクションの値を消費したりします。しかし、それは、現在のセクションに応じて、同じキーが異なることを行う可能性がある理由の1つにすぎません。

さらに、セクションタイプごとに、@code{magit-TYPE-section-map}という名前のキーマップを定義できます。そのキーマップは、それぞれのタイプの任意のセクションに属するすべてのテキストのテキストプロパティキーマップとして使用されます。そのようなマップが特定のタイプに存在しない場合、あなたが自分で定義することができ、そしてそれが自動的に使用されます。

@node Section Options
@subsection Section Options

このセクションでは、特定のタイプのセクション以外にも影響を与えるオプションについて説明します。以下ご覧のとおり、そんなに多くはありません。

@defopt magit-section-show-child-count
セクションの見出しに子の数を追加するかどうか。これは、この情報の恩恵を受ける可能性のあるセクションにのみ影響します。
@end defopt

@node トランジェントコマンド
@section トランジェントコマンド

多くのMagitコマンドは、@strong{トランジェント}(一時的)コマンドとして実装されています。
最初に、ユーザーが@strong{プレフィックス}(接頭辞)コマンドを呼び出すと、@strong{インフィックス}(中置)引数達と@strong{サフィックス}(後置)コマンド達がエコー領域に表示されます。次に、ユーザーはオプションでいくつかのインフィックス(中置)引数を設定し、最後にサフィックス(接尾辞)コマンドのどれか1つを呼び出します。

これは、ライブラリ@code{transient}で実装されています。
以前のMagitリリースでは、パッケージ@code{magit-popup}、さらに以前のバージョンではライブラリ@code{magit-key-mode}を使用していました。

transientの文書はこちらを参照して下さい(@ref{Top,,,transient,})。

@table @asis
@item @kbd{C-c C-c} (@code{magit-dispatch})
@kindex C-c C-c
@findex magit-dispatch
このトランジェント(一時的)プレフィックス(接頭辞)コマンドは、Magitの他のプレフィックスコマンドのほとんどをサフィックス(後置)コマンドとして結び付け、そのうちの1つが呼び出されるまで一時バッファ(temporary
buffer)に表示します。このようなサブプレフィックスを呼び出すと、@code{magit-dispatch}のではなく、そのコマンドのサフィックスコマンドが結び付けられて表示されます。
@end table

このコマンドは、Magitバッファの外部でも特に便利なので、グローバル・バインディングを設定すべきです:

@lisp
(global-set-key (kbd "C-x M-g") 'magit-dispatch)
@end lisp

@node Transient Arguments and Buffer Variables
@section Transient Arguments and Buffer Variables

Magitのトランジェント(一時的)プレフィックス(接頭辞)コマンドコマンドの多くのインフィックス(中置)引数は、それらのインフィックス引数で呼び出した@code{git}コマンドから帰って来ると、効果がなくなります。コミットを作成するコマンドは、この良い例です。ユーザーがインフィックス引数を変更した場合、それはそれに続くサフィックス(接尾辞)コマンドの呼び出しにのみ影響します。同じトランジェントプレフィックスコマンドが後で再度呼び出された場合、インフィックス引数は最初にデフォルト値にリセットされます。このデフォルト値は、現在のEmacsセッションに設定することも、永続的に保存することもできます(@ref{Saving
Values,,,transient,})。
@code{C-M-p}と@code{C-M-n}を使用して、以前に使用した引数のセットを循環させることもできます(@ref{Using
History,,,transient,})。

ただし、他の多くのトランジェントコマンドのインフィックス引数は、それらのインフィックス引数で呼び出した@code{git}コマンドから帰った後でも引き続き有効です。このようなコマンドで最も重要なのは、専用のバッファにdiffやログを表示したりするコマンドです。それぞれのdiffまたはログが表示されている限り、それらの引数は明らかに効果を持ち続けます。さらに、使用された引数は、将来の参照のためにバッファローカル変数に格納されます。

後者の場合、トランジェントコマンドが再度呼び出されたときに、それらの引数をグローバル値にリセットすることが常に望ましいとは限りません。

上記のように、トランジェントなポップアップが表示されている間に、以前に使用された引数のセットを循環させることができます。つまり、既存のバッファでアクティブになっている引数のセットは@code{C-M-p}の数個しか離れていないため、インフィックス(中置)引数を常にデフォルトにリセットできます。Magitはそのように動作するように構成できますが、ほとんどのユーザーにとってはそれほど便利ではないと思うので、デフォルトではありません。

また、@code{D}と@code{L}でそれぞれの"refresh"トランジェントプレフィックスコマンドを使用して、現在のバッファ(diffセクションとlogセクションの両方を含むステータスバッファを含む)で使用されるdiff引数とlog引数を変更できることにも注意してください。(一方、@code{d}と@code{l}は、diffまたはログの表示方法を変更することを@strong{目的}としています。diffまたはログの@strong{表示方法}を同時に変更することもできますが、後者のみを実行する場合は、refreshのバリエーションを使用する必要があります。）これらのセカンダリdiffおよびlogトランジェントプレフィックスコマンドは、現在のバッファで使用される引数の@strong{変更}に関するものであるため、常に、そのバッファで現在有効な引数のセットから開始します。

一部のコマンドは、トランジェントプレフィックスコマンドのサフィックスコマンドとして呼び出すこともできますが、通常は直接呼び出されます。その典型は@code{magit-show-commit}で、通常、ポイントがログのコミット中に@code{RET}と入力することで呼び出されますが、@code{magit-diff}トランジェントプレフィックスコマンドから呼び出すこともできます。

このようなコマンドを直接呼び出す場合は、デフォルトの引数を使用するのではなく、それぞれのバッファローカル値で指定された引数を再利用することが重要です。
logで@code{RET}を押して別のバッファ内のポイントでcommitを表示し、次に@code{D}を使用してそのバッファでのdiffの表示方法を変更するとします。次に、別のcommitで@code{RET}を押して、代わりにdiff引数がデフォルトにリセットされることを示します。クールじゃありません。したがって、Magitはデフォルトではそれを行いません。

@defopt magit-prefix-use-buffer-arguments
このオプションは、特定のトランジェントプレフィックスコマンドで最初に表示されるインフィックス引数が、サフィックスコマンドが更新するバッファで現在有効な引数に基づいているかどうかを制御します。

@code{magit-diff}および@code{magit-log}のトランジェントプレフィックスコマンドは、このオプションの影響を受けます。
@end defopt

@defopt magit-direct-use-buffer-arguments
このオプションは、特定のコマンドが直接呼び出されたときに(つまり、トランジェントプレフィックスコマンドのサフィックスコマンドとしてではなく)、更新しようとしているバッファで現在アクティブな引数を使用するかどうかを制御します。代替手段は、これらの引数にデフォルト値を使用することで、これにより、バッファで使用される引数が変更される可能性があります。
@end defopt

@noindent
上記の両方のオプションの有効な値は以下のとおりです:

@itemize
@item
@code{always}: もちろんバッファが存在する場合は、それぞれのバッファで現在アクティブな引数のセットを常に使用します。
@item
@code{selected}または@code{t}:
それぞれのバッファからの引数のセットを使用しますが、それが現在のフレームのウィンドウに表示されている場合に限ります。これは、両方の変数のデフォルトです。
@item
@code{current}: それぞれのバッファからの引数のセットを使用しますが、それが現在のバッファ(current
buffer)である場合に限ります。
@item
@code{never}: それぞれのバッファーからの引数のセットを使用しないでください。
@end itemize

@noindent
私はそれがさらに複雑になるのではないかと心配しています:

@itemize
@item
グローバルのdiffおよびlog引数は、サポートされているモードごとに個別に設定されます。たとえば、diff引数は、@code{magit-diff-mode}、@code{magit-revision-mode}、@code{magit-merge-preview-mode}および@code{magit-status-mode}バッファで異なる値を持ちます。あるモードの値を設定または保存しても、他のモードの値は変更されません。ただし、履歴は共有されます。

@item
@code{magit-show-commit}がログバッファから直接呼び出されると、ファイルフィルターは、リビジョンバッファやモードのグローバルdiff引数からではなく、そのバッファから取得されます。

@item
これらはdiff用トランジェントプレフィックスコマンドに従うサフィックスコマンドですが、@code{magit-show-commit}と@code{magit-stash-show}は、diffコマンドで使用されるdiffバッファを使用せず、代わりに専用のリビジョンバッファとstashバッファを使用します。

diff用トランジェントプレフィックスコマンドを呼び出すとき、どのサフィックスコマンドを呼び出すかはMagitにはわかりません。確かではありませんが、多くの場合、ユーザーはdiffバッファを使用するコマンドのいずれかを呼び出すため、最初のインフィックス引数はそのバッファで使用されるものです。ただし、これらのコマンドの1つを直接呼び出すと、Magitはリビジョンのそれぞれのスタッシュバッファからの引数を使用する必要があることを認識します。

@item
ログ用トランジェントプレフィックスコマンドにはreflogコマンドもありますが、これらのコマンドはログ引数を使用しません。

@item
@code{magit-show-refs}が@code{magit-refs-mode}バッファから呼び出された場合、それはrefreshトランジェントプレフィックスコマンドとして機能するため、バッファの引数を初期引数として無条件に使用します。プレフィックス引数を使用して他の場所で呼び出された場合は通常のプレフィックスとして機能するため、@code{magit-prefix-use-buffer-arguments}を尊重します。プレフィックス引数なしで他の場所で呼び出された場合、直接コマンドとして機能するため、@code{magit-direct-use-buffer-arguments}を尊重します。
@end itemize

@node Completion Confirmation(確認補完)とSelection(選択範囲)
@section Completion(補完)とConfirmation(確認)とSelection(選択範囲)

@menu
* アクションの確認::  アクションの確認
* 補完と確認::          補完と確認
* 選択範囲::             選択範囲
* ハンク内部リージョン::  ハンク内部リージョン
* 補完フレームワークのサポート::  補完フレームワークのサポート
* 追加の補完オプション::  追加の補完オプション
@end menu

@node アクションの確認
@subsection アクションの確認

デフォルトでは、データ損失につながる可能性のある多くのアクションを確認する必要があります。これには多くの非常に一般的なアクションが含まれるため、これはすぐに煩わしくなります。これらのアクションの多くは元に戻す(undo)ことができるので、あなたが特定の間違いを元に戻す方法を考えている場合は、それぞれのアクションの確認を無効にしても安全です。

オプション@code{magit-no-confirm}を使用すると、ユーザーが確認しなくても特定のアクションを実行するようにMagitに指示できます。このオプションは特定のアクションセットの確認を無効にするためにのみ使用できますが、次節では、Magitに質問を少なくするように指示する別の方法について説明します。

@defopt magit-no-confirm
このオプションの値はシンボルのリストであり、実行する前にユーザーが確認する必要のないアクションを表します。

デフォルトでは、多くの潜在的に危険なコマンドがユーザーに確認を求めます。以下の各シンボルは、意図せずに、または結果を完全に認識せずに呼び出された場合に、涙を流す可能性のあるアクションを表しています。多くの場合、特定のアクションのバリエーションを実行するコマンドがいくつかあるため、コマンド名ではなく、より一般的なシンボルを使用します。

@itemize
@item
変更の適用(applying changes):

@itemize
@item
@code{discard} 1つ以上の変更(つまり、ファイルのハンクまたは完全なdiff)を破棄すると、明らかにその変更が失われます。

@item
@code{reverse}
1つ以上の変更をrevertするには、通常、reversionのrevertによって元通り(undo)にすることができます。

@item
@code{stage-all-changes}, @code {unstage-all-changes}
ステージされた変更とステージされていない変更の両方がある場合、すべてのステージを解除/ステージすると、その区別が失われます。もちろん、これは単一の変更をステージ解除/ステージする場合にも当てはまりますが、失われるものは少なく、頻繁に行うため、毎回確認する必要はありません。
@end itemize

@item
ファイル(files):

@itemize
@item
@code{delete} Gitによってまだ追跡されていないファイルが削除されると、最後の変更だけでなく、全てが完全に失われます。大変危険です。

@item
@code{trash} ファイルを削除する代わりに、システムのゴミ箱に移動することもできます。明らかに、それを削除するよりもはるかに危険が少ないです。

オプション@code{magit-delete-by-moving-to-trash}もご覧ください。

@item
@code{resurrect}
削除されたファイルは、最初に同じファイルを削除するために使用されたのと同じコマンドを使用して実行される削除を「削除」することにより、簡単に復活させることができます。

@item
@code{untrack}
ファイルの追跡解除(untracking)は、ファイルを再度追跡(tracking)することで元に戻す(undo)ことができます。

@item
@code{rename} ファイルの名前変更は簡単に元に戻す(undo)ことができます。
@end itemize

@item
一連の処理(sequences):

@itemize
@item
@code{reset-bisect}
bisect操作を中止(abort)すると(Gitでは「リセット」と呼ばれます)、これまでに収集されたすべての情報が失われます。

@item
@code{abort-rebase}
リベースを中止(abort)すると、すでに変更されたすべてのコミットが破棄されますが、reflogからそれらを復元することは可能です。

@item
@code{abort-merge} マージを中止(abort)すると、ユーザーがすでに実行したすべての競合解決(conflict
resolution)が破棄されます。

@item
@code{merge-dirty} ダーティなワークツリーとマージすると、マージが開始される前の状態に戻るのが難しくなる可能性があります。
@end itemize

@item
参照(refernces):

@itemize
@item
@code{delete-unmerged-branch}
ブランチが削除されると、Gitが提供する低レベルのリカバリツールを使用してのみ復元できます。そしてそれでもreflogはなくなってしまいます。ユーザーは常にデフォルトの選択を受け入れる(または別のブランチを選択する)ことによってブランチの削除を確認する必要がありますが、ブランチがまだマージされていない場合は、ユーザーがそれを認識していることも確認してください。

@item
@code{delete-pr-remote}
プルリクエストから作成されたブランチを削除するときに、そのリモートに他のブランチがまだ存在しない場合、@code{magit-branch-delete}はリモートも削除するように提案します。これは、リモート名前空間(remotes
namespace)に他の参照が存在しない場合にのみ発生し、必要に応じてリモートを再作成できるため、安全であるはずです。

@item
@code{drop-stashes}
Gitはスタッシュをreflogに保存するため、スタッシュを削除するのは危険です。スタッシュが削除されると、Gitが提供する低レベルのリカバリツールを使用せずに戻すことはできません。単一のスタッシュがドロップされた場合、ユーザーは常にデフォルトを受け入れる(または別のスタッシュを選択する)ことによって確認する必要があります。このアクションは、一度に複数のスタッシュを削除する場合のみ関係します。
@end itemize

@item
公開(publishing):

@itemize
@item
@code {set-and-push}
アップストリームまたはプッシュリモートにプッシュし、それが実際にはまだ構成されていない場合、ユーザーは最初にターゲットを設定できます。デフォルトの確認が速すぎると、間違ったブランチにプッシュしてしまう可能性があり、リモートリポジトリがそのような間違いの修正を許可しないように構成されている場合、それは非常にどぎまぎして胸糞悪いことになる可能性があります。
@end itemize

@item
公開の歴史を編集(edit published history):

ここにこれらのシンボルを追加しないと、@code{magit-published-branches}にリストされているブランチの1つにすでにプッシュされているコミットを編集する前に警告が表示されます。

@itemize
@item
@code {amend-published}「HEAD」を修正するほとんどのコマンドに影響します。

@item
@code{rebase-published}
対話的なリベースを実行するコマンドに影響します。これには、「HEAD」以外のコミットを変更する、つまみぐいコミット(commit
transient)なコミットからのコマンド、つまりさまざまなfixupとsquashのバリエーションが含まれます。

@item
@code {edit-published}
コマンド@code{magit-edit-line-commit}および@code{magit-diff-edit-hunk-commit}に影響します。これらの2つのコマンドを使用すると、公開されたコミット(published
commit)を誤って編集することが非常に簡単になるため、確認を求めないように構成する前に、よく考えておく必要があります。
@end itemize

確認を完全に無効にするには、ここに3つのシンボルすべてを追加するか、@code{magit-published-branches}を@code{nil}に設定します。

@item
その他(various):

@itemize
@item
@code {kill-process} プロセスを強制終了する理由はめったにありません。
@end itemize

@item
グローバル設定(global settings):

このオプションの値に上記のすべてのシンボルを追加する代わりに、アトム`t'に設定することもできます。これは、上記のすべてのシンボルを追加するのと同じ効果があります。特に他のシンボルが将来追加される可能性があるため、これを行うことは間違いなく悪い考えです。したがって、これらのアクションのいずれについても確認を求められたくない場合でも、それぞれのシンボルをすべて個別に追加することをお勧めします。

@code{magit-wip-before-change-mode}が有効になっている場合、@code{discard}と@code{reverse}と@code{stage-all-changes}と@code{unstage-all-changes}アクションはかなり簡単に元に戻すことができます。このモードが有効になっている場合にのみ、@code{safe-with-wip}はこれらのシンボルをすべて個別に追加するのと同じ効果があります。
@end itemize
@end defopt

@node 補完と確認
@subsection 補完と確認

多くのMagitコマンドは、ユーザーに、実行可能なもののリストから選択するように求めますが、デフォルトとして最も可能性の高い選択肢を提供します。これらのコマンドの多くでは、実際に実行することできるという条件のものが提供され、デフォルトはその時点でのものです。ブランチに作用する多くのコマンドでは、ポイントにブランチがない場合、現在のブランチがデフォルトになります。

これらのコマンドは、確認(confirm)を求めることと、アクションを実行するターゲットを求めることを組み合わせて1つのアクションにします。ユーザーは、@code{RET}を使用してデフォルトのターゲットを確認するか、@code{C-g}を使用して中止(abort)することができます。これは@code{y-or-n-p}プロンプトに似ていますが、確認(confirm)または中止(abort)するためのキーが異なります。

同時に、ユーザーには別のターゲットを選択する機会も与えられます。これは、コマンドや状況によっては、ターゲットに移動して選択する前にアクションを選択したい場合があるため便利です。

けれども、一部のコマンドでは、デフォルトのターゲットがあればそれを常に使用したい場合や、確認をまったく必要とせずにコマンドをデフォルトで動作させたい場合もあります。オプション@code{magit-dwim-selection}を使用して、その効果をもたらす特定のコマンドを構成できます。

リージョンがアクティブな場合、多くの場合、確認を求めた後、リージョンに基づくメカニズムを使用して選択されたものに多くのコマンド達が作用することに注意してください。このリージョンベースのメカニズムは「selection」(選択状態)と呼ばれ、次節で詳しく説明します。呼び出されたコマンドに有効なselectionが存在する場合、そのコマンドは他の何かに作用することを提案することはなく、確認を求めるかどうかはこのオプションによって制御されません。

また、Magitは、補完(completion)(または選択状態(selection))と結び付けられていない特定のアクションの確認を要求することにも注意してください。前節で説明したように、このようなダイアログもこのオプションの影響を受けません。

@defopt magit-dwim-selection
@end defopt
このオプションを使用すると、確認の有無にかかわらず、アクションを実行する候補をユーザーに選択する代わりに、特定のコマンドにそのポイントでそれを使用するように指示できます。

値の形式は@code{((COMMAND nil|PROMPT DEFAULT)...)}です。

@itemize
@item
COMMANDは、選択を求めるプロンプトを表示してはならないコマンドです。効果を得るには、コマンドで関数@code{magit-completing-read}を使用するか、ユーティリティ関数を使用してその関数を使用する必要があります。

@item
コマンドが@code{magit-completing-read}を複数回使用する場合、PROMPTは、これらの使用の1つにのみ影響を与えるために使用できます。PROMPTは、nil以外の場合、@code{magit-completing-read}に渡されるPROMPT引数と照合するために使用される正規表現です。

@item
DEFAULTは、デフォルトの使用方法を指定します。@code{t}の場合、@code{magit-completing-read}に渡されたDEFAULT引数が確認なしで使用されます。@code{ask}の場合、ユーザーは中止する機会が与えられます。DEFAULTは@code{nil}にすることもできます。この場合、エントリは効果がありません。
@end itemize

@node 選択範囲
@subsection 選択範囲

リージョンがアクティブな場合、多くのMagitコマンドは、単一のものではなく、リージョンに基づくメカニズムを使用して選択されたもの達に作用します。リージョンがアクティブでない場合、これらのコマンドはそのポイントでモノに作用するか、作用する単一のモノを読み取ります。これについては前節で説明しました。この節では、複数のものを選択する方法、それを視覚化する方法、およびその場合の特定のコマンドの動作についてのみ説明します。

複数のもの、またはこれらを表すセクションを選択するためのMagitのメカニズムは、Emacsリージョンに基づいていますが、Magitが選択したと見なす領域は通常、リージョンよりも大きく、追加の制限が適用されます。

Magitは、有効なMagit選択範囲(selection)を形成する資格があるリージョンとそうでないリージョンを区別します。リージョンが適格でない場合は、他のEmacsバッファと同じように表示されます。リージョンがMagitの選択範囲として適格である場合、その選択範囲は常に視覚化されますが、リージョン自体は、同じ行で開始および終了する場合にのみ視覚化されます。

リージョンがMagitの選択範囲(selection)として適格であるためには、そのリージョンは1つのセクションの見出しで始まり、兄弟セクションの見出しで終わる必要があります。リージョンの終わりがセクション見出しの最初(つまり、行の最初の桁位置)にある場合、そのセクションは選択範囲の「内側」と見なされることに注意してください。

これは、リージョンがEmacsで通常どのように扱われるかと一致していません。Emacsリージョンが行の先頭で終了する場合、その行はEmacsリージョンの外側にあります。Magitが選択範囲を視覚化する方法により、この違いが存在することは明らかです。

すべてのコマンドがすべての有効な選択範囲に作用するわけではありません。一部のコマンドはポイントの位置さえ考慮しません。他のコマンドはポイントでセクションに作用しますが、選択範囲に作用することをサポートしません。もちろん、選択範囲をサポートするコマンドでさえ、作用できるものを選択する場合にのみそうします。

これが、選択範囲にポイントのセクションを含める必要がある主な理由です。選択範囲が存在する場合でも、呼び出されたコマンドはそれを無視する場合があります。その場合、現在のセクションにのみ作用する可能性があります。選択したセクションの「代わりに」現在のセクションに作用するよりも、現在のセクションにのみ作用し、他の選択したセクションには作用しない方がはるかに安全です。後者の方がはるかに驚くべきことであり、現在のセクションが常に選択範囲の一部である場合、それは起こり得ません。

@defvar magit-keep-region-overlay
この変数は、有効なMagit選択範囲またはハンク内部リージョンが存在する場合でも、リージョンを通常どおりに視覚化するかどうかを制御します。詳細については、doc-stringを参照してください。
@end defvar

@node ハンク内部リージョン
@subsection ハンク内部リージョン

前節で説明したMagitの選択範囲にいくらか関連しているのは、ハンク内部リージョンです。

選択範囲と同様に、ハンク内部リージョンはEmacsリージョンに基づいていますが、そのリージョンは他のEmacsバッファの場合のように視覚化されず、そして、そのリージョンの行の最初で終了しても、そのリージョンにはその行の終わりまでが含まれます。

1つのセクションの見出しで始まり、兄弟セクションのセクションで終わるリージョンに基づく選択状態とは異なり、ハンク内部リージョンは、ハンクセクションの「ボディ」内で始まり、そのセクションのボディ内で終わる必要があります。

ハンク内部リージョンは、"apply"コマンドによって尊重されます。このコマンドは、他のターゲットの中でも、ハンクに作用することができます。
ハンク内部リージョンがアクティブな場合、そのようなコマンドは、ハンク全体ではなく、ハンク中のマークされた部分にのみ作用します。

@node 補完フレームワークのサポート
@subsection 補完フレームワークのサポート

組み込みオプション@code{completing-read-function}は、@code{completing-read}がユーザーに選択肢のリストから選択するように求めるために使用する低レベル関数を指定します。デフォルト値は@code{completing-read-default}です。代替の補完フレームワークは通常、独自の実装で置き換えることによってそれ自体をアクティブにします。

主に歴史的な理由から、Magitは@code{magit-completing-read-function}という名前の同様のオプションを提供します。これは、@code{magit-completing-read}によって使用される低レベル関数のみを制御します。このオプションを使用すると、Magitで他のEmacsとは異なる補完メカニズムを使用することもできますが、これを行うことはお勧めしません。

ほとんどの場合、代替の補完フレームワークを使用するためにmagit固有のオプションをカスタマイズする必要はありません。
たとえば、@code{ivy-mode}を有効にすると、Magitはそれを尊重し、@code{helm-mode}を有効にすると、それも補完します。

ただし、Idoを使用する場合は、@code{ido-mode}ではうまくいきません。
@code{ido-completing-read+}パッケージもインストールしなければなりません。そして@code{magit-ido-completing-read}を@code{magit-completing-read-function}として使用する必要があります。

@defopt magit-completing-read-function
この変数の値は、(組み込みの@code{completing-read}ではなく)
@code{magit-completing-read}を使用するコードによる補完を実行するために使用される低レベル関数です。

デフォルト値の@code{magit-builtin-completing-read}は、少なくとも標準の補完メカニズムである@code{ivy-mode}と@code{helm-mode}に適しています。

組み込みの@code{completing-read}と@code{completing-read-default}は、ここでの使用には「適していません」。@code{magit-builtin-completing-read}はいくつかの追加作業を実行し、その場所で使用される関数はすべて同じことを実行する必要があります。
@end defopt

@defun magit-builtin-completing-read prompt choices &optional predicate require-match initial-input hist def
この関数は、組み込みの@code{completing-read}を使用して補完を実行し、magit固有の追加の作業を実行します。
@end defun

@defun magit-ido-completing-read prompt choices &optional predicate require-match initial-input hist def
この関数は、(明示的にインストールする必要がある)同じ名前のパッケージから@code{ido-completing-read+}を使用して補完を実行し、さらにいくつかのmagit固有の作業を実行します。

Ido自体に付属している@code{ido-completing-read}の代わりに@code{ido-completing-read+}を使用する必要があります。後者は、drop-in代替として意図されていますが、その目的を果たすことができないためです。それは暗黙の規則の多くに違反しています。
@end defun

@defun magit-completing-read prompt choices &optional predicate require-match initial-input hist def fallback
これは、Magitコマンドが、ユーザーが操作するものを1つ選択する必要がある場合に使用する機能です。引数の意味は、@code{completing-read}の場合と同じですが、FALLBACKはこの関数に固有ですので以下で説明します。

この関数は、可能な候補のリストから選択するようにユーザーに求める代わりに、ユーザーの確認を必要とするかどうかに関係なく、DEFで指定されたデフォルトを返すだけの場合があります。それが当てはまるかどうかは、PROMPTと@code{this-command}と@code{magit-dwim-selection}によって異なります。
詳細については後述します。

ミニバッファの値を読み取る場合、この関数は@code{completing-read}と同様に機能しますが、以下の点が異なります:

@itemize
@item
COLLECTIONは選択肢のリストでなければなりません。関数はサポートされていません。

@item
REQUIRE-MATCHが@code{nil}であり、ユーザーが選択せずに終了した場合、空文字列の代わりに@code{nil}が返されます。

@item
REQUIRE-MATCHがnil以外で、ユーザーが選択せずに終了した場合、ユーザーエラー(user-error)が発生(raise)します。

@item
FALLBACKは、一次デフォルトDEFが@code{nil}の場合にのみ使用される二次デフォルトを指定します。
二次デフォルトは@code{magit-dwim-selection}の対象ではありません。DEFが@code{nil}であるが、FALLBACKがそうでない場合、この関数は、両方のデフォルトが@code{nil}であるかのように、常にユーザーに候補を選択するように求めます。

@item
": " がPROMPTに追加されます。

@item
PROMPTは、\" (default DEF|FALLBACK):
\"で終わるように変更されます。ただし、DEFまたはFALLBACKがnil以外であり、@code{ivy-mode}も@code{helm-mode}も有効になっていない場合、@code{magit-completing-read-function}は、デフォルト値の@code{magit-builtin-completing-read}に設定されています。
@end itemize
@end defun

@node 追加の補完オプション
@subsection 追加の補完オプション

@defopt magit-list-refs-sortby
ユーザーから1つまたは複数の参照(ref)を読み取る多くのコマンドでは、このオプションの値を使用して、参照(refs)の順序を制御できます。有効な値には、@code{git
for-each-ref}の@code{--sort}フラグで受け入れられるすべてのキーが含まれます。デフォルトでは、参照(ref)はフルネームのアルファベット順に並べ替えられます(例:
"refs/heads/master")。
@end defopt

@node Mouse Support
@section Mouse Support

セクションの見出しをダブルクリックすると、その本文の可視性が切り替えられます (存在する場合)。
同様に、左フリンジをクリックすると、適切なセクションの表示に切り替わります。

コンテキスト メニューが提供されますが、明示的に有効にする必要があります。 Emacs 28 以降で、グローバル モード
@code{context-menu-mode} を有効にします。 古い Emacs
リリースを使用している場合は、@code{magit-section-show-context-menu-for-emacs<28} を設定します。

@node Running Git
@section Running Git

@menu
* Viewing Git Output::       Viewing Git Output
* Git Process Status::       Git Process Status
* Gitを手動で実行::    Gitを手動で実行
* Git実行ファイル::    Git実行ファイル
* Global Git Arguments::     Global Git Arguments
@end menu

@node Viewing Git Output
@subsection Viewing Git Output

Magitは、副作用(プッシュ時など)または何らかの値(現在のブランチの名前など)を得るためにGitを実行します。

副作用のためにGitを実行すると、プロセス出力はリポジトリごとのログバッファに記録されます。これが期待どおりに進まない場合には@code{magit-process}コマンドを使用して参照できます。

最大`magit-process-log-max'個のGitコマンドの 出力/エラー が保持されます。

@table @asis
@item @kbd{$} (@code{magit-process})
@kindex $
@findex magit-process
このコマンドは、現在のリポジトリのプロセスバッファを表示します。
@end table

そのバッファ内では、セクションをナビゲートおよび表示するための通常のキーバインディングが利用可能です。これらに追加のコマンドが1つあります。

@table @asis
@item @kbd{k} (@code{magit-process-kill})
@kindex k
@findex magit-process-kill
このコマンドは、ポイントしているセクションで表されるプロセスを強制終了します。
@end table

@defvar magit-git-debug
このオプションは、gitエラーの追加レポートを有効にするかどうかを制御します。

Magitは基本的に次の2つの理由のいずれかでgitを呼び出します: 副作用のため、または標準出力を使って何かをするためです。

gitが副作用のために実行されると、エラーメッセージを含むその出力は、@code{$}を使用したときに表示されるプロセスバッファに送られます。

gitの出力が何らかの方法で消費されると、それもこのバッファに挿入するにはコストがかかりすぎますが、このオプションがnil以外で、gitがゼロ以外の終了ステータスで返される場合、少なくともこのバッファにその標準エラーが挿入されます。

これは、デバッグのみを目的としています。これを永続的に有効にしないでください。パフォーマンスに悪影響を及ぼします。

これは、デバッグのみを目的としています。 これを永続的に有効にしないでください。パフォーマンスに悪影響を及ぼす可能性があります。 また、git
がゼロ以外の終了ステータスで終了し、エラーメッセージを出力するからといって、それがこと Magit
に関してはエラーであるとは限らないことに注意してください。これが、通常、これらのエラーメッセージを非表示にするもう 1 つの理由です。
エラーメッセージが予期しない動作に関連しているかどうかは、ケースバイケースで判断する必要があります。

コマンド @code{magit-toggle-git-debug} は、この変数の値を変更します。
@end defvar

@defvar magit-process-extreme-logging
このオプションは、@code{magit-process-file}が@code{*Messages*}バッファにロギングするかどうかを制御します。

Magitが舞台裏でGitをどのように使用しているかを理解しようとするときに、一時的に使用することのみを目的としています。通常magit-processバッファに送られる出力は、引き続きそこに送られます。なお、すべての出力がこれら2つのバッファのいずれかに送られるわけではありません。
@end defvar

@node Git Process Status
@subsection Git Process Status

副作用のためにGitプロセスが実行されている場合、Magitは@code{magit-mode-line-process}
faceを使用して、モード行にインジケーターを表示します。

Gitプロセスが正常に終了すると、プロセスインジケーターはモードラインから直ちに削除されます。

Gitエラーの場合、プロセスインジケーターは削除されませんが、代わりに@code{magit-mode-line-process-error}
faceで強調表示され、プロセスバッファーからのエラーの詳細がマウスユーザーのためにツールチップとして提供されます。このエラーインジケータは、次のmagitバッファリフレッシュまでモード行に表示されます。

モード行にプロセスエラーを表示したくない場合は、@code{magit-process-display-mode-line-error}ユーザーオプションをカスタマイズします。

プロセスエラーは、ステータスバッファの先頭に追加で示されます。

@node Gitを手動で実行
@subsection Gitを手動で実行

MagitはGitと対話するための多くのEmacsコマンドを提供しますが、すべてを網羅しているわけではありません。そのような場合、既存のGitの知識が役立ちます。Magitは、シェルに切り替える代わりに、ミニバッファーに入力することで任意のGitコマンドを実行するためのいくつかのコマンドを提供します。

@table @asis
@item @kbd{!} (@code{magit-run})
@kindex !
@findex magit-run
このトランジェント(一時的)プレフィックス(接頭辞)コマンドは、それに従うサフィックス(接尾辞)コマンド群を結びつけ、そのサフィックスコマンドのどれかを選ぶまでの間、サフィックス(接尾辞)コマンド群を一時バッファ(temporary
buffer)に表示します。

@item @kbd{! !} (@code{magit-git-command-topdir})
@kindex ! !
@findex magit-git-command-topdir
このコマンドは、ユーザーからコマンドを読み取り、現在の作業ツリーの最上位ディレクトリで実行します。

文字列「git」は、ユーザーにコマンドの入力を求めるときの初期入力として使用されます。別のコマンドを実行するために削除できます。

@item @kbd{:} (@code{magit-git-command})
@itemx @kbd{! p}
@kindex :
@kindex ! p
@findex magit-git-command
このコマンドは、ユーザーからコマンドを読み取り、@code{default-directory}で実行します。プレフィックス引数を使用すると、コマンドは@code{default-directory}の代わりに現在の作業ツリーの最上位ディレクトリで実行されます。

文字列「git」は、ユーザーにコマンドの入力を求めるときの初期入力として使用されます。別のコマンドを実行するために削除できます。

@item @kbd{! s} (@code{magit-shell-command-topdir})
@kindex ! s
@findex magit-shell-command-topdir
このコマンドは、ユーザーからコマンドを読み取り、現在の作業ツリーの最上位ディレクトリで実行します。

@item @kbd{! S} (@code{magit-shell-command})
@kindex ! S
@findex magit-shell-command
このコマンドは、ユーザーからコマンドを読み取り、@code{default-directory}で実行します。プレフィックス引数を使用すると、コマンドは@code{default-directory}の代わりに現在の作業ツリーの最上位ディレクトリで実行されます。
@end table

@defopt magit-shell-command-verbose-prompt
シェルコマンドを読み取るときに上記のコマンドで使用されるプロンプトが、それが実行されるディレクトリを表示しているかどうか。
@end defopt

以下のサフィックスコマンドは、外部GUIツールを起動します。

@table @asis
@item @kbd{! k} (@code{magit-run-gitk})
@kindex ! k
@findex magit-run-gitk
このコマンドは、現在のリポジトリで@code{gitk}を実行します。

@item @kbd{! a} (@code{magit-run-gitk-all})
@kindex ! a
@findex magit-run-gitk-all
このコマンドは、現在のリポジトリで@code{gitk --all}を実行します。

@item @kbd{! b} (@code{magit-run-gitk-branches})
@kindex ! b
@findex magit-run-gitk-branches
このコマンドは、現在のリポジトリで@code{gitk --branches}を実行します。

@item @kbd{! g} (@code{magit-run-git-gui})
@kindex ! g
@findex magit-run-git-gui
このコマンドは、現在のリポジトリで@code{git gui}を実行します。

@item @kbd{! m} (@code{magit-git-mergetool})
@kindex ! m
@findex magit-git-mergetool
このコマンドは、現在のリポジトリで @samp{git mergetool --gui} を実行します。

前置引数を使用すると、これは一時的な前置コマンドとして機能し、ユーザーが mergetool を選択して一部の設定を変更できるようにします。
@end table

@node Git実行ファイル
@subsection Git実行ファイル

MagitがGitを呼び出すときは、@code{git}実行可能ファイルへの絶対パスを使用するか、その名前だけを使用して呼び出すことができます。

@code{git}をローカルで実行し、かつ、@code{system-type}が@code{windows-nt}(任意のWindowsバージョン)または@code{darwin}(macOS)の場合、@code{magit-git-executable}は
Magitがロードされるときに絶対パスに設定されます。

Windowsでは、絶対パスを使用する必要があります。Gitには実際の@code{git}バイナリ用のラッパースクリプトがいくつか付属していて、これらも@code{$PATH}に配置されており、バイナリの代わりにこれらのラッパーの1つを使用すると、パフォーマンスがひどく低下します。一部のmacOSユーザーの場合、実行可能ファイルの名前だけを使用するとパフォーマンスが低下するため、そのプラットフォームでもそういう実行を回避します。他のプラットフォームでは、名前だけを使用しても問題なく機能するようです。

Trampを介してリモートマシンで@code{git}を実行するときに絶対パスを使用すると、ローカルマシンに適した絶対パスを使用するのが問題になるため、リモートマシンで使用される名前またはパスを制御するために別のオプションが使用されます。

@defopt magit-git-executable
ローカルホスト上のMagitによって使用される@code{git}実行可能ファイル。これは、実行可能ファイルへの絶対パス、またはEmacsがそのようなことを行うための標準メカニズムを使用して実行可能ファイル自体を見つけられるようにする文字列"git"のいずれかである必要があります。
@end defopt

@defopt magit-remote-git-executable
Trampを介してリモートマシン上のMagitによって使用される@code{git}実行可能ファイル。通常、これは文字列"git"である必要があります。このオプションの代わりに@code{tramp-remote-path}をカスタマイズすることを検討してください。
@end defopt

Emacsが正しい実行可能ファイルを見つけられない場合は、これら2つのオプションのいずれかの値を明示的に設定することで回避できます。それを行うことは、応急修理と見なされるべきです。@code{exec-path}または@code{tramp-remote-path}の順序が正しいことを確認することをお勧めします。

@code{exec-path}は、Emacsの起動時に有効な@code{PATH}環境変数の値に基づいて設定されることに注意してください。あなたのシェルのinitファイルで@code{PATH}を設定した場合、そのシェルから開始した場合にのみEmacsに影響します(プロセスの環境は子プロセスにのみ渡され、他の任意のプロセスには渡されないため)。それがEmacsの起動方法ではない場合は、@code{exec-path-from-shell}パッケージが役立ちます。正直なところ、私もそれを応急修理だと思います。

コマンド@code{magit-debug-git-executable}は、Emacsが@code{git}を検索している場所を見つけるのに役立ちます。

@table @asis
@item @kbd{M-x magit-debug-git-executable}
@findex magit-debug-git-executable
このコマンドは、@code{magit-git-executable}および@code{magit-remote-git-executable}に関する情報を含むバッファを表示します。

@item @kbd{M-x magit-version}
@findex magit-version
このコマンドは、現在使用されているMagit、Git、およびEmacsのバージョンをエコー領域に表示します。非インタラクティブでは、これは単にMagitバージョンを返すだけです。
@end table

@node Global Git Arguments
@subsection Global Git Arguments

@defopt magit-git-global-arguments
ここで設定された引数は、git実行可能ファイルがサブプロセスとして実行されるたびに使用されます。これらは、実行可能ファイル自体の直後で、gitコマンドの前に配置されます。@code{git
HERE... COMMAND REST}のように。有効な引数については→ 
@ifinfo
@ref{git,,,gitman,}
@end ifinfo
@ifhtml
@c html
@c end html
the <a href="http://git-scm.com/docs/git">git(1)</a> manpage.
@end ifhtml
@iftex
the git(1) manpage.
@end iftex

特にTrampを使用して古いGitバージョンのサーバーに接続している場合は、ここに何を追加するかに注意してください。自分が何をしているかを本当に理解していない限り、デフォルト値の一部であるものは絶対に削除しないでください。そして、何かを追加する前に、非常によく考えてください。それはMagitがどんな目的であれGitを実行するたびに使用されます。
@end defopt

@node Inspecting
@chapter Inspecting

Magitが提供する機能は、既存のデータの検査、既存のデータの操作または新しいデータの追加、データの転送の3つのグループに大別できます。もちろん、それはかなり大雑把な区別であり、しばしば不十分ですが、まったく区別しないよりも便利です。この節はデータの検査に関係し、次の2つはデータの操作と転送に関係します。次に、この区別に簡単に当てはまらないその他の機能に関する節が続きます。

もちろん、他の区別も意味があります。Gitでの磁器コマンドと配管コマンドの区別です。これは、ほとんどの場合、Emacsでのインタラクティブコマンドと非インタラクティブ機能の区別に相当します。前述のすべての節は、主に磁器に関係しています。Magitの配管コマンドレイヤーについては後で説明します。

@menu
* Status Buffer::            Status Buffer
* Repository List::          Repository List
* Logging::                  Logging
* Diffing::                  Diffing
* Ediffing::                 Ediffing
* References Buffer::        References Buffer
* Bisecting::                Bisecting
* Visiting Files and Blobs::  Visiting Files and Blobs
* Blaming::                  Blaming
@end menu

@node Status Buffer
@section Status Buffer

他のMagitバッファ達では、例えば、1つの特定のdiffまたは1つの特定のログや、ステータスバッファならばステージされた変更とステージされていない変更のdiff、プッシュされていないコミットとプルされていないコミットのログ、スタッシュと追跡されていないファイル(untracked
files)のリスト、および現在のブランチに関連する情報が含まれます。

特定の不完全な操作の途中(たとえば、マージによって競合が発生した場合)、操作の続行または中止に役立つ追加情報が表示されます。

コマンド@code{magit-status}は、現在のリポジトリに属するステータスバッファを別のウィンドウに表示します。このコマンドは頻繁に使用されるため、グローバルにバインドすべきです。我々は@code{C-x
g}をお勧めします:

@lisp
(global-set-key (kbd "C-x g") 'magit-status)
@end lisp

@table @asis
@item @kbd{C-x g} (@code{magit-status})
@kindex C-x g
@findex magit-status
既存のGitリポジトリ内から呼び出されると、このコマンドはバッファ内のそのリポジトリのステータスを表示します。

現在のディレクトリがGitリポジトリ内にない場合、このコマンドは、オプション@code{magit-repository-directories}に応じて、代わりに既存のリポジトリまたは任意のディレクトリの入力を求め、選択したリポジトリのステータスを表示します。

@itemize
@item
そのオプションで既存のリポジトリ達が指定されている場合、ユーザーはそれらの1つを選択するように求められます。

@item
それ以外の場合、ユーザーは通常のファイル名補完を使用して任意のディレクトリを選択するように求められます。選択したディレクトリが既存の作業ツリーの最上位ディレクトリである場合、そのステータスバッファが表示されます。

@item
それ以外の場合、ユーザーは選択したディレクトリを新しいリポジトリとして初期化するように提案されます。リポジトリを作成すると、そのステータスバッファが表示されます。
@end itemize

これらのフォールバック動作は、1つ以上のプレフィックス引数を使用して強制することもできます。

@itemize
@item
2ストロークのプレフィックス引数(より正確には16以上の数値プレフィックス値)を使用して、任意のディレクトリが読み取られ、上記のように処理されます。コマンド@code{magit-init}を使用して同じことを実行できます。

@item
1ストロークのプレフィックス引数を使用すると、既存のリポジトリがユーザーから読み取られます。または、@code{magit-repository-directories}の値に基づいてリポジトリが見つからない場合、動作は2ストロークのプレフィックス引数の場合と同じです。
@end itemize
@end table

@defopt magit-repository-directories
Gitリポジトリであるか、Gitリポジトリを含むディレクトリのリスト。

各要素の形式は@code{(DIRECTORY
.
DEPTH)}です。DIRECTORYは、ディレクトリまたはディレクトリファイル名で文字列である必要があります。DEPTHは整数でGitリポジトリを検索する最大の深さを指定します。DEPTHが0の場合は、DIRECTORY自体のみを追加します。

このオプションは、@code{magit-list-repositories}によってリストされるリポジトリを制御します。また、@code{magit-status}(を参照)にも驚くべき方法で影響を及ぼします(上記を参照)。
@end defopt

@deffn Command magit-status-quick
このコマンドは、@code{magit-status}の代替になり、通常はステータスバッファのリフレッシュを回避します。

現在のGitリポジトリのステータスバッファが存在するが、選択したフレームに表示されていない場合は、リフレッシュされずに表示されます。

選択したフレームにステータスバッファが表示されている場合、このコマンドはステータスバッファをリフレッシュします。

プレフィックス引数は@code{magit-status}の場合と同じ意味を持ち、さらにバッファをリフレッシュします。

このコマンドを使用するには、以下をinitファイルに追加します:

@lisp
(global-set-key (kbd "C-x g") 'magit-status-quick).
@end lisp

これを行った後、バッファを再表示してすぐにリフレッシュする場合は、@code{C-x g}に続けて@code{g}と入力します。

可能な代替コマンドは@code{magit-display-repository-buffer}です。ステータスバッファだけでなく、現在のリポジトリに属する既存のMagitバッファの表示をサポートします。
@end deffn

@deffn Command ido-enter-magit-status
ファイルを開くために使用されるIdoプロンプトから、代わりに@code{magit-status}にドロップ(drop)します。これは@code{ido-magic-delete-char}に似ており、その名前にもかかわらず、通常はDiredバッファが作成されます。

このコマンドを使用可能にするには、以下のようなものを使用します:

@lisp
(add-hook 'ido-setup-hook
          (lambda ()
            (define-key ido-completion-map
              (kbd \"C-x g\") 'ido-enter-magit-status)))
@end lisp

Emacs
25.1以降、IdoキーマップはIdoが呼び出されるたびではなく、一度だけ定義されるため、他のほとんどすべてのキーマップと同じように変更できるようになりました。

@lisp
(define-key ido-common-completion-map
  (kbd \"C-x g\") 'ido-enter-magit-status)
@end lisp
@end deffn

@menu
* Status Sections::          Status Sections
* Status Header Sections::   Status Header Sections
* Status Module Sections::   Status Module Sections
* Status Options::           Status Options
@end menu

@node Status Sections
@subsection Status Sections

ステータスバッファの内容は、フック@code{magit-status-sections-hook}を使用して制御されます。このようなフックとそれらをカスタマイズする方法についてはこちらを参照して下さい(@ref{Section
Hooks})。

@defopt magit-status-sections-hook
フックを実行して、セクションをステータスバッファに挿入します。
@end defopt

デフォルトでは、そのフックの最初の関数は@code{magit-insert-status-headers}です。次節で説明します。デフォルトでは、以下の関数もそのフックのメンバーです。

@defun magit-insert-merge-log
進行中のマージのセクションを挿入します。マージされているヘッド達を表示します。マージが進行中でない場合は、何もしません。
@end defun

@defun magit-insert-rebase-sequence
進行中のリベースシーケンスのセクションを挿入します。そのようなシーケンスが進行中でない場合は、何もしません。
@end defun

@defun magit-insert-am-sequence
進行中のパッチ適用シーケンスのセクションを挿入します。そのようなシーケンスが進行中でない場合は、何もしません。
@end defun

@defun magit-insert-sequencer-sequence
進行中のチェリーピックまたはrevertシーケンスのセクションを挿入します。そのようなシーケンスが進行中でない場合は、何もしません。
@end defun

@defun magit-insert-bisect-output
bisectしている間、@code{git bisect}からの出力を含むセクションを挿入します。
@end defun

@defun magit-insert-bisect-rest
bisectしている間、bisect態を視覚化するセクションを挿入します。
@end defun

@defun magit-insert-bisect-log
bisectしている間、bisectの進行状況をlogするセクションを挿入します。
@end defun

@defun magit-insert-untracked-files
たぶん、追跡されていないファイル(untracked file)のリストまたはツリーを挿入します。

@code{status.showUntrackedFiles}の値に応じてこれを行います。値が@code{all}であっても、Magitは最初はディレクトリのみを表示することに注意してください。ただし、ディレクトリセクションは@code{TAB}を使用して展開できます。
@end defun

@defun magit-insert-unstaged-changes
ステージされていない変更(unstaged changes)を示すセクションを挿入します。
@end defun

@defun magit-insert-staged-changes
ステージされた変更(staged changes)を表すセクションを挿入します。
@end defun

@defun magit-insert-stashes &optional ref heading
"refs/stash"のreflogを示す@code{stashes}セクションを挿入します。オプションのREFがnil以外の場合は、代わりにそのためのreflogを表示します。オプションのHEADINGがnil以外の場合は、"Stashes:"の代わりにセクション見出しとして使用します。
@end defun

@defun magit-insert-unpulled-from-upstream
アップストリームブランチからまだプルされていないコミットを示すセクションを挿入します。
@end defun

@defun magit-insert-unpulled-from-pushremote
プッシュリモートブランチからまだプルされていないコミットを示すセクションを挿入します。
@end defun

@defun magit-insert-unpushed-to-upstream
まだアップストリームにプッシュされていないコミットを示すセクションを挿入します。
@end defun

@defun magit-insert-unpushed-to-pushremote
まだプッシュリモートにプッシュされていないコミットを示すセクションを挿入します。
@end defun

以下の関数を上記のフックに追加することもできます:

@defun magit-insert-tracked-files
追跡中のファイル(tracked files)のツリーを挿入します。
@end defun

@defun magit-insert-ignored-files
無視されたファイル(ignored files)のツリーを挿入します。@code{D = f <DIRECTORY> RET
g}を使用して、現在のバッファ内のログを特定のディレクトリに制限することができます。これを行うと、このコマンドにも影響します。

ログフィルターの使用により、対象ファイル達を絞り込めます。その場合、この関数は最初のファイルのみを尊重し、それがディレクトリである場合に限ります。
@end defun

@defun magit-insert-skip-worktree-files
スキップワークツリーファイル(skip-worktree
files)のツリーを挿入します。@code{magit-buffer-diff-files}の最初の要素がディレクトリである場合は、リストをその下のファイル達だけに制限します。その変数の値は、@code{D
-- DIRECTORY RET g}を使用して設定できます。
@end defun

@defun magit-insert-assumed-unchanged-files
変更されていないと想定されるファイルのツリーを挿入します。@code{magit-buffer-diff-files}の最初の要素がディレクトリである場合は、リストをその下のファイル達に制限します。その変数の値は、@code{D
-- DIRECTORY RET g}を使用して設定できます。
@end defun

@defun magit-insert-unpulled-or-recent-commits
プルされていないコミットまたは最近のコミットを示すセクションを挿入します。アップストリームが現在のブランチ用に構成されていて、それが現在のブランチよりも進んでいる場合は、欠落しているコミットを表示します。それ以外の場合は、最後の@code{magit-log-section-commit-count}コミットを表示します。
@end defun

@defun magit-insert-recent-commits
最後の@code{magit-log-section-commit-count}コミットを示すセクションを挿入します。
@end defun

@defopt magit-log-section-commit-count
(プルされていないコミットがない場合、)
@code{magit-insert-recent-commits}および@code{magit-insert-unpulled-or-recent-commits}の最近のコミット数が表示されます。
@end defopt

@defun magit-insert-unpulled-cherries
プルされていないコミットを示すセクションを挿入します。@code{magit-insert-unpulled-commits}と同様ですが、まだ適用されていない各コミット(つまり、ローカルコミットと共有されていないパッチID(patch-id)を持つコミット)の前に"+"を付け、他のすべてのコミットには"-"を付けます。
@end defun

@defun magit-insert-unpushed-cherries
プッシュされていないコミットを示すセクションを挿入します。@code{magit-insert-unpushed-commits}と同様ですが、アップストリームにまだ適用されていない各コミット(つまり、パッチID(patch-id)のあるコミットはアップストリームコミットと共有されていません)の前に"+"を付け、他のすべてのコミットには"-"を付けます。
@end defun

ここで使用できるその他のセクションインサーターについてはこちらを参照して下さい(@ref{References Buffer})。

@node Status Header Sections
@subsection Status Header Sections

ステータスバッファの内容は、フック@code{magit-status-sections-hook}を使用して制御されます(see
@ref{Status Sections})。

デフォルトでは、@code{magit-insert-status-headers}がそのフック変数の最初のメンバーです。

@defun magit-insert-status-headers
@code{magit-status-mode}バッファに適したヘッダーセクションを挿入します。セクションは、フック@code{magit-status-headers-hook}で関数達を実行することによって挿入されます。
@end defun

@defopt magit-status-headers-hook
フックを実行して、ヘッダーセクションをステータスバッファーに挿入します。

このフックは@code{magit-insert-status-headers}によって実行され、それらの関数は@code{magit-status-sections-hook}のメンバーである必要があります。
@end defopt

デフォルトでは、以下の関数が上記フックのメンバーです:

@defun magit-insert-error-header
たった今発生したGitエラーに関するメッセージを示すヘッダー行を挿入します。

この関数は、副作用のためにGitが実行されたときに発生した最後のエラーのみを認識します。たとえば、diffの生成中にエラーが発生した場合、そのエラーは挿入されません。ステータスバッファをリフレッシュすると、このセクションは再び表示されなくなります。
@end defun

@defun magit-insert-diff-filter-header
有効なdiffフィルター達を示すヘッダー行を挿入します。
@end defun

@defun magit-insert-head-branch-header
現在のブランチまたはdetachされた@code{HEAD}に関するヘッダー行を挿入します。
@end defun

@defun magit-insert-upstream-branch-header
通常は現在のブランチにプル(pull into)されるブランチに関するヘッダー行を挿入します。
@end defun

@defun magit-insert-push-branch-header
現在のブランチが通常プッシュされるブランチに関するヘッダー行を挿入します。
@end defun

@defun magit-insert-tags-header
タグと@code{HEAD}の間のコミット数とともに、現在または次のタグ、あるいはその両方に関するヘッダー行を挿入します。
@end defun

以下の関数を上記のフックに追加することもできます:

@defun magit-insert-repo-header
リポジトリのトップレベルへのパスを表すヘッダー行を挿入します。
@end defun

@defun magit-insert-remote-header
現在のブランチのリモートに関するヘッダー行を挿入します。

現在のブランチにリモートが構成されていない場合は、フォールバックして"origin"リモートを表示します。存在しない場合は、アルファベット順に最初のリモートを表示します。
@end defun

@defun magit-insert-user-header
現在のユーザーに関するヘッダー行を挿入します。
@end defun

@node Status Module Sections
@subsection Status Module Sections

ステータスバッファの内容は、フック@code{magit-status-sections-hook}を使用して制御されます(see
@ref{Status Sections})。

デフォルトでは、@code{magit-insert-modules}はそのフック変数のメンバーでは「ありません」。

@defun magit-insert-modules
サブモジュールセクションを挿入します。

フック@code{magit-module-sections-hook}は、挿入されるモジュールセクションを制御し、オプション@code{magit-module-sections-nested}は、それらを追加のセクションでラップ(wrap)するかどうかを制御します。
@end defun

@defopt magit-module-sections-hook
@code{magit-insert-modules}によって実行されるフック。
@end defopt

@defopt magit-module-sections-nested
このオプションは、@code{magit-insert-modules}が挿入されたセクションを追加のセクションでラップ(wrap)するかどうかを制御します。

これがnil以外の場合、単一のトップレベルセクションのみが挿入されます。nilの場合、@code{magit-module-sections-hook}にリストされているすべてのセクションがトップレベルのセクションになります。
@end defopt

@defun magit-insert-modules-overview
すべてのサブモジュールのセクションを挿入します。セクションごとに、パスとブランチと、@code{git describe
--tags}の出力を挿入します。それができない場合は、省略されたHEADコミットハッシュを挿入します。

このようなサブモジュールセクションで@code{RET}を押すと、独自のステータスバッファが表示されます。"Modules"セクションで@code{RET}を押すと、別のバッファにあるサブモジュールのリストが表示されます。これは、スーパーリポジトリ(super-repository)のステータスバッファに表示されない追加情報を表しています。
@end defun

@defun magit-insert-modules-unpulled-from-upstream
まだアップストリームからプルされていないモジュールのセクションを挿入します。これらのセクションを展開して、それぞれのコミットを表示できます。
@end defun

@defun magit-insert-modules-unpulled-from-pushremote
プッシュリモートからまだプルされていないモジュールのセクションを挿入します。これらのセクションを展開して、それぞれのコミットを表示できます。
@end defun

@defun magit-insert-modules-unpushed-to-upstream
まだアップストリームにプッシュされていないモジュールのセクションを挿入します。これらのセクションを展開して、それぞれのコミットを表示できます。
@end defun

@defun magit-insert-modules-unpushed-to-pushremote
まだプッシュリモートにプッシュされていないモジュールのセクションを挿入します。これらのセクションを展開して、それぞれのコミットを表示できます。
@end defun

@node Status Options
@subsection Status Options

@defopt magit-status-refresh-hook
ステータスバッファがリフレッシュされた後、フックが実行されます。
@end defopt

@defopt magit-status-margin
このオプションは、欄外(margin)が最初にMagit-Statusモードのバッファに表示されるかどうか、およびそのフォーマット方法を指定します。

値の形式は@code{(INIT STYLE WIDTH AUTHOR AUTHOR-WIDTH)}です。

@itemize
@item
INITがnil以外の場合、欄外(margin)が最初に表示されます。
@item
STYLEは、作成者(author)またはコミッター(committer)の日付をフォーマットする方法を制御します。@code{age}(コミットの経過時間を示す)または@code{age-abbreviated}(時間単位を文字に短縮する)または実際の日付を表す文字列(@code{format-time-string}に適しています)のいずれかになります。オプション@code
{magit-log-margin-show-committer-date}は、表示される日付を制御します。
@item
WIDTHは、欄外(margin)の幅を制御します。これは上位互換性のために存在し、現在値を変更すべきではありません。
@item
AUTHORは、作成者の名前もデフォルトで表示されるかどうかを制御します。
@item
AUTHOR-WIDTHは整数である必要があります。作成者の名前が表示されている場合、これはそのために使用されるスペース(空き)の量を指定します。
@end itemize
@end defopt

ステータスバッファに関するその他のオプションについては、前節も参照してください。

@node Repository List
@section Repository List

@deffn Command magit-list-repositories
このコマンドは、別のバッファにあるリポジトリのリストを表示します。

オプション@code{magit-repository-directories}および@code{magit-repository-directories-depth}は、表示されるリポジトリを制御します。
@end deffn

@defopt magit-repolist-columns
このオプションは、コマンド@code{magit-list-repositories}によって表示される列(columns)とその表示方法を制御します。

各要素の形式は@code{(HEADER WIDTH FORMAT PROPS)}です。

HEADERは、ヘッダーに表示される文字列です。WIDTHは、列の幅です。FORMATは、1つの引数とリポジトリID(通常はそのベース名)と作業ツリーの最上位に結び付けられたされた@code{default-directory}を使用して呼び出される関数です。挿入する文字列またはnilを返す必要があります。PROPSは、キー@code{:right-align}と@code{:pad-right}と@code{:sort}をサポートするalistです。

@code{:sort} 関数は、 @code{tabulated-list--get-sort} の docstring
に記述されている奇妙なインターフェースを持っています。 あるいは @code{<} や @code{magit-repolist-version<}
を使用できます。これらの関数は、インターフェイスを満たす関数に自動的に置き換えられます。 @code{:sort} を @code{nil}
に設定してソートを禁止します。 指定しない場合、列はデフォルトのソーターを使用してソート可能です。

あなたは列ごとに1文字だけを使用し、列間にパディングなしで数値列の範囲を表示したい場合があるかもしれません。その場合は、適切なHEADERを使用し、WIDTHを1に設定し、@code{:pad-right}を9に設定する必要があります。@code{+}は、9より大きい数値に置き換えられます。
@end defopt

@noindent
上記のオプションに以下の関数を追加できます:

@defun magit-repolist-column-ident
この関数は、リポジトリのIDを挿入します。 通常、これは単なるベース名です。
@end defun

@defun magit-repolist-column-path
この関数は、リポジトリの絶対パスを挿入します。
@end defun

@defun magit-repolist-column-version
この関数は、リポジトリの@code{HEAD}リビジョンの説明を挿入します。
@end defun

@defun magit-repolist-column-branch
この関数は、現在のブランチの名前を挿入します。
@end defun

@defun magit-repolist-column-upstream
この関数は、現在のブランチのアップストリームブランチの名前を挿入します。
@end defun

@defun magit-repolist-column-branches
この関数は、ブランチの数を挿入します。
@end defun

@defun magit-repolist-column-stashes
この関数は、スタッシュの数を挿入します。
@end defun

@defun magit-repolist-column-flag
この関数は、@code{magit-repolist-column-flag-alist}で指定されたフラグ(flag)を挿入します。

デフォルトでは、コミットされていない変更(uncommitted changes)があるかどうかを示します。

@itemize
@item
@code{N}ならば、追跡されていないファイル(untracked file)が少なくとも1つある。
@item
@code{U}ならばステージされていないファイル(unstaged file)が少なくとも1つある。
@item
@code{S}ならばステージされたファイル(staged file)が少なくとも1つある。
@end itemize

これら適用するもののうち、最初の１つだけが表示されます。
@end defun

@defun magit-repolist-column-unpulled-from-upstream
この関数は、現在のブランチにないアップストリームコミットの数を挿入します。
@end defun

@defun magit-repolist-column-unpulled-from-pushremote
この関数は、現在のブランチではなく、プッシュブランチにコミット数を挿入します。
@end defun

@defun magit-repolist-column-unpushed-to-upstream
この関数は、現在のブランチにコミット数を挿入しますが、そのアップストリームには挿入しません。
@end defun

@defun magit-repolist-column-unpushed-to-pushremote
この関数は、現在のブランチにコミット数を挿入しますが、プッシュブランチには挿入しません。
@end defun

@noindent
以下のコマンドが repolist バッファーで使用できます:

@table @asis
@item @kbd{@key{RET}} (@code{magit-repolist-status})
@kindex RET
@findex magit-repolist-status
このコマンドは、ポイントでの定義のログを表示します。

@item @kbd{m} (@code{magit-repolist-mark})
@kindex m
@findex magit-repolist-mark
このコマンドは、ポイントでのリポジトリをマークします。

@item @kbd{u} (@code{magit-repolist-unmark})
@kindex u
@findex magit-repolist-unmark
このコマンドは、ポイントでのリポジトリのマークを解除します。

@item @kbd{f} (@code{magit-repolist-fetch})
@kindex f
@findex @kbd{f} (@code{magit-repolist-fetch})
このコマンドは、マークされたすべてのリポジトリを取得します。
リポジトリがマークされていない場合は、表示されているすべてのリポジトリを取得するよう提案されます。

@item @kbd{5} (@code{magit-repolist-find-file-other-frame})
@kindex 5
@findex magit-repolist-find-file-other-frame
このコマンドは、相対ファイル名を (補完なしで) 読み取り、マークされた各リポジトリのそれぞれのファイルを新しいフレームで開きます。
リポジトリがマークされていない場合は、表示されているすべてのリポジトリに対してこれを行うことを提案します。
@end table

@node Logging
@section Logging

ステータスバッファには、プッシュされていないコミットとプルされていないコミットのログが含まれていますが、それだけでは明らかに不十分です。@code{l}のトランジェントプレフィックスコマンド@code{magit-log}には、個別のログバッファに特定のログを表示するいくつかのサフィックスコマンドがあります。

他のトランジェントプレフィックスコマンドと同様に、@code{magit-log}にも、サフィックスコマンドの1つを呼び出す前に変更できるいくつかのインフィックス引数達があります。ただし、ログ用トランジェントコマンドの場合、これらの引数は、@code{magit-prefix-use-buffer-arguments}の値に応じて、現在のリポジトリのログバッファで現在使用されている引数から取得される場合があります(@ref{Transient
Arguments and Buffer Variables})。

さまざまな引数の情報ついては→ 
@ifinfo
@ref{git-log,,,gitman,}
@end ifinfo
@ifhtml
@c html
@c end html
the <a href="http://git-scm.com/docs/git-log">git-log(1)</a> manpage.
@end ifhtml
@iftex
the git-log(1) manpage.
@end iftex

スイッチ@code{++order=VALUE}は、@code{git
log}に渡される前に、@code{--author-date-order}または@code{--date-order}または@code{--topo-order}のいずれかに変換されます。

ログ用トランジェントコマンドには、いくつかのreflogコマンドもあります。こちらを参照して下さい(@ref{Reflog})。

@table @asis
@item @kbd{l} (@code{magit-log})
@kindex l
@findex magit-log
このトランジェント(一時的)なプレフィックス(接頭辞)コマンドは、それに従うサフィックス(接尾辞)コマンドを適切なインフィックス(中置)引数とともに結び付け、いずれかのサフィックスコマンドを選択するまでの間、そのインフィックス引数達とサフィックスコマンド達を一時バッファ(temporary
buffer)に表示します。

@item @kbd{l l} (@code{magit-log-current})
@kindex l l
@findex magit-log-current
現在のブランチのログを表示します。@code{HEAD}が切り離されている(detached)か、プレフィックス引数が付いている場合、ミニバッファから読み取られた1つ以上のリビジョン(rev)のログを表示します。

@item @kbd{l h} (@code{magit-log-head})
@kindex l h
@findex magit-log-head
@code{HEAD}のログを表示します。

@item @kbd{l u} (@code{magit-log-related})
@kindex l u
@findex magit-log-related
現在のブランチと、そのアップストリームと、プッシュターゲットのログを表示します。
アップストリームがローカルブランチの場合は、独自のアップストリームも表示します。 @code{HEAD}
がデタッチされていると、そのログと、以前にチェックアウトされたブランチと、その上流およびプッシュターゲットが表示されます。

@item @kbd{l o} (@code{magit-log-other})
@kindex l o
@findex magit-log-other
ミニバッファから読み取られた1つ以上のリビジョン(rev)のログを表示します。ユーザーは、スペースまたは範囲で区切られた1つまたは複数のリビジョンを入力できますが、完了候補として使用できるのは、ブランチ、タグ、およびポイントでのコミットの表現のみです。

@item @kbd{l L} (@code{magit-log-branches})
@kindex l L
@findex magit-log-branches
すべてのローカルブランチと@code {HEAD}のログを表示します。

@item @kbd{l b} (@code{magit-log-all-branches})
@kindex l b
@findex magit-log-all-branches
すべてのローカルブランチとリモートブランチと@code{HEAD}のログを表示します。

@item @kbd{l a} (@code{magit-log-all})
@kindex l a
@findex magit-log-all
すべての参照(reference)と@code{HEAD}のログを表示します。
@end table

現在のバッファが訪問しているファイルまたはblobのログを表示する2つの追加コマンドが存在します(@ref{Commands for Buffers
Visiting Files})。コマンド@code{magit-cherry}もログを表示します(@ref{Cherries})。

@menu
* Refreshing Logs::          Refreshing Logs
* Log Buffer::               Log Buffer
* Log Margin::               Log Margin
* Select from Log::          Select from Log
* Reflog::                   Reflog
* Cherries::                 Cherries
@end menu

@node Refreshing Logs
@subsection Refreshing Logs

@code{L}のトランジェントプレフィックスコマンド@code{magit-log-refresh}を使用すると、表示されるログを変更せずに、現在のバッファで使用されているログ引数を変更できます。これは専用のログバッファで機能しますが、ステータスバッファでも機能します。

@table @asis
@item @kbd{L} (@code{magit-log-refresh})
@kindex L
@findex magit-log-refresh
このトランジェント(一時的)なプレフィックス(接頭辞)コマンドは、それに従うサフィックス(接尾辞)コマンドを適切なインフィックス(中置)引数とともに結び付け、いずれかのサフィックスコマンドを選択するまでの間、そのインフィックス引数達とサフィックスコマンド達を一時バッファ(temporary
buffer)に表示します。

@item @kbd{L g} (@code{magit-log-refresh})
@kindex L g
@findex magit-log-refresh
このサフィックスコマンドは、現在のバッファのローカルログ引数を設定します。

@item @kbd{L s} (@code{magit-log-set-default-arguments})
@kindex L s
@findex magit-log-set-default-arguments
このサフィックスコマンドは、現在のバッファと同じタイプのバッファのデフォルトのログ引数を設定します。
同じタイプの他の既存のバッファは、ローカル値がすでに初期化されているため、影響を受けません。

@item @kbd{L w} (@code{magit-log-save-default-arguments})
@kindex L w
@findex magit-log-save-default-arguments
このサフィックスコマンドは、現在のバッファと同じタイプのバッファのデフォルトのログ引数を設定し、将来のセッションのために値を保存します。
同じタイプの他の既存のバッファは、ローカル値がすでに初期化されているため、影響を受けません。

@item @kbd{L t} (@code{magit-toggle-margin})
@kindex L t
@findex magit-toggle-margin
欄外(margin)を表示または非表示にします。
@end table

@node Log Buffer
@subsection Log Buffer

@table @asis
@item @kbd{L} (@code{magit-log-refresh})
@kindex L
@findex magit-log-refresh
このトランジェント(一時的)なプレフィックス(接頭辞)コマンドは、それに従うサフィックス(接尾辞)コマンドを適切なインフィックス(中置)引数とともに結び付け、いずれかのサフィックスコマンドを選択するまでの間、そのインフィックス引数達とサフィックスコマンド達を一時バッファ(temporary
buffer)に表示します。

参照(@ref{Refreshing Logs})

@item @kbd{q} (@code{magit-log-bury-buffer})
@kindex q
@findex magit-log-bury-buffer
現在のバッファまたはリビジョンバッファを同じフレームに隠し(bury)ます。@code{magit-mode-bury-buffer}(を参照)と同様ですが、現在のフレームに表示されている場合は、代わりにマイナスのプレフィックス引数を使用してリビジョンバッファを隠します。

@item @kbd{C-c C-b} (@code{magit-go-backward})
@kindex C-c C-b
@findex magit-go-backward
現在のバッファの履歴を逆方向に移動します。

@item @kbd{C-c C-f} (@code{magit-go-forward})
@kindex C-c C-f
@findex magit-go-forward
現在のバッファの履歴を順方向に進めます。

@item @kbd{C-c C-n} (@code{magit-log-move-to-parent})
@kindex C-c C-n
@findex magit-log-move-to-parent
現在のコミットの親に移動します。デフォルトでは、これは最初の親ですが、数値の接頭辞を使用して別の親を指定できます。

@item @kbd{j} (@code{magit-log-move-to-revision})
@kindex j
@findex magit-log-move-to-revision
リビジョンを読み取り、現在のログバッファでそのリビジョンに移動します。

選択したreferenceまたはリビジョンが現在のログバッファに表示されていない場合は、そのことをユーザーに通知し、他に何もしません。

ログバッファの外部で呼び出された場合は、最初に現在のリポジトリのログバッファを表示します。 必要に応じて作成します。

@item @kbd{@key{SPC}} (@code{magit-diff-show-or-scroll-up})
@kindex SPC
@findex magit-diff-show-or-scroll-up
ポイントしているモノのcommitまたはdiffバッファを更新します。

適切なバッファ内のポイントでコミットまたはスタッシュを表示するか、そのバッファが現在のフレームにすでに表示されていて、そのコミットまたはスタッシュに関する情報が含まれている場合は、代わりにバッファを上にスクロールします。ポイントにコミットまたはスタッシュがない場合は、コミットのプロンプトを表示します。

@item @kbd{@key{DEL}} (@code{magit-diff-show-or-scroll-down})
@kindex DEL
@findex magit-diff-show-or-scroll-down
ポイントしているモノのcommitまたはdiffバッファを更新します。

適切なバッファ内のポイントでコミットまたはスタッシュを表示するか、そのバッファが現在のフレームにすでに表示されていて、そのコミットまたはスタッシュに関する情報が含まれている場合は、代わりにバッファを下にスクロールします。ポイントにコミットまたはスタッシュがない場合は、コミットのプロンプトを表示します。

@item @kbd{=} (@code{magit-log-toggle-commit-limit})
@kindex =
@findex magit-log-toggle-commit-limit
現在のログバッファで表示制限されているコミットの数を切り替えます。コミットの数が現在表示制限されている場合は、その制限を削除します。それ以外の場合は256に設定します。

@item @kbd{+} (@code{magit-log-double-commit-limit})
@kindex +
@findex magit-log-double-commit-limit
現在のログバッファで表示制限されているコミット数を2倍に拡張します。

@item @kbd{-} (@code{magit-log-half-commit-limit})
@kindex -
@findex magit-log-half-commit-limit
現在のログバッファのコミット数表示制限数を半分に狭めます。
@end table

@defopt magit-log-auto-more
最後のエントリを超えて移動すると、さらにログエントリが自動的に挿入されます。@code{magit-goto-*-section}コマンドを使用して最後のエントリを通過する場合にのみ考慮されます。
@end defopt

@defopt magit-log-show-refname-after-summary
コミットの要約の後にrefnameを表示するかどうか。これは、あなたが非常に長いブランチ名を使用する場合に役立ちます。
@end defopt

Magitは、Gitの表示方法とは少し異なる方法でreferenceをログに表示します。

ローカルブランチは青色で、リモートブランチは緑色です。 もちろん、他の種類のreferenceに使用される色と同様に、使用するテーマによって異なります。
現在のブランチは、それぞれのリモートの@code{HEAD}ブランチであるリモートブランチと同様に、枠で囲まれています。

ローカルブランチとそのプッシュターゲットポイントが同じコミットにある場合、スペースを保持し、その関係を表示するために、それらの名前が組み合わされます。
例えば:

@example
origin/feature
[green][blue-]

は、下記の代わりです

feature origin/feature
[blue-] [green-------]
@end example

また、トランジェントコマンドには@code{--show-signature}引数がありますが、Magitはデフォルトではコミットごとに1行しか使用しないため、有効にすると実際には使用されないことに注意してください。代わりに、@code{magit-signature-*}という名前のface達を使用して、署名された(signed)コミットオブジェクトの有効性を色分けして示します。各@code{magit-signature-*}を参照して下さい。

@code {magit-log-margin}の説明についてはこちらを参照して下さい(@ref{Log Margin})。

@node Log Margin
@subsection Log Margin

1つ以上のログを表示するバッファーでは、欄外(margin)内に各コミットに関する追加情報を表示することができます。欄外の構成に使用されるオプションの名前は@code{magit-INFIX-margin}です。ここで、INFIX(訳注:INFIX:インフィックス;中置引数)はそれぞれのメジャーモード@code{magit-INFIX-mode}と同じです。通常のログバッファでは、@code{magit-log-margin}になります。

@defopt magit-log-margin
このオプションは、欄外(margin)が最初にMagit-Logモードのバッファに表示されるかどうか、およびそのフォーマット方法を指定します。

値の形式は@code{(INIT STYLE WIDTH AUTHOR AUTHOR-WIDTH)}です。

@itemize
@item
INITがnil以外の場合、欄外(margin)が最初に表示されます。
@item
STYLEは、作成者(author)またはコミッター(committer)の日付をフォーマットする方法を制御します。@code{age}(コミットの経過時間を示す)または@code{age-abbreviated}(時間単位を文字に短縮する)または実際の日付を表す文字列(@code{format-time-string}に適しています)のいずれかになります。オプション@code
{magit-log-margin-show-committer-date}は、表示される日付を制御します。
@item
WIDTHは、欄外(margin)の幅を制御します。これは上位互換性のために存在し、現在値を変更すべきではありません。
@item
AUTHORは、作成者の名前もデフォルトで表示されるかどうかを制御します。
@item
AUTHOR-WIDTHは整数である必要があります。作成者の名前が表示されている場合、これはそのために使用されるスペース(空き)の量を指定します。
@end itemize
@end defopt

@code{magit}がロードされる「前」に@code{magit-log-margin}をカスタマイズすることで、すべての@code{magit-INFIX-margin}オプションのSTYLEとAUTHOR-WIDTHを同じ値に変更できます。これを行うと、他のオプションのそれぞれの値は、デフォルトでその変数に設定した値になります。同様に、@code{magit-log-margin}のINITを@code{nil}に設定すると、それが他のすべてのオプションのデフォルトで使用されます。ただし、@code{t}に設定する、つまりそのオプションのデフォルトを再適用しても、他のオプションには適用されません。

@defopt magit-log-margin-show-committer-date
このオプションは、欄外(margin)にコミッターの日付を表示するかどうかを指定します。
このオプションは、作成者の日付の代わりにコミッターの日付を表示するかどうかのみを制御します。欄外に日付を表示するかどうか、および欄外を表示するかどうかは、他のオプションによって制御されます。
@end defopt

@table @asis
@item @kbd{L} (@code{magit-margin-settings})
@kindex L
@findex magit-margin-settings
このトランジェントプレフィックスコマンドは、それに従うサフィックスコマンドを結び付けます。各コマンドは、何らかの方法で欄外(margin)の外観を変更します。
@end table

欄外(margin)をサポートする一部のバッファでは、@code{L}は代わりに@code{magit-log-refresh}に結び付けられますが、そのトランジェントコマンドには同じコマンドと、他のいくつかの無関係なコマンドがあります。

@table @asis
@item @kbd{L L} (@code{magit-toggle-margin})
@kindex L L
@findex magit-toggle-margin
このコマンドは、欄外(margin)を表示または非表示にします。

@item @kbd{L l} (@code{magit-cycle-margin-style})
@kindex L l
@findex magit-cycle-margin-style
このコマンドは、欄外(margin)に使用されるスタイルを循環させます。

@item @kbd{L d} (@code{magit-toggle-margin-details})
@kindex L d
@findex magit-toggle-margin-details
このコマンドは、欄外(margin)の詳細を表示または非表示にします。
@end table

@node Select from Log
@subsection Select from Log

ユーザーが@code{HEAD}から到達可能な最近のコミットを選択する必要がある場合、通常の補完を使用するのは不便です(ほとんどの人間は、少なくともダブルチェックなしではハッシュとかまたは"HEAD~5"とかを覚えていないため)。代わりに、ログバッファを使用してコミットを選択します。これには、コミットが順番にコミットメッセージとともに表示されるという利点があります。

このような選択用ログは、リベースの開始を選択するとき、およびsquashコミットを選択するときに使用されます。

すべてのログバッファで使用可能なキーバインディングに加えて、以下の追加のキーバインディングが選択用ログバッファで使用できます:

@table @asis
@item @kbd{C-c C-c} (@code{magit-log-select-pick})
@kindex C-c C-c
@findex magit-log-select-pick
ポイントでコミットを選択し、それに基づいて行動します。
選択したコミットを引数として@code{magit-log-select-pick-function}を呼び出します。

@item @kbd{C-c C-k} (@code{magit-log-select-quit})
@kindex C-c C-k
@findex magit-log-select-quit
コミットの選択を中止(abort)し、どのコミットに基づいて行動することもしません。
@end table

@defopt magit-log-select-margin
このオプションは、欄外(margin)が最初にMagit-Log-Selectモードのバッファに表示されるかどうか、およびそのフォーマット方法を指定します。

値の形式は@code{(INIT STYLE WIDTH AUTHOR AUTHOR-WIDTH)}です。

@itemize
@item
INITがnil以外の場合、欄外(margin)が最初に表示されます。
@item
STYLEは、作成者(author)またはコミッター(committer)の日付をフォーマットする方法を制御します。@code{age}(コミットの経過時間を示す)または@code{age-abbreviated}(時間単位を文字に短縮する)または実際の日付を表す文字列(@code{format-time-string}に適しています)のいずれかになります。オプション@code
{magit-log-margin-show-committer-date}は、表示される日付を制御します。
@item
WIDTHは、欄外(margin)の幅を制御します。これは上位互換性のために存在し、現在値を変更すべきではありません。
@item
AUTHORは、作成者の名前もデフォルトで表示されるかどうかを制御します。
@item
AUTHOR-WIDTHは整数である必要があります。作成者の名前が表示されている場合、これはそのために使用されるスペース(空き)の量を指定します。
@end itemize
@end defopt

@node Reflog
@subsection Reflog

こちらもご覧下さい 
@ifinfo
@ref{git-reflog,,,gitman,}
@end ifinfo
@ifhtml
@c html
@c end html
the <a href="http://git-scm.com/docs/git-reflog">git-reflog(1)</a> manpage.
@end ifhtml
@iftex
the git-reflog(1) manpage.
@end iftex

これらのreflogコマンドは、ログ用トランジェントコマンドから使用できます。こちらを参照して下さい(@ref{Logging})。

@table @asis
@item @kbd{l r} (@code{magit-reflog-current})
@kindex l r
@findex magit-reflog-current
現在のブランチのreflogを表示します。

@item @kbd{l O} (@code{magit-reflog-other})
@kindex l O
@findex magit-reflog-other
ブランチまたは別のrefのreflogを表示します。

@item @kbd{l H} (@code{magit-reflog-head})
@kindex l H
@findex magit-reflog-head
@code{HEAD}のreflogを表示します。
@end table

@defopt magit-reflog-margin
このオプションは、欄外(margin)が最初にMagit-Reflogモードのバッファに表示されるかどうか、およびそのフォーマット方法を指定します。

値の形式は@code{(INIT STYLE WIDTH AUTHOR AUTHOR-WIDTH)}です。

@itemize
@item
INITがnil以外の場合、欄外(margin)が最初に表示されます。
@item
STYLEは、作成者(author)またはコミッター(committer)の日付をフォーマットする方法を制御します。@code{age}(コミットの経過時間を示す)または@code{age-abbreviated}(時間単位を文字に短縮する)または実際の日付を表す文字列(@code{format-time-string}に適しています)のいずれかになります。オプション@code
{magit-log-margin-show-committer-date}は、表示される日付を制御します。
@item
WIDTHは、欄外(margin)の幅を制御します。これは上位互換性のために存在し、現在値を変更すべきではありません。
@item
AUTHORは、作成者の名前もデフォルトで表示されるかどうかを制御します。
@item
AUTHOR-WIDTHは整数である必要があります。作成者の名前が表示されている場合、これはそのために使用されるスペース(空き)の量を指定します。
@end itemize
@end defopt

@node Cherries
@subsection Cherries

チェリー(cherry)は(まだ)アップストリームに適用されていないコミットであり、通常はログを使用して視覚化されます。各コミットには、アップストリームに同等のものがある場合は@code{-}が接頭辞として付けられ、そうでない場合、つまりチェリー(cherry)の場合は@code{+}が接頭辞として付けられます。

コマンド@code{magit-cherry}は、単一のブランチのチェリー(cherry)を表示しますが、参照バッファ(@ref{References
Buffer})は、一度に複数の「アップストリーム」のチェリー達を表示できます。

こちらもご覧下さい 
@ifinfo
@ref{git-reflog,,,gitman,}
@end ifinfo
@ifhtml
@c html
@c end html
the <a href="http://git-scm.com/docs/git-reflog">git-reflog(1)</a> manpage.
@end ifhtml
@iftex
the git-reflog(1) manpage.
@end iftex

@table @asis
@item @kbd{Y} (@code{magit-cherry})
@kindex Y
@findex magit-cherry
特定のブランチにあるが、アップストリームブランチにマージされていないコミットを表示します。
@end table

@defopt magit-cherry-margin
このオプションは、欄外(margin)が最初にMagit-Cherryモードのバッファに表示されるかどうか、およびそのフォーマット方法を指定します。

値の形式は@code{(INIT STYLE WIDTH AUTHOR AUTHOR-WIDTH)}です。

@itemize
@item
INITがnil以外の場合、欄外(margin)が最初に表示されます。
@item
STYLEは、作成者(author)またはコミッター(committer)の日付をフォーマットする方法を制御します。@code{age}(コミットの経過時間を示す)または@code{age-abbreviated}(時間単位を文字に短縮する)または実際の日付を表す文字列(@code{format-time-string}に適しています)のいずれかになります。オプション@code
{magit-log-margin-show-committer-date}は、表示される日付を制御します。
@item
WIDTHは、欄外(margin)の幅を制御します。これは上位互換性のために存在し、現在値を変更すべきではありません。
@item
AUTHORは、作成者の名前もデフォルトで表示されるかどうかを制御します。
@item
AUTHOR-WIDTHは整数である必要があります。作成者の名前が表示されている場合、これはそのために使用されるスペース(空き)の量を指定します。
@end itemize
@end defopt

@node Diffing
@section Diffing

ステータスバッファには、ステージされたコミットとステージされていないコミットのdiffが含まれていますが、それだけでは明らかに不十分です。@code{d}のトランジェントプレフィックスコマンド@code{magit-diff}は、個別のdiffバッファに特定のdiffを表示するいくつかのサフィックスコマンドがあります。

他のトランジェントプレフィックスコマンドと同様に、@code{magit-diff}も、サフィックスコマンドの1つを呼び出す前に変更できるいくつかのインフィックス引数達があります。ただし、diff用トランジェントコマンドの場合、これらの引数は、@code{magit-prefix-use-buffer-arguments}の値に応じて、現在のリポジトリのdiffバッファで現在使用されている引数から取得される場合があります(@ref{Transient
Arguments and Buffer Variables})。

こちらもご覧下さい 
@ifinfo
(@ref{git-diff,,,gitman,})
@end ifinfo
@ifhtml
@c html
@c end html
the <a href="http://git-scm.com/docs/git-diff">git-diff(1)</a> manpage.
@end ifhtml
@iftex
the git-diff(1) manpage.
@end iftex

@table @asis
@item @kbd{d} (@code{magit-diff})
@kindex d
@findex magit-diff
このトランジェント(一時的)なプレフィックス(接頭辞)コマンドは、それに従うサフィックス(接尾辞)コマンドを適切なインフィックス(中置)引数とともに結び付け、いずれかのサフィックスコマンドを選択するまでの間、そのインフィックス引数達とサフィックスコマンド達を一時バッファ(temporary
buffer)に表示します。

@item @kbd{d d} (@code{magit-diff-dwim})
@kindex d d
@findex magit-diff-dwim
そのポイントでの変更を表示します。

@item @kbd{d r} (@code{magit-diff-range})
@kindex d r
@findex magit-diff-range
2つのコミット間の違いを表示します。

RANGEは範囲(A..B or
A@dots{}B)である必要がありますが、単一のコミットにすることもできます。範囲の片側を省略すると、デフォルトで@code{HEAD}になります。コミットのみが指定された場合、そのコミットに関連する作業ツリーの変更が表示されます。

リージョンがアクティブな場合は、リージョンの最初と最後の行のリビジョンを使用します。プレフィックス引数を使用して、リビジョンを比較する代わりに、両方のリビジョンの共通の祖先から開始して、変更を表示するリビジョンを選択します(つまり、"@dots{}"の範囲を使用します)。

@item @kbd{d w} (@code{magit-diff-working-tree})
@kindex d w
@findex magit-diff-working-tree
現在の作業ツリーと@code{HEAD}コミットの間の変更を表示します。プレフィックス引数を使用して、作業ツリーとミニバッファから読み取られたコミット間の変更を表示します。

@item @kbd{d s} (@code{magit-diff-staged})
@kindex d s
@findex magit-diff-staged
インデックスと@code{HEAD}コミットの間の変更を表示します。プレフィックス引数を使用して、インデックスとミニバッファから読み取られたコミット間の変更を表示します。

@item @kbd{d u} (@code{magit-diff-unstaged})
@kindex d u
@findex magit-diff-unstaged
作業ツリーとインデックスの間の変更を表示します。

@item @kbd{d p} (@code{magit-diff-paths})
@kindex d p
@findex magit-diff-paths
ディスク上の任意の2つのファイル間の変更を表示します。
@end table

上記のすべてのサフィックスコマンドは、リポジトリのdiffバッファを更新します。diff用トランジェントコマンドには、別のバッファとの違いを表す2つのコマンドもあります。

@table @asis
@item @kbd{d c} (@code{magit-show-commit})
@kindex d c
@findex magit-show-commit
ポイントでコミットを表示します。ポイントにコミットがない場合、またはプレフィックス引数がある場合は、コミットのプロンプトを表示します。

@item @kbd{d t} (@code{magit-stash-show})
@kindex d t
@findex magit-stash-show
バッファ内のスタッシュのすべてのdiffを表示します。
@end table

現在のバッファで訪問しているファイルまたはblobのdiffを表示する2つの追加コマンドが存在します。こちらを参照して下さい(@ref{Commands
for Buffers Visiting Files})。

@menu
* Refreshing Diffs::         Refreshing Diffs
* Commands Available in Diffs::  Commands Available in Diffs
* Diff Options::             Diff Options
* Revision Buffer::          Revision Buffer
@end menu

@node Refreshing Diffs
@subsection Refreshing Diffs

@code{D}のトランジェントプレフィックスコマンド@code{magit-diff-refresh}を使用すると、表示されるdiffを変更せずに、現在のバッファで使用されているdiff引数を変更できます。これは専用のdiffバッファで機能しますが、ステータスバッファでも機能します。

@table @asis
@item @kbd{D} (@code{magit-diff-refresh})
@kindex D
@findex magit-diff-refresh
このトランジェント(一時的)なプレフィックス(接頭辞)コマンドは、それに従うサフィックス(接尾辞)コマンドを適切なインフィックス(中置)引数とともに結び付け、いずれかのサフィックスコマンドを選択するまでの間、そのインフィックス引数達とサフィックスコマンド達を一時バッファ(temporary
buffer)に表示します。

@item @kbd{D g} (@code{magit-diff-refresh})
@kindex D g
@findex magit-diff-refresh
このサフィックスコマンドは、現在のバッファのローカルdiff引数を設定します。

@item @kbd{D s} (@code{magit-diff-set-default-arguments})
@kindex D s
@findex magit-diff-set-default-arguments
このサフィックスコマンドは、現在のバッファと同じタイプのバッファのデフォルトのdiff引数を設定します。同じタイプの他の既存のバッファは、ローカル値がすでに初期化されているため、影響を受けません。

@item @kbd{D w} (@code{magit-diff-save-default-arguments})
@kindex D w
@findex magit-diff-save-default-arguments
このサフィックスコマンドは、現在のバッファと同じタイプのバッファのデフォルトのdiff引数を設定し、将来のセッションのために値を保存します。同じタイプの他の既存のバッファは、ローカル値がすでに初期化されているため、影響を受けません。

@item @kbd{D t} (@code{magit-diff-toggle-refine-hunk})
@kindex D t
@findex magit-diff-toggle-refine-hunk
このコマンドは、ハンクの絞り込みのオンとオフを切り替えます。

@item @kbd{D r} (@code{magit-diff-switch-range-type})
@kindex D r
@findex magit-diff-switch-range-type
このコマンドは、diff範囲タイプを"revA..revB"から"revB@dots{}revA"に、またはその逆に変換します。

@item @kbd{D f} (@code{magit-diff-flip-revs})
@kindex D f
@findex magit-diff-flip-revs
このコマンドは、diff範囲のリビジョンを"revA..revB"から"revB..revA"に、またはその逆に交換します。

@item @kbd{D F} (@code{magit-diff-toggle-file-filter})
@kindex D F
@findex magit-diff-toggle-file-filter
このコマンドは、現在のバッファ内のdiffのファイル制限を切り替え、コミット内のすべての変更の表示と制限されたサブセットの表示をすばやく切り替えることができるようにします。特別な場合として、このコマンドがログバッファから呼び出されると、リポジトリのリビジョンバッファ内のファイル制限が切り替わります。これは、1つまたは複数のファイルに制限されているログバッファからリビジョンを表示する場合に役立ちます。
@end table

サポートされている引数のいずれかを変更できる上記のトランジェントコマンドに加えて、特定の引数のみを変更するコマンドもいくつか存在します。

@table @asis
@item @kbd{-} (@code{magit-diff-less-context})
@kindex -
@findex magit-diff-less-context
このコマンドは、diffハンクのコンテキスト(the context)をCOUNT行ずつ減らします。

@item @kbd{+} (@code{magit-diff-more-context})
@kindex +
@findex magit-diff-more-context
このコマンドは、diffハンクのコンテキスト(the context)をCOUNT行増やします。

@item @kbd{0} (@code{magit-diff-default-context})
@kindex 0
@findex magit-diff-default-context
このコマンドは、diffハンクのコンテキスト(the context)をデフォルトの行数にリセットします。
@end table

以下のコマンドは、diff用トランジェントコマンドのいずれも使用せずに、表示されているdiffをすばやく変更します。

@table @asis
@item @kbd{C-c C-d} (@code{magit-diff-while-committing})
@kindex C-c C-d
@findex magit-diff-while-committing
コミット中、このコマンドはコミットされようとしている変更を表示します。修正中にコマンドを再度呼び出すと、新しい変更のみを表示するか、コミットされるすべての変更を表示するかが切り替わります。

このキーバインドは、diffバッファとcommitメッセージバッファで使用できます。

@item @kbd{C-c C-b} (@code{magit-go-backward})
@kindex C-c C-b
@findex magit-go-backward
このコマンドは、現在のバッファの履歴を逆方向に移動します。

@item @kbd{C-c C-f} (@code{magit-go-forward})
@kindex C-c C-f
@findex magit-go-forward
このコマンドは、現在のバッファーの履歴を順方向に進めます。
@end table

@node Commands Available in Diffs
@subsection Commands Available in Diffs

一部のコマンドは、ポイントがdiff内にある場合にのみ使用できます。

@code{magit-diff-visit-file}および関連するコマンドは、その時点でのdiffが含まれているファイルの適切なバージョンを訪問します。
同様に、@code{magit-diff-visit-worktree-file}および関連するコマンドは、その時点でのdiffが含まれているファイルのワークツリーバージョンを訪問します。詳細とキーバインディングについてはこちらを参照して下さい(@ref{Visiting
Files and Blobs from a Diff})。

@table @asis
@item @kbd{C-c C-t} (@code{magit-diff-trace-definition})
@kindex C-c C-t
@findex magit-diff-trace-definition
このコマンドは、ポイントでの定義(the definition)のログを表示します。
@end table

@defopt magit-log-trace-definition-function
このオプションで指定された関数は、@code{magit-log-trace-definition}によって使用され、ポイントでの機能を決定します。特別なニーズがあるメジャーモードの場合、モードのフックを使用してローカル値を設定できます。
@end defopt

@table @asis
@item @kbd{C-c C-e} (@code{magit-diff-edit-hunk-commit})
@kindex C-c C-e
@findex magit-diff-edit-hunk-commit
このコマンドは、ハンクからそれぞれのコミットを編集し、ファイルを訪問します。

まず、@code{magit-diff-visit-file}を使用して、ハンクによって正しい場所で変更されているファイルを訪問します。これは実際にblobを訪問します。ポイントが個々のハンク内ではなくdiffヘッダー上にある場合、これは最初のハンクが存在するblobを訪問します。

次に@code{magit-edit-line-commit}を呼び出し、@code{HEAD}からそのコミットを直接チェックチェックアウトすることで到達することは不可能な、インタラクティブなリベースを使用してコミットを編集可能にし、これにより実際の作業ツリーのファイルも訪問できます。

リベースの終了時に、blobもファイルバッファも強制終了(kill)されません。それが望ましくない場合は、このコマンドの代わりに@code{magit-rebase-edit-command}を使用する方がよい場合があります。

@item @kbd{j} (@code{magit-jump-to-diffstat-or-diff})
@kindex j
@findex magit-jump-to-diffstat-or-diff
このコマンドは、diffstatまたはdiffにジャンプします。ポイントがdiffstatセクション内のファイル上にある場合は、それぞれのdiffセクションにジャンプします。
それ以外の場合は、diffstatセクションまたはその子にジャンプします。
@end table

以下の2つのコマンドは、Magit-Diffモード(または、さらに言えばMagitバッファ)に固有のものではありませんが、ここでも使用できることを指摘しておく価値があります。

@table @asis
@item @kbd{@key{SPC}} (@code{scroll-up})
@kindex SPC
@findex scroll-up
このコマンドは、テキストを上にスクロールします。

@item @kbd{@key{DEL}} (@code{scroll-down})
@kindex DEL
@findex scroll-down
このコマンドは、テキストを下にスクロールします。
@end table

@node Diff Options
@subsection Diff Options

@defopt magit-diff-refine-hunk
diffハンク内で単語の粒度(word-granularity)のdiffを表示するかどうか。

@itemize
@item
@code{nil} 細かい違いを表示しないでください。
@item
@code{t} 現在のdiffハンクのみの細かい違いを表示します。
@item
@code{all} 表示されているすべてのdiffハンクの細かい違いを表示します。
@end itemize
@end defopt

@defopt magit-diff-refine-ignore-whitespace
単語の粒度(word-granularity)の違いにおける空白の変更を無視するかどうか。
@end defopt

@defopt magit-diff-adjust-tab-width
diffでタブの幅を調整するかどうか。

大きなファイルや多数のファイルを開く必要がある場合、正しい幅を決定するのはコストがかかる可能性があるため、幅は変数@code{magit-diff--tab-width-cache}にキャッシュされます。キャッシュを無効にするには、これをnilに設定します。

@itemize
@item
@code{nil} タブ幅は調整しません。代わりに、Magitバッファ自体の`tab-width'の値を使います。

@item
@code{t}
対応するfile-visitingバッファが存在する場合は、そのバッファの@code{tab-width}の値を使用します。これを行うのは安価であるため、対応するキャッシュエントリが存在する場合でも、この値が使用されます。

@item
@code{always} そのようなバッファがない場合は、一時的(temporarily)にファイルを訪問して値を決定します。

@item
NUMBER @code{always}と同様ですが、NUMBERバイトより大きいファイルを訪問しないでください。
@end itemize
@end defopt

@defopt magit-diff-paint-whitespace
空白エラー達を強調表示(highlight)する場所を指定します。

@code{magit-diff-highlight-trailing}、@code{magit-diff-highlight-indentation}を参照してください。
シンボル@code{t}はすべてのdiffを意味し、@code{status}はステータスバッファ内のみを意味し、nilはどこにも存在しないことを意味します。

@itemize
@item
@code{nil} 空白エラーを強調表示(highlight)しません。
@item
@code{t} どこでも空白エラーを強調表示(highlight)します。
@item
@code{uncommitted}
コミットされていない変更を示すdiff達の空白エラーのみを強調表示(highlight)します。下位互換性のために、@code{status}は同義語として扱われます。
@end itemize
@end defopt

@defopt magit-diff-paint-whitespace-lines
空白エラーを強調表示(highlight)する行の種類(kind of lines)を指定します。

@itemize
@item
@code{t} 追加された行でのみ強調表示(highlight)します。
@item
@code{both} 追加および削除された行を強調表示(highlight)します。
@item
@code {all} 追加、削除、およびコンテキスト行で強調表示(highlight)します。
@end itemize
@end defopt

@defopt magit-diff-highlight-trailing
diff達の行末の空白を強調表示するかどうか。@code{magit-diff-paint-whitespace}がnil以外の場合にのみ使用されます。
@end defopt

@defopt magit-diff-highlight-indentation
このオプションは、「間違った」インデントスタイルを使用した場合にインデントを強調表示(highlight)するかどうかを制御します。インデントは、@code{magit-diff-paint-whitespace}もnil以外の場合にのみ強調表示されます。

値は、@code{((REGEXP
.
INDENT)...)}の形式のalistです。現在のリポジトリへのパスは、逆の順序で各要素と照合されます。したがって、REGEXPが一致する場合、以前の要素は試行されません。

使用するインデントが@code{tabs}の場合は、タブでインデントを強調表示(highlight)します。INDENTが整数の場合は、少なくともその数のスペースでインデントを強調表示します。それ以外の場合は、どちらも強調表示しません。
@end defopt

@defopt magit-diff-hide-trailing-cr-characters
diff達の行末の ^M 文字を非表示にするかどうか。
@end defopt

@defopt magit-diff-highlight-hunk-region-functions
このオプションは、ハンク内部regionを強調表示(highlight)するために使用される関数を指定します。

@code{magit-diff-highlight-hunk-region-dim-outside}は、ハンクの内部選択範囲(hunk
internal
selection)の外側に、追加および削除された行の背景色をコンテキスト行と同じにするfaceをオーバーレイします。この関数は、このオプションの値から削除すべきではありません。

@code{magit-diff-highlight-hunk-region-using-overlays}と@code{magit-diff-highlight-hunk-region-using-underline}は、前後に区切りの水平線を配置することで、regionを強調します。これらの機能には両方とも、Emacsのディスプレイエンジンの制限のために修正できない欠陥(glitches)があります。詳細についてはこちらを参照して下さい
@uref{https://github.com/magit/magit/issues/2758} ff

Instead of, or in addition to, using delimiting horizontal lines, to
emphasize the boundaries, you may wish to emphasize the text itself, using
@code{magit-diff-highlight-hunk-region-using-face}.

ターミナルフレームでは、オーバーレイとアンダーラインのバリエーションが通常行うように線を描画することはできないため、代わりにface関数の呼び出しにフォールバックします。
@end defopt

@defopt magit-diff-unmarked-lines-keep-foreground
このオプションは、ハンク内部(hunk-internal)regionの外側に追加および削除された線が、明確な背景色のみを失うか、前景色も失うかを制御します。
領域の外側が暗くなるかどうかは、@code{magit-diff-highlight-hunk-region-functions}によって異なります。
@end defopt

@defopt magit-diff-extra-stat-arguments
このオプションは、@code{--stat}と一緒に使用される追加の引数を指定します。

値は、0個以上の引数のリスト、または引数をとらずにそのようなリストを返す関数です。一緒に使ってよい引数は@code{--stat-width}と@code{--stat-name-width}と@code{--stat-graph-width}と@code{--compact-summary}です。こちらもご覧ください 
@ifinfo
(@ref{git-diff,,,gitman,})
@end ifinfo
@ifhtml
@c html
@c end html
the <a href="http://git-scm.com/docs/git-diff">git-diff(1)</a> manpage.
@end ifhtml
@iftex
the git-diff(1) manpage.
@end iftex
@end defopt

@node Revision Buffer
@subsection Revision Buffer

@defopt magit-revision-insert-related-refs
関連するブランチをリビジョンバッファに表示するかどうか。

@itemize
@item
@code{nil} 関連するブランチを表示しません。
@item
@code{t} 関連するローカルブランチを表示します。
@item
@code{all} 関連するローカルブランチとリモートブランチを表示します。
@item
@code{mixed} 含まれているすべてのブランチとローカルのマージされたブランチを表示します。
@end itemize
@end defopt

@defopt magit-revision-show-gravatars
リビジョンバッファにGravatar画像を表示するかどうか。

@code{nil}の場合はGravatar画像を挿入しません。@code{t}の場合は両方の画像を挿入します。@code{author}または@code{committer}の場合は、それぞれの画像のみを挿入します。

あなたがオプション@code{magit-revision-headers-format}をカスタマイズしていて、画像を挿入したい場合は、どこに挿入するかも指定する必要があります。その場合、値は2つの正規表現のコンスセルである必要があります。carは、作者の画像を挿入する場所を指定します。画像の上半分は一致したテキストの直後に挿入され、下半分は同じ列の次の行に挿入されます。cdrは、それに応じてコミッターのイメージを挿入する場所を指定します。carかcdrのどちらかがnilかもしれません。
@end defopt

@defopt magit-revision-use-hash-sections
コミットメッセージ内のハッシュをセクションに変換するかどうか。

nil以外の場合、コミットメッセージ内のハッシュは@code{commit}セクションに変換されます。パフォーマンスと信頼性の間にはトレードオフがあります。

@itemize
@item
@code{slow} 確実にすべての単語に対してgitを呼び出します。
@item
@code{quick} 7文字未満の単語をスキップします。
@item
@code{quicker} さらに、数字を含まない単語をスキップします。
@item
@code{quickest} 7文字以上の長さでかつ、1つ以上の数字かつ、1つ以上文字を含むすべての単語を使用します。
@end itemize

nilの場合、ハッシュはセクションに変換されませんが、そのポイントで「RET」を使用してコミットを訪問できます。
@end defopt

リビジョンバッファに表示されるdiff達は、変更されたファイルのサブセットに自動的に制限される場合があります。リビジョンバッファがログバッファから表示される場合、リビジョンバッファは、そのログバッファと同じファイル制限を共有します(コマンド@code{magit-diff-toggle-file-filter}も参照してください)。

@defopt magit-revision-filter-files-on-follow
ログ引数に@code{--follow}が含まれている場合に、ログバッファからのコミットを表示するかどうかは、ログのファイルフィルターを尊重します。

このオプションがnilの場合、ログ引数に@code{--follow}が含まれていると、ログからのコミットの表示はログのファイルフィルターを無視します。そうすることで、名前変更イベントの前にコミット用のリビジョンバッファに空のdiffが表示されないようにします。このような場合、ログ用トランジェントコマンドの@code{--patch}引数を使用して、ファイル制限されたdiff達をインラインで表示できます。

@code{--follow}がログ引数に存在する場合でもログのファイル制限を維持するには、このオプションを非nilに設定します。
@end defopt

リビジョンバッファがログバッファから表示されない場合、ファイル制限は通常どおりに決定されます(@ref{Transient Arguments and
Buffer Variables})。

@node Ediffing
@section Ediffing

このセクションでは、MagitバッファからEdiffを入力する方法について説明します。
Ediff自体の使用方法についてはこちらを参照して下さい(@ref{Top,,,ediff,})。

@table @asis
@item @kbd{e} (@code{magit-ediff-dwim})
@kindex e
@findex magit-ediff-dwim
Ediffを使用して比較(compare)またはステージ(stage)または解決(resolve)します。

このコマンドは、Ediffを使用して、ユーザーが比較(compare)またはステージ(stage)または解決(resolve)したいファイルと、コミットまたは範囲(range)を推測しようとします。ファイルまたは範囲(range)/コミットのいずれかを推測することしかできない場合があります。その場合、ユーザーはもう一方について尋ねられます。常に正しく推測できるとは限りません。その場合、適切な@code{magit-ediff-*}コマンドを明示的に使用する必要があります。Magitがユーザーの心をまったく読み取れない場合は、実行するコマンドをユーザーに要求します。

@item @kbd{E} (@code{magit-ediff})
@kindex E
@findex magit-ediff
このトランジェント(一時的)プレフィックス(接頭辞)コマンドは、それに従うサフィックス(接尾辞)コマンド群を結びつけ、そのサフィックスコマンドのどれかを選ぶまでの間、サフィックス(接尾辞)コマンド群を一時バッファ(temporary
buffer)に表示します。

@item @kbd{E r} (@code{magit-ediff-compare})
@kindex E r
@findex magit-ediff-compare
Ediffを使用してファイルの2つのリビジョンを比較します。

リージョンがアクティブな場合は、リージョンの最初と最後の行のリビジョンを使用します。プレフィックス引数を使用して、リビジョンを比較する代わりに、両方のリビジョンの共通の祖先から開始して、変更を表示するリビジョンを選択します(つまり、"@dots{}"の範囲を使用します)。

@item @kbd{E m} (@code{magit-ediff-resolve-rest})
@kindex E m
@findex magit-ediff-resolve-rest
このコマンドを使用すると、Ediff を使用して、ポイントしているファイルのファイル内の未解決の競合を解決できます。
ポイントしているファイルがない場合、またはマージされていない変更がない場合、このコマンドはファイルの入力を促します。

@code
{merge.conflictstyle}の値が@code{diff3}の場合、Ediff制御バッファで@code{/}を使用してファイルのマージベースリビジョン(merge-base
revision)を表示できます。

AとBと Ancestor(先祖) バッファーは、ワークツリーファイル内の競合マーカーから構築されます。 あなたや Git
が既にいくつかの競合を解決している可能性があるため、これらのバッファーにはそれぞれのブロブの実際のバージョンが含まれていない可能性があります。

@item @kbd{E m} (@code{magit-ediff-resolve-all})
@kindex E m
@findex magit-ediff-resolve-all
このコマンドを使用すると、あなたは Ediff を使用してその時点でファイル内のすべての競合を解決できます。
ポイントしているファイルがない場合、またはマージされていない変更がない場合、このコマンドはファイルの入力を促します。

@code
{merge.conflictstyle}の値が@code{diff3}の場合、Ediff制御バッファで@code{/}を使用してファイルのマージベースリビジョン(merge-base
revision)を表示できます。

まず、ワークツリー内のファイルが脇に移動され、サフィックス @samp{.ORIG} が追加されるため、後でそのバージョンに戻ることができます。
次に、競合の 2 つの側面とマージ ベース (利用可能な場合) から再構築されます。

ワークツリーのファイルをそのまま使用できればよいのですが、Ediff はそれをサポートしていません。 これは、Git
が既に解決したすべての競合が復元(restore)されることを意味します。 一方、Ediff も競合を解決しようとします。多くの場合、Ediff と
Git は同様の結果を生成するはずです。

ただし、一部の競合を手動で解決済みの場合、それらの変更は破棄されます (ただし、バックアップ ファイルから復元(recover)することはできます)。
そのような場合、 @code{magit-ediff-resolve-rest} の方が適切かもしれません。

このコマンドが @code{magit-ediff-resolve-rest} よりも優れている点は、Aと Bと
Ancestorバッファーがそれぞれのコミットのブロブに対応しているため、コンテキスト内でその側を検査し、バッファ内でそうするための Magit
コマンドを使用できることです。 Blame コマンドと log コマンドは、ここで特に役立ちます。

@item @kbd{E t} (@code{magit-git-mergetool})
@kindex E t
@findex magit-git-mergetool
このコマンドは、実際には Ediff を使用しません。 @samp{magit-ediff-resolve-rest}
と同じ目的を果たしますが、@samp{git mergetool --gui} を使用して競合を解決します。

前置引数を使用すると、これは一時的な前置コマンドとして機能し、ユーザーが mergetool を選択して一部の設定を変更できるようにします。

@item @kbd{E s} (@code{magit-ediff-stage})
@kindex E s
@findex magit-ediff-stage
Ediffを使用してファイルへの変更をステージ(stage)およびステージ解除(unstage)します。デフォルトではそのポイントのファイルを対象にします。

@item @kbd{E u} (@code{magit-ediff-show-unstaged})
@kindex E u
@findex magit-ediff-show-unstaged
Ediffを使用して、ファイルへのステージされていない変更(unstaged changes)を表示します。

@item @kbd{E i} (@code{magit-ediff-show-staged})
@kindex E i
@findex magit-ediff-show-staged
Ediffを使用してファイルのステージされた変更(staged changes)を表示します。

@item @kbd{E w} (@code{magit-ediff-show-working-tree})
@kindex E w
@findex magit-ediff-show-working-tree
Ediffを使用して、@code{HEAD}と作業ツリーの間のファイルの変更を表示します。

@item @kbd{E c} (@code{magit-ediff-show-commit})
@kindex E c
@findex magit-ediff-show-commit
Ediffを使用したコミットによって導入されたファイル(file introduced)への変更を表示します。

@item @kbd{E z} (@code{magit-ediff-show-stash})
@kindex E z
@findex magit-ediff-show-stash
Ediffを使用してstashによって導入されたファイルへの変更を表示します。
@end table

@defopt magit-ediff-dwim-resolve-function
このオプションは、競合を解決するために @code{magit-ediff-dwim} が使用する関数を制御します。
@code{magit-ediff-resolve-rest} または @code{magit-ediff-resolve-all} または
@code{magit-git-mergetool} のいずれ一つです。 これらすべてはで説明されています。
@end defopt

@defopt magit-ediff-dwim-show-on-hunks
このオプションは、ポイントがコミットされていないハンク上にあるときに@code{magit-ediff-dwim}が呼び出すコマンドを制御します。nilの場合、常に@code{magit-ediff-stage}を実行します。それ以外の場合は、@code{magit-ediff-show-staged}と@code{magit-ediff-show-unstaged}を使用して、それぞれステージされた変更(staged
changes)とステージされていない変更(unstaged changes)を表示します。
@end defopt

@defopt magit-ediff-show-stash-with-index
このオプションは、@code{magit-ediff-show-stash}にスタッシュが作成されたときのインデックス内のファイルの状態を含むバッファを含めるかどうかを制御します。
これにより、スタッシュのどの変更がステージ(stage)されたかを知ることができます。
@end defopt

@defopt magit-ediff-quit-hook
このフックは、Magitコマンドを使用して作成されたEdiffセッションを終了した後に実行されます。フック関数はEdiff制御バッファ内で実行され、現在のバッファを変更すべきではありません。

これは@code{ediff-quit-hook}に似ていますが、Magitのニーズを考慮に入れています。通常の@code{ediff-quit-hook}は、Magitコマンドを使用して作成されたEdiffセッションでは無視されます。
@end defopt

@node References Buffer
@section References Buffer

@table @asis
@item @kbd{y} (@code{magit-show-refs})
@kindex y
@findex magit-show-refs
このコマンドは、専用バッファ内のブランチとタグを一覧表示します。

けれども、このコマンドがこのバッファから再度呼び出された場合、またはプレフィックス(接頭辞)引数を指定して呼び出された場合は、トランジェントプレフィックスコマンドとして機能し、それに従うサフィックスコマンドといくつかのインフィックス引数を結び付けます。
@end table

それに従うすべてのサフィックスコマンドは、まったく同じブランチとタグを一覧表示します。唯一の違いは、@code{magit-refs-show-commit-count}の値を変更することで有効にできるオプション機能です(以下を参照)。これらのコマンドは、他のすべてのreferencesが比較される別のブランチまたはコミットを指定します。

@table @asis
@item @kbd{y y} (@code{magit-show-refs-head})
@kindex y y
@findex magit-show-refs-head
このコマンドは、専用バッファ内のブランチとタグを一覧表示します。各referenceは@code{HEAD}と比較されています。

@item @kbd{y c} (@code{magit-show-refs-current})
@kindex y c
@findex magit-show-refs-current
このコマンドは、専用バッファ内のブランチとタグを一覧表示します。各referenceは、現在のブランチまたはdetachされている場合は@code{HEAD}と比較されます。

@item @kbd{y o} (@code{magit-show-refs-other})
@kindex y o
@findex magit-show-refs-other
このコマンドは、専用バッファ内のブランチとタグを一覧表示します。各referenceは、ユーザーから読み取られたブランチと比較されています。

@item @kbd{y r} (@code{magit-refs-set-show-commit-count})
@kindex y r
@findex magit-refs-set-show-commit-count
このコマンドは、コミットカウント(the commit count)が表示されるrefsを変更します。
@end table

@defopt magit-refs-show-commit-count
Magit-Refsモードのバッファでコミット数を表示するかどうか。

@itemize
@item
@code{all} ブランチとタグのカウントを表示します。
@item
@code{branch} ブランチのカウントのみを表示します。
@item
@code{nil} カウントを表示しません。
@end itemize

デフォルトは@code{nil}です。他のものは非常に重い処理になる可能性があるためです。
@end defopt

@defopt magit-refs-pad-commit-counts
Magit-Refsモードバッファのすべての脇(side)ですべてのコミットカウントをパディングするかどうか。

これがnilの場合、一部のコミットカウントは、カウントの横に表示されるブランチの1つのすぐ隣に、間にスペースを入れずに表示されます。ブランチ名のfaceが@code{magit-dimmed}に似すぎている場合、これは見栄えが悪い可能性があります。

これがnil以外の場合、スペースがすべてのコミットカウントの両側に配置されます。
@end defopt

@defopt magit-refs-show-remote-prefix
リモートブランチのリストにremote prefixを表示するかどうか。

リモートの名前はそのブランチのリストの前の見出しにすでに表示されているため、prefixの表示は冗長です。
@end defopt

@defopt magit-refs-primary-column-width
`magit-refs-mode'バッファのprimary列の幅。primary列は、現在の行が含まれているブランチの名前を含む列です。

これが整数の場合、列の幅がその整数になります。それ以外の場合は、2つの整数のコンスセルである必要があります。
1つ目は最小幅を指定し、2つ目は最大幅を指定します。その場合、実際の幅は、表示されているローカルブランチの名前の長さを使用して決定されます。(最適な幅に計算する場合、リモートブランチとタグは考慮されません。)
@end defopt

@defopt magit-refs-focus-column-width
`magit-refs-mode'バッファのfocus列の幅。

focus列は最初の列であり、@code{*}または@code{@@}を使用して、1つのブランチ(通常は現在のブランチ)をフォーカスされたブランチとしてマークします。他のreferenceごとに、このfocus列はオプションで、フォーカスされたブランチと@code{<}の前にあるコミットの数を示します。前にない場合は、後ろにあるコミットと@code{>}を示します。前にも後ろにも無い場合は@code{=}です。

この列には、フォーカスされたブランチの@code{*}または@code{@@}のみが表示される場合もあります。その場合、このオプションは無視されます。@code{L
v}を使用して、この列の詳細度を変更します。
@end defopt

@defopt magit-refs-margin
このオプションは、欄外(margin)が最初にMagit-Refsモードのバッファに表示されるかどうか、およびそのフォーマット方法を指定します。

値の形式は@code{(INIT STYLE WIDTH AUTHOR AUTHOR-WIDTH)}です。

@itemize
@item
INITがnil以外の場合、欄外(margin)が最初に表示されます。
@item
STYLEは、作成者(author)またはコミッター(committer)の日付をフォーマットする方法を制御します。@code{age}(コミットの経過時間を示す)または@code{age-abbreviated}(時間単位を文字に短縮する)または実際の日付を表す文字列(@code{format-time-string}に適しています)のいずれかになります。オプション@code
{magit-log-margin-show-committer-date}は、表示される日付を制御します。
@item
WIDTHは、欄外(margin)の幅を制御します。これは上位互換性のために存在し、現在値を変更すべきではありません。
@item
AUTHORは、作成者の名前もデフォルトで表示されるかどうかを制御します。
@item
AUTHOR-WIDTHは整数である必要があります。作成者の名前が表示されている場合、これはそのために使用されるスペース(空き)の量を指定します。
@end itemize
@end defopt

@defopt magit-refs-margin-for-tags
このオプションは、欄外(margin)にタグに関する情報を表示するかどうかを指定します。タグが多いと遅いため、デフォルトでは無効になっています。
@end defopt

以下の変数は、個々のrefsの表示方法を制御します。これらの変数の1つ(特に"%c"の部分)を変更する場合は、他の変数も変更して、調整を維持する必要があります。以下の%シーケンスがサポートされています:

@itemize
@item
@code{%a} このrefが比較したコミットを超えるコミットの数。
@item
@code{%b} 比較するrefのコミット数がこれを超えています。
@item
@code{%c}
このrefが比較したコミットを超えるコミットの数。他のすべてのrefが比較されるrefの場合、これは、現在のブランチの場合は代わりに"@@"、それ以外の場合は"#"になります。
@item
@code{%C} 他のすべてのrefが比較されるrefの場合、これは現在のブランチの場合は"@@"、それ以外の場合は"#"です。 他のすべての参照は"
"です。
@item
@code{%h} このrefのtipのハッシュ。
@item
@code{%m} このrefのtipの要約をコミットします。
@item
@code{%n} このrefの名前。
@item
@code{%u} このローカルブランチのupstream。
@item
@code{%U} このローカルブランチのアップストリームおよび追加のローカル情報とアップストリーム情報。
@end itemize

@defopt magit-refs-filter-alist
このオプションの目的は、名前に基づいて特定のrefを表示しないようにすることです。特定のタイプのrefを表示したくない場合は、代わりに@code{magit-refs-sections-hook}から適切な関数を削除する必要があります。

このalistは、@code{magit-refs-mode}バッファに表示されないようにするタグとブランチを制御します。@code{nil}の場合、すべてのrefが表示されます(@code{magit-refs-sections-hook}に従います)。

1つが一致するまで、すべてのキーが順番に試行されます。
次に、その値が使用され、後続の要素は無視されます。値がnil以外の場合はそのreferenceが表示され、そうでない場合は表示されません。
一致する要素がない場合は、そのreferenceが表示されます。

キーは、refnameが一致する必要のある正規表現、またはrefnameを引数としてのみ受け取り、ブール値を返す関数のいずれかです。"origin/master"などのリモートブランチは単に"master"として表示されますが、この比較では前者が使用されます。
@end defopt

@table @asis
@item @kbd{@key{RET}} (@code{magit-visit-ref})
@kindex RET
@findex magit-visit-ref
このコマンドは、別のバッファ内のポイントでreferenceまたはリビジョンを訪問します。ポイントにリビジョンがない場合、またはプレフィックス引数がある場合は、リビジョンの入力を求められます。

このコマンドは、ポイントが@code{magit-refs-mode}バッファ内のreference上にある場合を除いて、上記の@code{magit-show-commit}と同じように動作します。あなたがオプション@code{magit-visit-ref-behavior}をカスタマイズした場合、動作は異なる可能性があります。
@end table

@defopt magit-visit-ref-behavior
このオプションは、@code{magit-visit-ref}が@code{magit-refs-mode}バッファでどのように動作するかを制御します。

デフォルトでは、@code{magit-visit-ref}は@code{magit-refs-mode}バッファを含むすべてのバッファで、@code{magit-show-commit}のように動作します。ポイントあるセクションのタイプが@code{commit}の場合、「RET」は@code{magit-show-commit}に結び付けられ、タイプが@code{branch}または@code{tag}の場合、@code{magit-visit-ref}に結び付けられています。

「RET」はMagitの最も重要なキーの1つであり、少なくともデフォルトでは、Magit全体で一貫して動作する必要があります。特に、ユーザーには非常に無害なことをすぐに理解できるようにするためです。別のバッファ内のポイントにあるものに関する詳細情報が表示されます。

けれども、「RET」は@code{magit-refs-mode}バッファで異なる動作をし、驚くべきことを実行していました。その中には、「これこれを訪問する」(visit
this
thing)とは実際には説明できないものもあります。この動作に慣れている場合は、このオプションの値に以下のシンボルを1つ以上追加することで、この動作を復元できます。
ただし、そうすることで不整合が発生するだけでなく、一部の機能が失われ、@code{M-x
magit-show-commit}を使用して元に戻す必要がある場合があることに注意してください。

@code{magit-visit-ref}は、ここで説明されている順序でこれらのシンボルを検索します。シンボルの存在が現在の状況に当てはまる場合、後続のシンボルは結果に影響を与えません。

@itemize
@item
@code{focus-on-ref}

プレフィックス引数を使用してバッファを更新し、現在のバッファまたは@code{HEAD}ではなく、そのポイントでのreferenceに関連するコミット数とcherry
commitのリストを表示します。

このシンボルを追加する代わりに、"C-u y o RET"を押すことを検討してください。

@item
@code{create-branch}

ポイントがリモートブランチ上にある場合は、同じ名前で新しいローカルブランチを作成し、リモートブランチをアップストリームとして使用してから、ローカルブランチをチェックアウトします。

このシンボルを追加する代わりに、他のバッファで行うように、"b c RET RET"を押すことを検討してください。

@item
@code{checkout-any}

ポイントでreferenceをチェックアウトします。そのreferenceがタグまたはリモートブランチである場合、これにより@code{HEAD}がdetachされます。

このシンボルを追加する代わりに、他のバッファで行うように、"b b RET"を押すことを検討してください。

@item
@code{checkout-branch}

ポイントでローカルブランチをチェックアウトしてください。

このシンボルを追加する代わりに、他のバッファで行うように、"b b RET"を押すことを検討してください。
@end itemize
@end defopt

@menu
* References Sections::      References Sections
@end menu

@node References Sections
@subsection References Sections

参照バッファ(references
buffers)の内容は、フック@code{magit-refs-sections-hook}を使用して制御されます。このようなフックとそれらをカスタマイズする方法については、こちらを参照して下さい(@ref{Section
Hooks})。以下の関数はすべてデフォルト値のメンバーです。注意:
このフックをカスタマイズすることは、ステータスバッファに使用されるそれぞれのフックよりもはるかに意味がないことに注意してください。

@defopt magit-refs-sections-hook
フックを実行して、セクションをreferenceバッファに挿入します。
@end defopt

@defun magit-insert-local-branches
すべてのローカルブランチを表すセクションを挿入します。
@end defun

@defun magit-insert-remote-branches
すべてのリモート追跡(remote-tracking)ブランチを表すセクションを挿入します。
@end defun

@defun magit-insert-tags
すべてのタグを表示するセクションを挿入します。
@end defun

@node Bisecting
@section Bisecting

こちらもご覧下さい 
@ifinfo
@ref{git-bisect,,,gitman,}
@end ifinfo
@ifhtml
@c html
@c end html
the <a href="http://git-scm.com/docs/git-bisect">git-bisect(1)</a> manpage.
@end ifhtml
@iftex
the git-bisect(1) manpage.
@end iftex

@table @asis
@item @kbd{B} (@code{magit-bisect})
@kindex B
@findex magit-bisect
このトランジェント(一時的)プレフィックス(接頭辞)コマンドは、それに従うサフィックス(接尾辞)コマンド群を結びつけ、そのサフィックスコマンドのどれかを選ぶまでの間、サフィックス(接尾辞)コマンド群を一時バッファ(temporary
buffer)に表示します。
@end table

bisectが進行中でない場合、トランジェントコマンド(transient)にはそれに従うサフィックスコマンドがあります。

@table @asis
@item @kbd{B B} (@code{magit-bisect-start})
@kindex B B
@findex magit-bisect-start
bisectセッションを開始します。

バグを二分探索(bisect)するということは、バグを引き起こしたコミットを見つけることを意味します。このコマンドは、既知の良好なコミットと既知の不良コミットを要求することにより、このようなbisectセッションを開始します。
あなたがデグレ(regression)ではない変更について二分探索する場合は、"bad"と"good"よりも概念的に適切な代替用語を選択できますが、そうするためのインフィックス引数はデフォルトでは無効になっています。

@item @kbd{B s} (@code{magit-bisect-run})
@kindex B s
@findex magit-bisect-run
各ステップの後にコマンドを実行することにより、自動的にbisectします。
@end table

進行中のbisectの場合、トランジェントコマンドには代わりのサフィックスコマンドがあります。

@table @asis
@item @kbd{B b} (@code{magit-bisect-bad})
@kindex B b
@findex magit-bisect-bad
現在のコミットをbadとしてマークします。コミットに問題のバグが含まれていることを表明します。

@item @kbd{B g} (@code{magit-bisect-good})
@kindex B g
@findex magit-bisect-good
現在のコミットをgoodとしてマークします。 コミットに問題のバグが含まれていないことを表明します。

@item @kbd{B m} (@code{magit-bisect-mark})
@kindex B m
@findex magit-bisect-mark
現在のコミットをbisectの用語の1つでマークします。このコマンドは、@code{magit-bisect-bad}および@code{magit-bisect-good}の代替を提供し、「bad」および「good」以外の用語を使用する場合に役立ちます。このサフィックスコマンドはデフォルトでは無効になっています。

@item @kbd{B k} (@code{magit-bisect-skip})
@kindex B k
@findex magit-bisect-skip
現在のコミットをスキップします。何らかの理由で現在のコミットがテストに適していない場合に役立ちます。このコマンドにより、Gitは別のコミットを選択できます。

@item @kbd{B r} (@code{magit-bisect-reset})
@kindex B r
@findex magit-bisect-reset
bisect後、bisect状態をクリーンアップし、元の@code{HEAD}に戻します。
@end table

デフォルトでは、ステータスバッファには、進行中のbisectセッションに関する情報が表示されます。

@defopt magit-bisect-show-graph
このオプションは、まだbisectする必要があるコミットのログのグラフを表示するかどうかを制御します。
@end defopt

@node Visiting Files and Blobs
@section Visiting Files and Blobs

Magitは、ファイルまたはblob(特定のコミットに保存されているファイルのバージョン)を訪問するいくつかのコマンドを提供します。
実際には、そのようなコマンドのいくつかの「グループ」と、各グループ内のいくつかの「バリエーション」を提供します。

@menu
* General-Purpose Visit Commands::  General-Purpose Visit Commands
* Visiting Files and Blobs from a Diff::  Visiting Files and Blobs from a 
                                            Diff
@end menu

@node General-Purpose Visit Commands
@subsection General-Purpose Visit Commands

これらのコマンドは、任意のblobを開くためにどこでも使用できます。現在、デフォルトではこれらのコマンドに結び付けられているキーはありませんが、変更される可能性はあります。

@deffn Command magit-find-file
このコマンドは、ユーザーからファイル名とリビジョンを読み取り、バッファ内でそれぞれのBLOBを訪問します。選択したウィンドウにバッファが表示されます。
@end deffn

@deffn Command magit-find-file-other-window
このコマンドは、ユーザーからファイル名とリビジョンを読み取り、バッファ内でそれぞれのBLOBを訪問します。バッファは別のウィンドウに表示されます。
@end deffn

@deffn Command magit-find-file-other-frame
このコマンドは、ユーザーからファイル名とリビジョンを読み取り、バッファ内でそれぞれのBLOBを訪問します。バッファは別のフレームに表示されます。
@end deffn

@node Visiting Files and Blobs from a Diff
@subsection Visiting Files and Blobs from a Diff

以下のコマンドは、ポイントがdiff内にある場合にのみ使用できます。

@table @asis
@item @kbd{@key{RET}} (@code{magit-diff-visit-file})
@kindex RET
@findex magit-diff-visit-file
このコマンドは、diff内のポイントのところのファイルの適切なバージョンを訪問します。

このコマンドは、適切なファイルの作業ツリーバージョンを訪問します。diff内のポイントの位置によって、訪問するファイルが決まります。訪問したバージョンは、diffがどのような変更であるかによって異なります。

@enumerate
@item
diffにコミットされていない変更(つまり、ステージされた変更(staged changes)またはステージされていない変更(unstaged
changes))が表示される場合は、作業ツリー内のファイル(つまり、@code{find-file}が訪問するのと同じ「実際の」ファイル)を訪問します。それ以外の場合は、blob(つまり、コミットに保存されているファイルのバージョン)を訪問します。

@item
ポイントが、削除された行にある場合は、その行を削除したコミットの最初の親、つまりその行がまだ存在する最後のコミットのblobを訪問します。

@item
ポイントが、追加された行またはコンテキスト行にある場合は、その行を追加するblobを訪問します。または、diffが複数のコミットから表示される場合は、これらの最後のコミットからblobを訪問します。
@end enumerate

file-visitingバッファでは、このコマンドは、diffでポイントがある行に対応する行に移動します。

選択したウィンドウにバッファが表示されます。プレフィックス引数を使用すると、その代わりにバッファが別のウィンドウに表示されます。
@end table

@defopt magit-diff-visit-previous-blob
このオプションは、@code{magit-diff-visit-file}が前のblobを訪問できるかどうかを制御します。これが@code{t}（デフォルト）であり、コミットされた変更のdiff内の削除された行にポイントがある場合、@code{magit-diff-visit-file}はその行がまだ残っている最後のリビジョンのblobを訪問します。

現在、これはコミットされた変更に対してのみサポートされています。ステージされた変更(staged
changes)とステージされていない変更(unstaged
changes)の場合、@code{magit-diff-visit-file}は常に作業ツリー内のファイルを訪問します。
@end defopt

@table @asis
@item @kbd{C-<return>} (@code{magit-diff-visit-file-worktree})
@kindex C-<return>
@findex magit-diff-visit-file-worktree
このコマンドは、適切なファイルの作業ツリーバージョンを訪問します。diff内のポイントの位置によって、訪問されるファイルが決まります。@code{magit-diff-visit-file}とは異なり、常に作業ツリー内の「実際の」ファイル、つまりファイルの「現在のバージョン」を訪問します。

file-visitingバッファでは、このコマンドは、diffでポイントある行に対応する行に移動します。作業ツリーで追加または削除された行、インデックス、およびその間のその他のコミットは、自動的に考慮されます。

選択したウィンドウにバッファが表示されます。プレフィックス引数を使用すると、その代わりにバッファが別のウィンドウに表示されます。
@end table

上記の2つのコマンドのバリエーションがあります。それらは上記の代わりに別のウィンドウまたは別のフレームでファイルを訪問します。このような動作が必要な場合は、上記のキーバインディングを変更することをお勧めしますが、上記のコマンドは、プレフィックス引数を指定して呼び出されたときに別のウィンドウも使用することに注意してください。

@deffn Command magit-diff-visit-file-other-window
@end deffn
@deffn Command magit-diff-visit-file-other-frame
@end deffn
@deffn Command magit-diff-visit-worktree-file-other-window
@end deffn
@deffn Command magit-diff-visit-worktree-file-other-frame
@end deffn

@node Blaming
@section Blaming

こちらもご覧下さい 
@ifinfo
@ref{git-blame,,,gitman,}
@end ifinfo
@ifhtml
@c html
@c end html
the <a href="http://git-scm.com/docs/git-blame">git-blame(1)</a> manpage.
@end ifhtml
@iftex
the git-blame(1) manpage.
@end iftex

blameを開始するには、@code{C-c
M-g}を押して、@code{magit-file-dispatch}のトランジェントプレフィックスコマンドを呼び出します。

blameサフィックスコマンドは、ディスパッチトランジェントコマンドから呼び出すことができます。
ただし、インフィックス引数を設定する場合は、最初にblameサブトランジェントコマンドを入力する必要があります。

以下に示すキーバインディングは、デフォルトのバインディングを使用してディスパッチトランジェントコマンドを入力することを前提としています。

@table @asis
@item @kbd{C-c M-g B} (@code{magit-blame})
@kindex C-c M-g B
@findex magit-blame
このトランジェント(一時的)なプレフィックス(接頭辞)コマンドは、それに従うサフィックス(接尾辞)コマンドを適切なインフィックス(中置)引数とともに結び付け、いずれかのサフィックスコマンドを選択するまでの間、そのインフィックス引数達とサフィックスコマンド達を一時バッファ(temporary
buffer)に表示します。
@end table

注意:
以下のサフィックスコマンドのすべてが常に使用できるわけではないことに注意してください。たとえば、@code{magit-blame-mode}が有効になっていない場合、そのモードをオフにすることを目的としたコマンドは役に立たないため、使用できません。

@table @asis
@item @kbd{C-c M-g b} (@code{magit-blame-addition})
@itemx @kbd{C-c M-g B b}
@kindex C-c M-g b
@kindex C-c M-g B b
@findex magit-blame-addition
このコマンドは、現在のfile-visitingまたはblob-visitingバッファ内の各行または行のチャンクに、これらの行に最後にアクセス(touch)したコミットに関する情報を追加します。

バッファがそのファイルのリビジョンを訪問すると、そのリビジョンまでの履歴が考慮されます。それ以外の場合は、コミットされていない変更を含む、ファイルの完全な履歴が考慮されます。

現在のバッファでMagit-Blameモードがすでにオンになっている場合は、REVISION:FILEを訪問して(@code{magit-find-file}を使用)、再帰的にblameを行います。ここで、REVISIONは、現在の行または行のチャンクを追加したリビジョンの親です。

@item @kbd{C-c M-g r} (@code{magit-blame-removal})
@itemx @kbd{C-c M-g B r}
@kindex C-c M-g r
@kindex C-c M-g B r
@findex magit-blame-removal
このコマンドは、現在のblob-visitingバッファ内の各行または行のチャンクを、それを削除するリビジョンに関する情報で補強します。file-visitingバッファでは使用できません。

@code{magit-blame-addition}と同様に、このコマンドは再帰的に使用できます。

@item @kbd{C-c M-g f} (@code{magit-blame-reverse})
@itemx @kbd{C-c M-g B f}
@kindex C-c M-g f
@kindex C-c M-g B f
@findex magit-blame-reverse
このコマンドは、現在のfile-visitingまたはblob-visitingバッファ内の各行または行のチャンクに、行がまだ存在していた最後のリビジョンに関する情報を追加します。

@code{magit-blame-addition}と同様に、このコマンドは再帰的に使用できます。

@item @kbd{C-c M-g e} (@code{magit-blame-echo})
@itemx @kbd{C-c M-g B e}
@kindex C-c M-g e
@kindex C-c M-g B e
@findex magit-blame-echo
このコマンドは@code{magit-blame-addition}に似ていますが、@code{read-only-mode}がオンにならず、最初はオプション@code{magit-blame-echo-style}で指定された視覚化スタイルを使用する点が異なります。
@end table

Magit-Blameモードが有効で、読み取り専用モードが有効になっていない場合は、以下のキーバインディングを使用できます。これらのコマンドは、他のバッファでも使用できます。ここでは、blameされているfile-visitingバッファに関連する動作のみが説明されています。

@table @asis
@item @kbd{@key{RET}} (@code{magit-show-commit})
@kindex RET
@findex magit-show-commit
このコマンドは、ポイントで行に最後に触れたコミットを表示します。

@item @kbd{@key{SPC}} (@code{magit-diff-show-or-scroll-up})
@kindex SPC
@findex magit-diff-show-or-scroll-up
このコマンドは、コミットバッファを更新します。

これは、適切なバッファ内のポイントで最後に行に触れたコミットを示します。または、そのバッファが現在のフレームに既に表示されていて、そのバッファにそのコミットに関する情報が含まれている場合は、代わりにバッファが上にスクロールされます。

@item @kbd{@key{DEL}} (@code{magit-diff-show-or-scroll-down})
@kindex DEL
@findex magit-diff-show-or-scroll-down
このコマンドは、コミットバッファを更新します。

これは、適切なバッファ内のポイントで最後に行に触れたコミットを示します。または、そのバッファが現在のフレームに既に表示されていて、そのバッファにそのコミットに関する情報が含まれている場合は、代わりにバッファが下にスクロールされます。
@end table

以下のキーバインディングは、Magit-Blameモードと読み取り専用モードの両方が有効になっている場合に使用できます。

@table @asis
@item @kbd{b} (@code{magit-blame})
@kindex b
@findex magit-blame
上記参照。

@item @kbd{n} (@code{magit-blame-next-chunk})
@kindex n
@findex magit-blame-next-chunk
このコマンドは次のチャンクに移動します。

@item @kbd{N} (@code{magit-blame-next-chunk-same-commit})
@kindex N
@findex magit-blame-next-chunk-same-commit
このコマンドは、同じコミットから次のチャンクに移動します。

@item @kbd{p} (@code{magit-blame-previous-chunk})
@kindex p
@findex magit-blame-previous-chunk
このコマンドは前のチャンクに移動します。

@item @kbd{P} (@code{magit-blame-previous-chunk-same-commit})
@kindex P
@findex magit-blame-previous-chunk-same-commit
このコマンドは、同じコミットから前のチャンクに移動します。

@item @kbd{q} (@code{magit-blame-quit})
@kindex q
@findex magit-blame-quit
このコマンドは、Magit-Blameモードをオフにします。 再帰的なblameの間にバッファが作成された場合は、バッファも強制終了します。

@item @kbd{M-w} (@code{magit-blame-copy-hash})
@kindex M-w
@findex magit-blame-copy-hash
このコマンドは、現在のチャンクのコミットのハッシュをキルリングに保存します。

リージョンがアクティブな場合、コマンドは@code{kill-ring-save}のように、ハッシュではなくリージョンのコンテンツを保存します。

@item @kbd{c} (@code{magit-blame-cycle-style})
@kindex c
@findex magit-blame-cycle-style
このコマンドは、オプション@code{magit-blame-styles}を使用して指定されたスタイルを循環することにより、現在のバッファでのblame情報の視覚化方法を変更します。
@end table

blameは、以下のオプションを使用して制御されます。

@defopt magit-blame-styles
このオプションは、blame情報を視覚化するために使用されるスタイルのリストを定義します。詳細については、今のところはそのdoc-stringを参照してください。
@end defopt

@defopt magit-blame-echo-style
このオプションは、コマンド@code{magit-blame-echo}で使用されるblameの視覚化スタイルを指定します。
これは、@code{magit-blame-styles}で定義されているスタイルの1つの識別子として使用されるシンボルである必要があります。
@end defopt

@defopt magit-blame-time-format
このオプションは、blame報を表示するときに時間を表示するために使用される書式文字列を指定します。
@end defopt

@defopt magit-blame-read-only
このオプションは、バッファをblameすることで一時的に読み取り専用にするかどうかを制御します。
@end defopt

@defopt magit-blame-disable-modes
このオプションは、バッファにblame情報が含まれている場合に一時的に無効にする必要がある互換性のないマイナーモードを一覧表示します。バッファにblame情報が表示されなくなると、これらは再び有効になります。
@end defopt

@defopt magit-blame-goto-chunk-hook
このフックは、チャンク間を移動するときに実行されます。
@end defopt

@node Manipulating
@chapter Manipulating

@menu
* Creating Repository::      Creating Repository
* Cloning Repository::       Cloning Repository
* Staging and Unstaging::    Staging and Unstaging
* Applying::                 Applying
* Committing::               Committing
* Branching::                Branching
* Merging::                  Merging
* Resolving Conflicts::      Resolving Conflicts
* Rebasing::                 Rebasing
* Cherry Picking::           Cherry Picking
* Resetting::                Resetting
* Stashing::                 Stashing
@end menu

@node Creating Repository
@section Creating Repository

@table @asis
@item @kbd{I} (@code{magit-init})
@kindex I
@findex magit-init
このコマンドは、リポジトリを初期化してから、新しいリポジトリのステータスバッファを表示します。

ディレクトリが既存のリポジトリの下にある場合、ユーザーは新しいリポジトリを内部に作成する必要があることを確認する必要があります。ディレクトリが既存のリポジトリのルートである場合、ユーザーはそれを再初期化する必要があることを確認する必要があります。
@end table

@node Cloning Repository
@section Cloning Repository

リモートまたはローカルリポジトリのクローンを作成するには、コマンド@code{magit-clone}に結び付けられている@code{C}を使用します。このコマンドは、いくつかのインフィックス引数とサフィックスコマンドを結びつけるするトランジェントプレフィックスコマンドとして機能するか、プレフィックス(接頭辞)引数が使用されているかどうかと@code{magit-clone-always-transient}の値に応じて、@code{git
clone}を直接呼び出すことができます。

@defopt magit-clone-always-transient
このオプションは、プレフィックス(接頭辞)引数が使用されているかどうかに関係なく、コマンド@code{magit-clone}が常にトランジェントプレフィックスコマンドとして機能するかどうかを制御します。@code{t}の場合、そのコマンドは常にトランジェントプレフィックスコマンドとして機能します。@code{nil}の場合、トランジェントコマンドとして機能させるには、プレフィックス引数を使用する必要があります。
@end defopt

@table @asis
@item @kbd{C} (@code{magit-clone})
@kindex C
@findex magit-clone
このコマンドは、上記のようにトランジェントプレフィックスコマンドとして機能するか、以下で説明するように@code{transient-clone-regular}と同じことを行います。

トランジェントプレフィックスコマンドとして機能する場合は、それに従うサフィックスコマンドといくつかのインフィックス引数が結び付けられます。

@item @kbd{C C} (@code{magit-clone-regular})
@kindex C C
@findex magit-clone-regular
このコマンドは、既存のリポジトリの通常のクローンを作成します。 リポジトリとターゲットディレクトリがユーザーから読み取られます。

@item @kbd{C s} (@code{magit-clone-shallow})
@kindex C s
@findex magit-clone-shallow
このコマンドは、既存のリポジトリの浅いクローン(shallow
clone)を作成します。リポジトリとターゲットディレクトリがユーザーから読み取られます。
デフォルトでは、複製される履歴の深さが1だけのコミットであるクローンですが、プレフィックス引数を使用すると、その深さはユーザーから読み取られます。

@item @kbd{C >} (@code{magit-clone-sparse})
@kindex C >
@findex magit-clone-sparse
このコマンドは、既存のリポジトリのクローンを作成し、スパースチェックアウト(sparse
checkout;疎なチェックアウト)を初期化して、作業ツリー全部のチェックアウトを回避します。
さらにディレクトリを追加するには、@code{magit-sparse-checkout} トランジェントを使用します (@ref{Sparse
checkouts} を参照)。

@item @kbd{C b} (@code{magit-clone-bare})
@kindex C b
@findex magit-clone-bare
このコマンドは、既存のリポジトリのbareクローンを作成します。リポジトリとターゲットディレクトリがユーザーから読み取られます。

@item @kbd{C m} (@code{magit-clone-mirror})
@kindex C m
@findex magit-clone-mirror
このコマンドは、既存のリポジトリのミラーを作成します。リポジトリとターゲットディレクトリがユーザーから読み取られます。
@end table

以下のサフィックスコマンドはデフォルトで無効になっています。有効にする方法についてはこちらを参照して下さい(@ref{Enabling and
Disabling Suffixes,,,transient,})。

@table @asis
@item @kbd{C d} (@code{magit-clone-shallow-since})
@kindex C d
@findex magit-clone-shallow-since
このコマンドは、既存のリポジトリの浅い(shallow)クローンを作成します。ユーザーから読み取られた日付の後にコミットされたコミットのみが複製され、リポジトリとターゲットディレクトリもユーザーから読み取られます。

@item @kbd{C e} (@code{magit-clone-shallow-exclude})
@kindex C e
@findex magit-clone-shallow-exclude
このコマンドは、既存のリポジトリの浅い(shallow)クローンを作成します。ユーザーからブランチまたはタグが読み取られます。そのブランチまたはタグから到達可能なコミットを除外します。リポジトリとターゲットディレクトリもユーザーから読み取られます。
@end table

@defopt magit-clone-set-remote-head
このオプションは、クローン作成によって reference @code{refs/remotes/<remote>/HEAD}
がクローンに作成されるかどうかを制御します。デフォルトでは、@code{git
clone}を実行した後、referenceを削除します。これにより、referenceの作成が要求されます。
これは、リモートの@code{HEAD}が変更されたときに自動的に更新されないため、referenceが特に有用であることが判明していないためです。このオプションを@code{t}に設定すると、referenceを作成するというGitのデフォルトの動作が維持されます。
@end defopt

@defopt magit-clone-set-remote.pushDefault
このオプションは、クローン作成後にGit変数@code{remote.pushDefault}の値を設定するかどうかを制御します。

@itemize
@item
@code{t}の場合、常に問い合わせ無しで設定されます。
@item
@code{ask}の場合、ユーザーはリポジトリのクローンを作成するたびに問い合わせされます。
@item
@code{nil}の場合、設定されません。
@end itemize
@end defopt

@defopt magit-clone-default-directory
このオプションは、クローン作成操作の宛先(destination)を読み取るときに使用されるデフォルトのディレクトリ名を制御します。

@itemize
@item
@code{nil}（デフォルト）の場合、@code{default-directory}の値が使用されます。
@item
ディレクトリの場合は、それが使用されます。
@item
関数の場合、それは唯一の引数としてリモートURLを使用して呼び出され、その戻り値が使用されます。
@end itemize
@end defopt

@defopt magit-clone-name-alist
このオプションは、リポジトリ名に一致する正規表現をリポジトリURLにマップし、ユーザーがリポジトリのクローンを作成するときにURLの代わりに短い名前を入力できるようにします。

各要素の形式は@code{(REGEXP HOSTNAME
USER)}です。クローン作成コマンドが名前またはURLを要求したときにユーザーが名前を入力すると、それがこのリストで検索されます。REGEXPが一致する最初の要素が使用されます。

オプション@code{magit-clone-url-format}で指定された形式は、HOSTNAMEとリポジトリ名を使用して名前をURLに変換するために使用されます。指定された名前にスラッシュが含まれている場合は、それが使用されます。それ以外の場合、名前でリポジトリの所有者が省略されている場合は、一致したエントリで指定されているデフォルトのユーザーが使用されます。

USERにドットが含まれている場合、それはGit変数として扱われ、その値がユーザー名として使用されます。それ以外の場合は、USERがユーザー名自体として使用されます。
@end defopt

@defopt magit-clone-url-format
このオプションで指定された形式は、リポジトリ名をURLに変換するときに使用されます。@code{%h}はホスト名であり、@code{%n}は所有者の名前を含むリポジトリ名です。
値は、文字列(単一の静的フォーマットを表す)またはホスト名をフォーマットにマッピングする要素 @code{(HOSTNAME . FORMAT)}
を持つ alist にすることができます。 alist が使用される場合、@code{nil} キーはデフォルトの形式を表します。

単一のフォーマット文字列の例:

@lisp
(setq magit-clone-url-format
      "git@@%h:%n.git")
@end lisp

ホスト名によるフォーマット文字列の例:

@lisp
(setq magit-clone-url-format
      '(("git.example.com" . "git@@%h:~%n")
        (nil . "git@@%h:%n.git")))
@end lisp
@end defopt

@node Staging and Unstaging
@section Staging and Unstaging

もちろん、Gitと同様Magitは、完全なファイルをステージ(stage)およびステージ解除(unstage)できます。Gitとは異なり、ユーザーは個々のハンクやハンクの一部を適切にステージ/ステージ解除することもできます。Gitを直接使用して個々のハンクとハンクの一部をステージするには、@code{git
add --interactive}セッションの、モーダルでかなり不器用なインターフェースを使用する必要があります。

一方、Magitを使用すると、ステータスバッファまたは別のdiffバッファに表示されているdiff内のそれぞれのセクションにポイントを移動し、@code{s}または@code{u}と入力するだけで、個々のハンクのステージを解除(unstage)/ステージ(stage)できます。ハンクの一部だけを操作するには、リージョンを使用してステージ/ステージ解除する必要のある変更にマークを付けてから、ステージ/ステージ解除に使用するのと同じキーを押します。複数のファイルまたはハンクを一度にステージするには、そのようなセクションの見出しの内側で始まり、同じタイプの兄弟セクションの見出しの内側で終わるリージョンを使用します。

ステージ(stage)とステージ解除(unstage)に加えて、Magitは、ファイルや一度に複数のファイルやハンクや一度に複数のハンクやハンクの一部を操作できる他のいくつかの「適用バリエーション」(apply
variants)も提供します。 これらの適用バリエーション(apply variants)については、次の節で説明します。

あなたはEdiffを使用してステージ(stage)およびステージ解除(unstage)することもできます。こちらを参照して下さい(@ref{Ediffing})。

@table @asis
@item @kbd{s} (@code{magit-stage})
@kindex s
@findex magit-stage
ポイントでの変更をステージ領域に追加します。

プレフィックス引数と追跡されていないファイル(untracked
file)(または複数のファイル)をポイントに指定して、ファイルをステージしますが、その内容はステージしません。これにより、新しいファイルの変更のサブセットのみをステージすることが可能になります。

@item @kbd{S} (@code{magit-stage-modified})
@kindex S
@findex magit-stage-modified
ワークツリー内で変更されたファイルへのすべての変更をステージします。追跡中のファイル(tracked
files)のすべての新しいコンテンツをステージし、もはや作業ツリーに存在しなくなった追跡中のファイル(訳注:つまり、削除されたファイル)をインデックスから削除します。プレフィックス引数を使用すると、まだ追跡中でない(ただし無視されない;訳注:つまり@code{.gitignore}の対象でない)ファイルもステージされます。

@item @kbd{u} (@code{magit-unstage})
@kindex u
@findex magit-unstage
ステージ領域からポイントされた変更(the change)を削除します。

ステージされた変更のみがステージ解除できます。
ただし、デフォルトでは、このコマンドは、コミットされた変更で呼び出されたときに、ステージ解除にいくらか似たアクションを実行します。インデックスの変更を元に戻しますが、作業ツリーでは元に戻しません。

@item @kbd{U} (@code{magit-unstage-all})
@kindex U
@findex magit-unstage-all
ステージ領域からすべての変更を削除します。
@end table

@defopt magit-unstage-committed
このオプションは、@code{magit-unstage}が変更をコミットしたかどうかを、作業ツリーではなくインデックスで逆にすることによって制御します。別の方法は、エラーを発生させることです。
@end defopt

@table @asis
@item @kbd{M-x magit-reverse-in-index}
@findex magit-reverse-in-index
このコマンドは、作業ツリーではなく、インデックス内のポイントでコミットされた変更を元に戻します。デフォルトでは、このコマンドに直接結び付けられたキーはありませんが、コミットされた変更で@code{u}(@code{magit-unstage})が押されると、間接的に呼び出されます。

これにより、@code{HEAD}から変更を抽出し、作業ツリーに残しておくことができるため、後で別のコミットを使用してコミットできます。典型的なワークフローは以下のとおりです:

@enumerate
@item
(オプションで、コミットされていない変更がないことを確認します。)
@item
@code{HEAD}コミットを訪問し、そのコミットに含まれるべきではなかった変更に移動します。
@item
@code{u}(@code{magit-unstage})と入力して、インデックスで逆にします。これは、@code{magit-unstage-committed-changes}がnil以外であることを前提としています。
@item
@code{c e}と入力して、@code{HEAD}を拡張し、以前に既にステージされた変更を含めます。
@item
オプションで、@code{s}または@code{S}を使用して残りの変更をステージし、@code{c c}と入力して新しいコミットを作成します。
@end enumerate

@item @kbd{M-x magit-reset-index}
@findex magit-reset-index
インデックスをコミットにリセットします(Reset the index to some
commit)。コミットはユーザーから読み取られ、デフォルトでその時点でコミットされます。その時点でコミットがない場合、デフォルトで@code{HEAD}になります。
@end table

@menu
* Staging from File-Visiting Buffers::  Staging from File-Visiting Buffers
@end menu

@node Staging from File-Visiting Buffers
@subsection Staging from File-Visiting Buffers

きめ細かいステージ/ステージ解除は、ステータスまたはdiffバッファから実行する必要がありますが、現在のバッファで訪問したファイルに加えられたすべての変更を、そのバッファ内から直接ステージ/ステージ解除することもできます。

@table @asis
@item @kbd{M-x magit-stage-file}
@findex magit-stage-file
file-visitingバッファ内で呼び出されると、そのファイルへのすべての変更をステージします。Magitバッファで、ファイルがある場合はその時点でステージします。それ以外の場合は、ステージするファイルの入力を求めます。プレフィックス引数を使用すると、file-visitingバッファ内やポイントにファイルセクションがある場合でも、常にユーザーにファイルの入力を求めるプロンプトが表示されます。

@item @kbd{M-x magit-unstage-file}
@findex magit-unstage-file
file-visitingバッファ内で呼び出された場合は、そのファイルへのすべての変更をステージ解除します。
Magitバッファで、ある場合はその時点でファイルのステージを解除します。それ以外の場合は、ファイルのステージを解除するように求められます。プレフィックス引数を使用すると、file-visitingバッファ内やポイントにファイルセクションがある場合でも、常にユーザーにファイルの入力を求めるプロンプトが表示されます。
@end table

@node Applying
@section Applying

Magitはいくつかの適用バリエーションを提供します。それはステージ(stage)とステージ解除(unstage)と破棄(discard)と戻し(reverse)と通常のapply(regular
apply)です。少なくともハンクで操作する場合、それらはすべて@code{git
apply}を使用して実装されます。そのため、これらは適用バリエーション("apply variants")と呼ばれます。

@itemize
@item
ステージ(stage)。作業ツリーからインデックスに変更を適用(apply)します。変更は作業ツリーにも残ります。

@item
ステージ解除(unstage)。インデックスから変更を削除します。 変更は作業ツリーに残ります。

@item
破棄(discard)。ステージされた変更(staged
change)において、作業ツリーとインデックスから削除します。ステージされていない変更(unstaged
change)では、作業ツリーからのみ削除します。

@item
戻し(reverse)。作業ツリーの変更を元に戻します。 コミットされた変更とステージされた変更(staged
changes)の両方を元に戻すことができます。ステージされていない変更(unstaged
changes)は元に戻すことはできないので破棄(discard)します。

@item
適用(apply)。作業ツリーに変更を適用します。コミットされた変更とステージされた変更(staged
changes)の両方を適用できます。ステージされていない変更(unstaged
changes)は適用できません。なぜならそれはすでに適用されているためです。
@end itemize

前節は、ステージコマンドとステージ解除コマンドについて説明しました。以下は、残りの適用バリエーションを実装するコマンドです。

@table @asis
@item @kbd{a} (@code{magit-apply})
@kindex a
@findex magit-apply
ポイントでの変更を作業ツリーに適用(apply)します。

プレフィックス引数を使用して、3方向マージにフォールバックします。これを行うと、変更がインデックスにも適用されます。

@item @kbd{k} (@code{magit-discard})
@kindex k
@findex magit-discard
ポイントでの変更を作業ツリーから削除します。

競合が解決されていないハンクまたはファイルでは、どちらの側を保持するかを確認します(もう一方を破棄します)。ポイントがそのどちらか側のテキスト内にある場合は、プロンプトを表示せずにその側を保持します。

@item @kbd{v} (@code{magit-reverse})
@kindex v
@findex magit-reverse
作業ツリーのポイントの変更を元に戻します。

プレフィックス引数を使用して、3方向マージにフォールバックします。これを行うと、変更がインデックスにも適用されます。
@end table

プレフィックス引数を使用すると、すべてのapplyバリエーションは、適切な場合（つまり、@code{git
apply}が内部で使用される場合）に3方向マージを試行します。

@node Committing
@section Committing

ユーザーがコミットを開始すると、Magitは引数なしで@code{git
commit}を呼び出すため、Gitはユーザーからコミットを取得する必要があります。ファイル@code{.git/COMMIT_EDITMSG}を作成し、そのファイルをエディターで開きます。Magitは、そのエディターがEmacsclientになるように手配します。ユーザーが編集セッションを終了すると、Emacsclientが終了し、Gitはファイルのコンテンツをメッセージとして使用してコミットを作成します。

@menu
* コミット開始::       コミット開始
* Editing Commit Messages::  Editing Commit Messages
@end menu

@node コミット開始
@subsection コミット開始

こちらもご覧下さい 
@ifinfo
@ref{git-commit,,,gitman,}
@end ifinfo
@ifhtml
@c html
@c end html
the <a href="http://git-scm.com/docs/git-commit">git-commit(1)</a> manpage.
@end ifhtml
@iftex
the git-commit(1) manpage.
@end iftex

@table @asis
@item @kbd{c} (@code{magit-commit})
@kindex c
@findex magit-commit
このトランジェント(一時的)なプレフィックス(接頭辞)コマンドは、それに従うサフィックス(接尾辞)コマンドを適切なインフィックス(中置)引数とともに結び付け、いずれかのサフィックスコマンドを選択するまでの間、そのインフィックス引数達とサフィックスコマンド達を一時バッファ(temporary
buffer)に表示します。

@item @kbd{c c} (@code{magit-commit-create})
@kindex c c
@findex magit-commit-create
@code{HEAD}に新しいコミットを作成します。プレフィックス引数を伴うと、代わりに@code{HEAD}でコミットを修正(amend)します。

@item @kbd{c a} (@code{magit-commit-amend})
@kindex c a
@findex magit-commit-amend
最後のコミットを修正(amend)。

@item @kbd{c e} (@code{magit-commit-extend})
@kindex c e
@findex magit-commit-extend
メッセージを編集せずに、最後のコミットを修正します。プレフィックス引数を伴うとコミッターの日付(committer
date)を保持します。それ以外の場合は変更します。
オプション@code{magit-commit-extend-override-date}を使用して、プレフィックス引数の意味を逆にすることができます。

オプションのOVERRIDE-DATE引数を非対話的に尊重し、オプションを無視します。

@item @kbd{c w} (@code{magit-commit-reword})
@kindex c w
@findex magit-commit-reword
ステージされた変更を無視して、最後のコミットをreword(言い換え)します。
プレフィックス引数を使用してコミッターの日付を保持します。それ以外の場合は変更します。オプション@code{magit-commit-reword-override-date}を使用して、プレフィックス引数の意味を逆にすることができます。

オプションのOVERRIDE-DATE引数を非対話的に尊重し、オプションを無視します。

@item @kbd{c f} (@code{magit-commit-fixup})
@kindex c f
@findex magit-commit-fixup
fixupミットを作成します。

プレフィックス引数を使用して、ターゲットコミットを確認する必要があります。
それ以外の場合、オプション@code{magit-commit-squash-confirm}の値によっては、そのポイントでのコミットが確認なしで使用される可能性があります。

@item @kbd{c F} (@code{magit-commit-instant-fixup})
@kindex c F
@findex magit-commit-instant-fixup
fixupコミットを作成し、即座にリベースします。

@item @kbd{c s} (@code{magit-commit-squash})
@kindex c s
@findex magit-commit-squash
squashメッセージを編集せずに、squashコミットを作成します。

プレフィックス引数を使用して、ターゲットコミットを確認する必要があります。
それ以外の場合、オプション@code{magit-commit-squash-confirm}の値によっては、そのポイントでのコミットが確認なしで使用される可能性があります。

@item @kbd{c S} (@code{magit-commit-instant-squash})
@kindex c S
@findex magit-commit-instant-squash
squashコミットを作成し、即座にリベースします。

@item @kbd{c A} (@code{magit-commit-augment})
@kindex c A
@findex magit-commit-augment
squashメッセージを編集して、squashコミットを作成します。

プレフィックス引数を使用して、ターゲットコミットを確認する必要があります。
それ以外の場合、オプション@code{magit-commit-squash-confirm}の値によっては、そのポイントでのコミットが確認なしで使用される可能性があります。
@end table

@defopt magit-commit-ask-to-stage
コミット時にステージされていないすべての変更(all unstaged changes)をステージするよう問い合わせるか、あるいは何もステージしないか。
@end defopt

@defopt magit-commit-show-diff
コミット時に関連するdiffが自動的に表示されるかどうか。
@end defopt

@defopt magit-commit-extend-override-date
@code{magit-commit-extend}の使用によってコミッターの日付を変更するかどうか。
@end defopt

@defopt magit-commit-reword-override-date
@code{magit-commit-reword}の使用によってコミッターの日付を変更するかどうか。
@end defopt

@defopt magit-commit-squash-confirm
squashとfixupの対象となるコミットを確認する必要があるかどうか。nil以外の場合、ポイントでのコミット（存在する場合）がデフォルトの選択として使用されます。
それ以外の場合は確認する必要があります。このオプションは、@code{magit-commit-squash}と@code{magit-commit-fixup}にのみ影響します。「インスタント」バリエーションは、使用中にエラーが発生すると回復が困難になるため、常に確認が必要です。
@end defopt

@defopt magit-post-commit-hook
ユーザーがメッセージを編集せずにコミットを作成した後、フックを実行します。

@code{this-command}が@code{magit-post-stage-hook-commands}のメンバーである場合、このフックは@code{magit-refresh}によって実行されます。これには、@code{magit-commit-*}という名前のコマンドのみが含まれ、ユーザーがバッファ内のコミットメッセージを編集する必要は「ありません」。

こちらもご覧下さい→@code{git-commit-post-finish-hook}
@end defopt

@defopt magit-commit-diff-inhibit-same-window
コミット中にdiffを表示するときに同じウィンドウの使用を禁止するかどうか。

コミットを書き込むと、コミットされる変更のdiffが自動的に表示されます。このアイデアは、diffが同じフレームの別のウィンドウに表示され、ほとんどのユーザーにとっては正常に機能するというものです。言い換えると、ほとんどのユーザーは、このオプションの値がユーザーに違いをもたらさないため、このオプションを完全に無視できます。

ただし、パッケージが明示的に作成しようとしても新しいウィンドウを作成しないようにEmacsを構成したユーザーにとって、2つの新しいバッファを表示すると、必然的に最初のバッファがすぐに2番目のバッファに置き換えられます。
私たちの場合、メッセージバッファはすぐにdiffバッファに置き換えられますが、これはもちろん非常に望ましくありません。

回避策としては、この特定の場合にこのユーザー構成を抑制することです。
ユーザーは、このオプション切り替えに関して明示的に事前に同意(opt-in)を取る要があります。この回避策を無条件に有効にすることはできません。これも他のユーザーに問題を引き起こすためです。フレームが小さすぎるか、関連する設定が強すぎると、diffバッファが新しいフレームに表示されることになります。

こちらも参照下さい(@uref{https://github.com/magit/magit/issues/4132})。
@end defopt

@node Editing Commit Messages
@subsection Editing Commit Messages

前節で説明したようにコミットを開始すると、2つの新しいバッファが表示されます。1つはコミットされようとしている変更を示し、もう1つはメッセージの書き込みに使用されます。

コミットメッセージは編集セッションで編集されます。バックグラウンドで@code{git}は、エディタ(この場合は@code{emacsclient})がコミットメッセージをファイル(ほとんどの場合@code{.git/COMMIT_EDITMSG})に保存するのを待機しています。そして戻ります。エディタがゼロ以外の終了ステータスで戻った場合、@code{git}はコミットを作成しません。したがって、最も重要なコマンドは、コミットを終了および中止するためのコマンドです。

@table @asis
@item @kbd{C-c C-c} (@code{with-editor-finish})
@kindex C-c C-c
@findex with-editor-finish
終了コード0で戻ることにより、現在の編集セッションを終了します。次に、Gitは、ファイル内で見つけたメッセージを使用してコミットを作成します。

@item @kbd{C-c C-k} (@code{with-editor-cancel})
@kindex C-c C-k
@findex with-editor-cancel
終了コード1で戻ることにより、現在の編集セッションをキャンセルします。Gitはコミットをキャンセルしますが、ファイルは変更されません。
@end table

@code{git
commit}によって使用されることに加えて、メッセージはEmacsが閉じられるまで持続するリング(ring)に保存されることもあります。デフォルトでは、メッセージは、(セッションが正常に終了したかキャンセルされたかに関係なく、)編集セッションの開始時と終了時に保存されます。そのリングからメッセージを戻すと便利な場合があります。

@table @asis
@item @kbd{C-c M-s} (@code{git-commit-save-message})
@kindex C-c M-s
@findex git-commit-save-message
現在のバッファの内容をコミットメッセージリングに保存します。

@item @kbd{M-p} (@code{git-commit-prev-message})
@kindex M-p
@findex git-commit-prev-message
現在のメッセージをリングに保存した後、コミットメッセージリングを逆方向に循環します。数字のプレフィックス引数を付けると、コメントをその数字の個数分遡ります。

@item @kbd{M-n} (@code{git-commit-next-message})
@kindex M-n
@findex git-commit-next-message
現在のメッセージをリングに保存した後、コミットメッセージリングを順方向に循環します。数字のプレフィックス引数を付けると、コメントをその数字の個数分遡ります。
@end table

デフォルトでは、コミットしようとしている変更のdiffは、コミットを呼び出すときに自動的に表示されます。これを防ぐには、@code{server-switch-hook}から@code{magit-commit-diff}を削除します。

既存のコミットを修正するときは、そのコミットに追加されようとしている変更を表示するか、すでにコミットされている変更と一緒にそれらの変更を表示すると便利な場合があります。

@table @asis
@item @kbd{C-c C-d} (@code{magit-diff-while-committing})
@kindex C-c C-d
@findex magit-diff-while-committing
コミット中に、コミットしようとしている変更を表示します。修正中にコマンドを再度呼び出すと、新しい変更のみを表示するか、コミットされるすべての変更を表示するかが切り替わります。
@end table

@menu
* Using the Revision Stack::  Using the Revision Stack
* Commit Pseudo Headers::    Commit Pseudo Headers
* Commit Mode and Hooks::    Commit Mode and Hooks
* Commit Message Conventions::  Commit Message Conventions
@end menu

@node Using the Revision Stack
@unnumberedsubsubsec Using the Revision Stack

@table @asis
@item @kbd{C-c C-w} (@code{magit-pop-revision-stack})
@kindex C-c C-w
@findex magit-pop-revision-stack
このコマンドは、リビジョンの表現(representation)を現在のバッファに挿入します。コミットメッセージの書き込みに使用されるバッファ内だけでなく、電子メール(email)やChangeLogファイルの編集に使用されるバッファなどの他のバッファでも使用できます。

デフォルトでは、このコマンドは@code{magit-revision-stack}に最後に追加されたリビジョンをポップし、@code{magit-pop-revision-stack-format}に従って現在のバッファに挿入します。リビジョンは、@code{magit-copy-section-value}と@code{magit-copy-buffer-revision}を使用してスタックに配置できます。

スタックが空であるか、プレフィックス引数がある場合は、代わりにミニバッファのリビジョンを読み取ります。ミニバッファ履歴を使用することにより、以前にポップされたアイテムを選択したり、最初にスタックにプッシュせずに任意のreferenceまたはリビジョンを挿入したりできます。

ミニバッファからリビジョンを読み取るとき、正しいリポジトリを推測できない場合があります。このコマンドがリポジトリ内で呼び出されると(たとえば、コミットメッセージの作成中に)、そのリポジトリが使用されます。
それ以外の場合(たとえば、電子メールの作成中)、(別のリビジョンを挿入した場合でも)スタックの最上位要素として記録されたリポジトリが使用されます。リポジトリ内で呼び出されず、スタックが空の場合、またはプレフィックス引数が2つある場合は、ミニバッファのリポジトリも読み取ります。
@end table

@defopt magit-pop-revision-stack-format
このオプションは、コマンド@code{magit-pop-revision-stack}が現在のバッファにリビジョンを挿入する方法を制御します。

スタックのエントリの形式は@code{(HASH TOPLEVEL)}で、このオプションの書式は@code{(POINT-FORMAT
EOB-FORMAT INDEX-REGEXP)}で、すべてnilまたは文字列です(ただし、
EOB-FORMATまたはPOINT-FORMATのいずれかを文字列にする必要があります。INDEX-REGEXPがnil以外の場合は、2つの書式も文字列にする必要があります)。

最初のINDEX-REGEXPは、ポイントから逆方向に検索することにより、以前に挿入されたエントリを見つけるために使用されます。最初の部分一致はインデックス番号と一致する必要があります。その番号が1ずつ増え、挿入されるエントリのインデックス番号になります。挿入されたリビジョンに番号を付けたくない場合は、INDEX-REGEXPにnilを使用します。

INDEX-REGEXPがnil以外の場合、POINT-FORMATとEOB-FORMATの両方に \"%N\"
が含まれている必要があります。これは、前の手順で決定された番号に置き換えられます。

両方の書式は、nil以外の場合、%Nを削除した後、TOPLEVEL内で@code{git show --format=FORMAT
...}を使用して展開されます。

POINT-FORMATの展開はポイントに挿入され、EOB-FORMATの展開はバッファの最後に挿入されます(バッファがコメントで終了する場合は、その直前に挿入されます)。
@end defopt

@node Commit Pseudo Headers
@unnumberedsubsubsec Commit Pseudo Headers

一部のプロジェクトでは、コミットメッセージで疑似ヘッダー(pseudo
header)を使用します。Magitはそのようなヘッダーを色付けし、そのようなヘッダーを挿入するためのいくつかのコマンドを提供します。

@defopt git-commit-known-pseudo-headers
強調表示されるGit疑似ヘッダーのリスト。
@end defopt

@table @asis
@item @kbd{C-c C-i} (@code{git-commit-insert-pseudo-header})
@kindex C-c C-i
@findex git-commit-insert-pseudo-header
コミットメッセージの疑似ヘッダーを挿入します。

@item @kbd{C-c C-a} (@code{git-commit-ack})
@kindex C-c C-a
@findex git-commit-ack
あなたがコミットをチェックしたことを承認(acknowledge)するヘッダーを挿入します。

@item @kbd{C-c C-r} (@code{git-commit-review})
@kindex C-c C-r
@findex git-commit-review
あなたがコミットをレビューしたことを承認(acknowledge)するヘッダーを挿入します。

@item @kbd{C-c C-s} (@code{git-commit-signoff})
@kindex C-c C-s
@findex git-commit-signoff
ヘッダーを挿入して、コミットを承認(sign off)します。

@item @kbd{C-c C-t} (@code{git-commit-test})
@kindex C-c C-t
@findex git-commit-test
あなたがコミットをテストしたことを承認(acknowledge)するヘッダーを挿入します。

@item @kbd{C-c C-o} (@code{git-commit-cc})
@kindex C-c C-o
@findex git-commit-cc
興味があるかもしれない誰かに言及するヘッダーを挿入します。

@item @kbd{C-c C-p} (@code{git-commit-reported})
@kindex C-c C-p
@findex git-commit-reported
コミットによって修正された問題を報告した人に言及するヘッダーを挿入します。

@item @kbd{C-c M-i} (@code{git-commit-suggested})
@kindex C-c M-i
@findex git-commit-suggested
変更を提案した人に言及するヘッダーを挿入します。
@end table

@node Commit Mode and Hooks
@unnumberedsubsubsec Commit Mode and Hooks

@code{git-commit-mode}は、特定のキーバインディングを確立するためにのみ使用されるマイナーモードです。
これにより、コミットメッセージの編集に使用されるバッファで任意のメジャーモードを使用できるようになります。異なるリポジトリで異なるメジャーモードを使用することも可能です。これは、異なるプロジェクトが異なるコミットメッセージ規則を課す場合に役立ちます。

@defopt git-commit-major-mode
このオプションの値は、Gitコミットメッセージの編集に使用されるメジャーモードです。
@end defopt

@code{git-commit-mode}はマイナーモードであるため、キーバインディングを除いて、そのモードフックを使用してバッファをセットアップしません。他のすべてのセットアップは、関数@code{git-commit-setup}で実行されます。この関数は、とりわけフック@code{git-commit-setup-hook}を実行します。

@defopt git-commit-setup-hook
@code{git-commit-setup}の最後でフックを実行します。
@end defopt

@noindent
このフックには、以下の関数が適しています:

@defun git-commit-save-message
現在のバッファの内容をコミットメッセージリングに保存します。
@end defun

@defun git-commit-setup-changelog-support
この関数が呼び出された後、ChangeLogエントリは段落(paragraph)として扱われます。
@end defun

@defun git-commit-turn-on-auto-fill
@code{auto-fill-mode}をオンにし、@code{fill-column}を@code{git-commit-fill-column}の値に設定します。
@end defun

@defun git-commit-turn-on-flyspell
Flyspellモードをオンにします。また、コメントがチェックされないようにし、最後に現在の非コメントテキストをチェックします。
@end defun

@defun git-commit-propertize-diff
コミットメッセージバッファ内に表示されるdiffをプロパティ化します。@code{--verbose}引数が使用されると、Gitはそのようなdiffをコミットメッセージテンプレートに挿入します。@code{magit-commit}は、別のバッファに表示されるdiffの方が便利なため、デフォルトではその引数を提供しません。
しかし、一部のユーザーはこれに同意しません。そのため、この機能が存在します。
@end defun

@defun bug-reference-mode
バッファ内のハイパーリンクのバグ参照(bug reference)。
@end defun

@defun with-editor-usage-message
エコーエリアに使用情報(usage information)を表示します。
@end defun

@defopt git-commit-post-finish-hook
ユーザーがコミットメッセージの書き込みを終了した後、フックを実行します。

このフックは、コミットメッセージの編集に使用されるバッファで@code{C-c
C-c}を押した後にのみ実行されます。ユーザーがバッファにメッセージを入力せずにコミットが作成された場合、このフックは実行されません。

このフックは、新しいコミットが作成されるまで実行されません。Gitがコミットを作成するのに1秒以上かかる場合、このフックはまったく実行されません。@code{magit-rebase-continue}などの特定のコマンドでは、競合状態が発生するため、このフックは実行されません。

このフックは、@code{magit}が利用可能な場合にのみ実行されます。

こちらもご覧ください→@code{magit-post-commit-hook}
@end defopt

@node Commit Message Conventions
@unnumberedsubsubsec Commit Message Conventions

Git-Commitは、一般的に受け入れられているコミットメッセージ規則の特定の違反を強調しています。特定の違反により、Git-Commitは、本当にそれを実行したいことを確認するように要求することさえあります。もちろん、このしつこい表示はオフにすることができますが、通常、それを行うと、コードの代わりに、コミットをレビューしている人間が、コミットを修正するように指示する時間を無駄にする必要があります。

@defopt git-commit-summary-max-length
コミットメッセージの要約行(summry line)の意図する最大桁数。この桁数を超える文字は、この設定に違反していることを示すために色分します。
@end defopt

@defopt git-commit-fill-column
それを超えると、コミットメッセージバッファで自動行折り返しが発生する桁数。
@end defopt

@defopt git-commit-finish-query-functions
コミットを実行する前にクエリを実行するために呼び出される関数のリスト。

関数が呼び出されている間、コミットメッセージバッファは最新です。それらのいずれかがnilを返す場合、コミットは実行されず、バッファは強制終了されません。
その後、ユーザーは問題を修正して再試行する必要があります。

関数は1つの引数で呼び出されます。nil以外の場合は、問題があるにもかかわらず、ユーザーがプレフィックス引数を使用してセッションを強制的に終了したことを示します。関数は通常、この願いを尊重し、nil以外を返す必要があります。

デフォルトでは、@code{git-commit-check-style-conventions}が唯一のメンバーです。
@end defopt

@defun git-commit-check-style-conventions
この関数は、特定の基本的なスタイル規則の違反をチェックします。違反ごとに、とにかく続行するかどうかをユーザーに尋ねます。
@end defun

@defopt git-commit-style-convention-checks
このオプションは、関数@code{git-commit-check-style-conventions}が強制しようとする規則を制御します。値は、特定の規則を識別する自明のシンボルのリストです。それは@code{non-empty-second-line}と@code
{overlong-summary-line}です。
@end defopt

@node Branching
@section Branching

@menu
* The Two Remotes::          The Two Remotes
* Branch Commands::          Branch Commands
* Branch Git Variables::     Branch Git Variables
* Auxiliary Branch Commands::  Auxiliary Branch Commands
@end menu

@node The Two Remotes
@subsection The Two Remotes

一部のローカルブランチのアップストリームブランチは、そのローカルブランチのコミットが最終的にマージされるブランチであり、通常は@code{origin/master}のようなものです。@code{master}ブランチ自体の場合、アップストリームブランチとそれがプッシュされるブランチは、通常、同じリモートブランチです。ただし、機能(feature)ブランチの場合、アップストリームブランチとプッシュ先のブランチは異なる必要があります。

機能(feature)ブランチでのコミットも、@emph{最終的に}@code{origin/master}や@code{origin/maint}などのリモートブランチで終了する必要があります。したがって、このようなブランチはアップストリームとして使用する必要があります。
ただし、機能ブランチをそのようなブランチに直接プッシュしないでください。代わりに、機能ブランチ@code{my-feature}は通常@code{my-fork/my-feature}にプッシュされるか、寄稿者(contributor)の場合は@code{origin/my-feature}にプッシュされます。
新しい機能がレビューされた後、メンテナはその機能を@code{master}にマージします。そして最後に、@code{master}(@code{my-feature}自体ではない)が@code{origin/master}にプッシュされます。

ただし、新しい機能が最初の試行で完全になることはめったにないため、通常、機能(feature)ブランチを何度も確認、改善、および再プッシュする必要があります。したがって、プッシュは簡単に実行できるべきです。そういう理由から、多くのGitユーザーは、ローカル機能ブランチがプッシュされているリモートブランチをアップストリームとして使用するのが最善であると結論付けています。

しかし幸運なことに、Gitは、変数@code{branch.<name>.pushRemote}と@code{remote.pushDefault}を使用して、アップストリームブランチとは別に構成できるプッシュリモートのサポートをずっと前に手に入れています。だから私達は、2つのリモートのどちらを「リモート」として使用するかを選択する必要がなくなりました。

トランジェントコマンドのフェッチ、プル、およびプッシュのそれぞれは、現在のブランチと他のいくつかのブランチに作用する3つのサフィックスコマンドがあります。これらのうち、@code{p}はプッシュリモートで動作するコマンドに結び付けられ、@code{u}はアップストリームで動作するコマンドに結び付けられ、@code{e}は任意の他のブランチで動作するコマンドに結び付けられます。ステータスバッファには、プッシュリモートとアップストリームの両方の、プッシュされていないコミットとプルされていないコミットが表示されます。

これら2つのリモートを構成するのはかなり簡単です。フェッチ、プル、プッシュに関連するすべての変数(およびその他のブランチ関連の変数)の値は、コマンド@code{magit-branch-configure}を使用して検査および変更できます。これは、ブランチを処理する多くのトランジェントプレフィックスコマンドから利用できます。プッシュ中にプッシュリモートまたはアップストリームを設定することもできます(@ref{Pushing})。

@node Branch Commands
@subsection Branch Commands

トランジェントプレフィックスコマンド@code{magit-branch}は、ブランチの作成とチェックアウト、および既存のブランチへの変更に使用されます。ブランチのフェッチまたはプルまたはマージまたはリベースまたはプッシュには使用されません。つまり、このコマンドはブランチ自体を処理し、ブランチから到達可能なコミットは処理しません。これらの機能は、個別のトランジェントコマンドから利用できます。

@table @asis
@item @kbd{b} (@code{magit-branch})
@kindex b
@findex magit-branch
このトランジェント(一時的)プレフィックス(接頭辞)コマンドは、それに従うサフィックス(接尾辞)コマンド群を結びつけ、そのサフィックスコマンドのどれかを選ぶまでの間、サフィックス(接尾辞)コマンド群を一時バッファ(temporary
buffer)に表示します。

デフォルトでは、ブランチ関連のGit変数の値を結び付けて表示し、それらの値を変更することもできます。
@end table

@defopt magit-branch-direct-configure
このオプションは、トランジェントコマンド@code{magit-branch}を使用してGit変数の値を直接変更できるかどうかを制御します。これはデフォルトで@code{t}になります(キーバインディングの変更を避けるため)。@code{nil}に設定すると、そのトランジェントコマンドによって変数は表示されず、代わりにそのサフィックスコマンド@code{magit-branch-configure}を使用して、ブランチ関連の変数を表示および変更する必要があります。
@end defopt

@table @asis
@item @kbd{b C} (@code{magit-branch-configure})
@itemx @kbd{f C}
@itemx @kbd{F C}
@itemx @kbd{P C}
@kindex b C
@kindex f C
@kindex F C
@kindex P C
@findex magit-branch-configure
このトランジェント(一時的)プレフィックス(接頭辞)コマンドは、ブランチ関連変数の値を設定するコマンドを結び付け、トランジェントコマンドが終了するまでそれらブランチ関連変数の値を設定するコマンドを一時バッファ(temporary
buffer)に表示します。

プレフィックス引数を使用すると、このコマンドは常にブランチの入力を求めます。

プレフィックス引数がない場合、これは@code{magit-branch}のサフィックスコマンドとして呼び出されたかどうかと@code{magit-branch-direct-configure}オプションに依存します。@code{magit-branch}がすでに現在のブランチの変数を表示している場合、同じブランチの変数を表示する別のトランジェントコマンドを呼び出すことは役に立ちません。その場合、このコマンドはブランチの入力を求めます。
@end table

変数の説明についてはこちらを参照して下さい(@ref{Branch Git Variables})

@table @asis
@item @kbd{b b} (@code{magit-checkout})
@kindex b b
@findex magit-checkout
ミニバッファで読み取られたリビジョンをチェックアウトし、デフォルトでブランチまたは任意のリビジョンに設定します。リビジョンがローカルブランチの場合、それが現在のブランチになります。それが別のものである場合、@code{HEAD}はdetachされます。作業ツリーまたはステージ領域に変更が含まれている場合、チェックアウトは失敗します。

@item @kbd{b n} (@code{magit-branch-create})
@kindex b n
@findex magit-branch-create
新しいブランチを作成します。ユーザーは、新しいブランチの開始点として使用するブランチまたは任意のリビジョンの入力を求められます。ブランチ名が指定されると、それが新しいブランチのアップストリームブランチになります。新しいブランチの名前もミニバッファから読み込まれます。

オプション@code{magit-branch-prefer-remote-upstream}も参照してください。

@item @kbd{b c} (@code{magit-branch-and-checkout})
@kindex b c
@findex magit-branch-and-checkout
このコマンドは、@code{magit-branch-create}のような新しいブランチを作成しますが、それをチェックアウトします。

オプション@code{magit-branch-prefer-remote-upstream}も参照してください。

@item @kbd{b l} (@code{magit-branch-checkout})
@kindex b l
@findex magit-branch-checkout
このコマンドは、既存または新規のローカルブランチをチェックアウトします。すべてのローカルブランチとリモートブランチのサブセットを候補として提供して、ユーザーからブランチ名を読み取ります。同じ名前のローカルブランチが存在するリモートブランチは、候補のリストから除外されます。
ユーザーは、まったく新しいブランチ名を入力することもできます。

@itemize
@item
ユーザーが既存のローカルブランチを選択すると、それがチェックアウトされます。

@item
ユーザーがリモートブランチを選択すると、同じ名前の新しいローカルブランチが作成およびチェックアウトされ、選択されたリモートブランチがプッシュターゲットとして構成されます。

@item
ユーザーが新しいブランチ名を入力すると、ユーザーから開始点(starting-point)も読み取った後、ブランチ名が作成されてチェックアウトされます。
@end itemize

後者の2つのケースでは、アップストリームも設定されます。選択した開始点に設定するか、他の何かに設定するかは、@code{magit-branch-adjust-remote-upstream-alist}の値によって異なります。

@item @kbd{b s} (@code{magit-branch-spinoff})
@kindex b s
@findex magit-branch-spinoff
このコマンドは、現在のブランチから開始して追跡する新しいブランチを作成してチェックアウトします。そのブランチは、アップストリームと共有する最後のコミットにリセットされます。現在のブランチにアップストリームまたはプッシュされていないコミットがない場合は、とにかく新しいブランチが作成され、以前の現在のブランチは変更されません。

これは、古いブランチで作業がすでに開始された後に機能(feature)ブランチを作成するのに役立ちます（おそらく「master」である必要はありません）。

現在のブランチがオプション@code{magit-branch-prefer-remote-upstream}の値のメンバーである場合、現在のブランチは通常どおり開始点(starting
point)として使用されますが、starting-pointそれ自身の代わりに、starting-pointを新しいブランチのアップストリームとして使用できます。

オプションのFROMがnil以外の場合、ソースブランチは、アップストリームと共有する最後のコミットではなく、@code{FROM~}にリセットされます。対話的なFROMは、リージョンがいくつかのコミットを選択した場合にのみnil以外になり、それらのコミットの中で、FROMはソースブランチの前にあるコミットの数が最も少ないコミットです。

選択範囲のもう一方の端でのコミットは実際には重要ではありません。FROMと@code{HEAD}の間のすべてのコミットは新しいブランチに移動されます
FROMが@code{HEAD}から到達できない場合、またはソースブランチのアップストリームから到達可能である場合、エラーが発生します。

@item @kbd{b S} (@code{magit-branch-spinout})
@kindex b S
@findex magit-branch-spinout
このコマンドは、現在のブランチを変更しないことを除いて、@code{magit-branch-spinoff}のように動作します。コミットされていない変更がある場合は、@code{magit-branch-spinoff}とまったく同じように動作します。

@item @kbd{b x} (@code{magit-branch-reset})
@kindex b x
@findex magit-branch-reset
このコマンドは、ブランチをリセットします。デフォルトでは、ポイントのブランチ、別のブランチの先端、またはその他のコミットにリセットされます。

リセットされるブランチが現在のブランチである場合、ハードリセットが実行されます。コミットされていない変更がある場合、それらの変更は失われるため、ユーザーはリセットを確認する必要があります。

これは、機能(feature)ブランチでの作業を開始したが、それがすべてがらくたであり、最初からやり直したい場合に役立ちます。

別のブランチにリセットし、プレフィックス引数を使用すると、ターゲットブランチは、リセットされるブランチのアップストリームとして設定されます。

@item @kbd{b k} (@code{magit-branch-delete})
@kindex b k
@findex magit-branch-delete
1つまたは複数のブランチを削除します。リージョンが複数のブランチをマークしている場合は、それらを削除することを提案します。それ以外の場合は、削除する単一のブランチの入力を求めます。デフォルトでは、そのポイントでのブランチになります。

@item @kbd{b m} (@code{magit-branch-rename})
@kindex b m
@findex magit-branch-rename
ブランチの名前を変更します。ブランチと新しい名前がミニバッファで読み取られます。プレフィックス引数を使用すると、その名前が既存のブランチと競合する場合でも、ブランチの名前が変更されます。
@end table

@defopt magit-branch-read-upstream-first
ブランチを作成するときに、作成するブランチの名前の前にアップストリームブランチをユーザーから読み取るかどうか。デフォルトは@code{t}で、そのままにしておくことをお勧めします。
@end defopt

@defopt magit-branch-prefer-remote-upstream
このオプションは、新しいブランチを作成するときに、リモートアップストリームをローカルアップストリームよりも優先するかどうかを指定します。

新しいブランチが作成されると、そのポイントでのブランチ、コミット、またはスタッシュが新しいブランチの開始点として提案されます。そのようなリビジョンがポイントにない場合は、現在のブランチが提案されます。
いずれの場合も、ユーザーは別の開始点を選択できます。

選択した開始点がブランチの場合、Git変数`branch.autoSetupMerge'の値に応じて、新しいブランチのアップストリームとして設定することもできます。デフォルトでは、これはリモートブランチに対して実行され、ローカルブランチに対しては実行されません。

常にアップストリームとしてリモートブランチを使用することをお勧めします。選択した開始点が
(1)ローカルブランチ、(2)名前がこのオプションの値のメンバーと一致する場合、(3)そのローカルブランチの上流が同じ名前のリモートブランチである場合、(4)そのリモートブランチをローカルブランチにfast-forwardedk可能、であるならば選択したブランチが開始点として使用され、それ自体のアップストリームが新しいブランチのアップストリームとして使用されます。

このオプションの値のメンバーは、ブランチ名として無効にする文字が含まれていない限り、完全に一致する必要があるブランチ名として扱われます。正規表現としての解釈をトリガーするために使用する推奨文字は、"*"と"^"です。
無効であると予想される他のいくつかの文字は、実際にはそうではありません。".+$"はすべて完全に有効です。 より正確には、@code{git
check-ref-format --branch STRING}がゼロ以外のステータスで終了する場合、STRINGを正規表現として扱います。

選択したブランチがこれらの条件に一致すると仮定すると、以下のようになります:

@example
feature --upstream--> origin/master
@end example

は以下の代わりです

@example
feature --upstream--> master --upstream--> origin/master
@end example

あなたがどちらを好むかは個人的な好みの問題です。前者を使用する場合は、@code{master}、@code{next}、@code{maint}などのブランチをこのオプションの値に追加する必要があります。
@end defopt

@defopt magit-branch-adjust-remote-upstream-alist
このオプションの値は、リモートブランチを分岐するときにアップストリームとして使用されるブランチのalistです。

リモートにあるつかの間のブランチ(ephemeral
branch)からローカルブランチを作成する場合。機能(feature)ブランチまたはホットフィックスブランチの場合、プッシュリモートはすでにアクセスを許可しており、アップストリームとプッシュリモートの両方が同じ関連ブランチを参照するのは無駄になるため、通常、そのリモートブランチをアップストリームブランチとして使用しないでください。代わりに、"maint"や"master"などのブランチをアップストリームとして使用する必要があります。

このオプションを使用すると、特定のリモートブランチを分岐するときにアップストリームとして使用する必要があるブランチを指定できます。
値は、@code{((UPSTREAM . RULE)...)}の形式のalistです。最初に一致する要素が使用され、その後の要素は無視されます。

UPSTREAMは、RULEで指定されたブランチのアップストリームとして使用されるブランチです。ローカルブランチでもリモートブランチでもかまいません。

RULEは正規表現のいずれかであり、そのアップストリームがUPSTREAMで指定されるべきであるブランチに一致します。または、UPSTREAMを使用してはならない単一のブランチのリストにすることもできます。他ブランチは全てそうします。マッチングは、分岐元のブランチ名のリモート部分を削除した後に行われます。

あなたのすべてのリポジトリで永続的なブランチの限定セットを使用する場合、あなたは以下のようなものを使用できます:

@lisp
(("origin/master" . ("master" "next" "maint")))
@end lisp

または、少なくとも一部のリポジトリで、あなたのすべてのつかの間の(ephemeral)ブランチの名前にスラッシュが含まれている場合、適切な値は以下のようになります:

@lisp
(("origin/master" . "/"))
@end lisp

もちろん、あなたは微調整することもできます:

@lisp
(("origin/maint" . "\\`hotfix/")
 ("origin/master" . "\\`feature/"))
@end lisp

UPSTREAMはローカルブランチにすることができます:

@lisp
(("master" . ("master" "next" "maint")))
@end lisp
@end defopt

メインブランチはほとんどの場合「master」という名前ではなくなったため、他の一般的な名前も考慮する必要があります:

@lisp
(("main"  . ("main" "master" "next" "maint"))
 ("master" . ("main" "master" "next" "maint")))
@end lisp

@deffn Command magit-branch-orphan
このコマンドは、指定されたリビジョンのコンテンツを含む新しい孤立したブランチを作成してチェックアウトします。
@end deffn

@deffn Command magit-branch-or-checkout
このコマンドは、@code{magit-checkout}と@code{magit-branch-and-checkout}のハイブリッドであり、@code{magit-branch}で、@code{magit-checkout}の代わりとして使用することを目的としています。

最初に、既存のブランチまたはリビジョンをユーザーに要求します。ユーザー入力が実際にブランチまたはリビジョンとして解決できる場合は、@code{magit-checkout}と同じように、それをチェックアウトします。

それ以外の場合は、入力を名前として使用して新しいブランチを作成してチェックアウトします。そうする前に、新しいブランチの開始点を読み取ります。これは、@code{magit-branch-and-checkout}が行うことと似ています。

@code{magit-checkout}の代わりにこのコマンドを使用するには、以下をあなたのinitファイルに追加します:

@lisp
(transient-replace-suffix 'magit-branch 'magit-checkout
  '("b" "dwim" magit-branch-or-checkout))
@end lisp
@end deffn

@node Branch Git Variables
@subsection Branch Git Variables

これらの変数は、トランジェントプレフィックスコマンド@code{magit-branch-configure}から設定できます。デフォルトでは、@code{magit-branch}から設定することもできます。こちらを参照して下さい(@ref{Branch
Commands})

@defvar branch.NAME.merge
この変数は、@code{branch.NAME.remote}とともに、NAMEという名前のローカルブランチのアップストリームブランチを定義します。
この変数の値は、アップストリーム「ブランチ」の完全なreferenceです。
@end defvar

@defvar branch.NAME.remote
この変数は、@code{branch.NAME.merge}とともに、NAMEという名前のローカルブランチのアップストリームブランチを定義します。
この変数の値は、アップストリーム「リモート」の名前です。
@end defvar

@defvar branch.NAME.rebase
この変数は、NAMEという名前のブランチへのプルが、リベースによって行われるか、フェッチされたブランチをマージすることによって行われるかを制御します。

@itemize
@item
@code{true}の場合、プルはリベースによって行われます。
@item
@code{false}の場合、プルはマージによって行われます。
@item
未定義の場合、@code{pull.rebase}の値が使用されます。その変数のデフォルトは@code{false}です。
@end itemize
@end defvar

@defvar branch.NAME.pushRemote
この変数は、NAMEという名前のブランチが通常プッシュされるリモートを指定します。値は、既存のリモートの名前である必要があります。

ローカルブランチをプッシュする「ブランチ」の名前を指定することはできません。リモートブランチの名前は、常にローカルブランチの名前と同じです。

この変数が未定義であるが、@code{remote.pushDefault}が定義されている場合は、後者の値が使用されます。デフォルトでは、@code{remote.pushDefault}は未定義です。
@end defvar

@defvar branch.NAME.description
この変数は、NAMEという名前のブランチを説明するために使用できます。例えばブランチを一連のパッチに変えるとき、その説明が使用されます。
@end defvar

以下の変数は、上記のブランチ固有の変数が設定されていない場合に使用されるデフォルトを指定します。

@defvar pull.rebase
この変数は、プルがリベースによって行われるか、マージによって行われるかを指定します。@code{branch.NAME.rebase}を使用して上書きできます。

@itemize
@item
@code{true}の場合、プルはリベースによって行われます。
@item
@code{false}(デフォルト)の場合、プルはマージによって行われます。
@end itemize

アップストリームブランチを、機能(feature)ブランチまたはホットフィックスブランチ(ほとんどのブランチはそのようなブランチです)にマージすることは決して良い考えではなく、この変数を@code{true}に設定し、@code{branch.master.rebase}を@code{false}に設定することを検討する必要があります。
@end defvar

@defvar remote.pushDefault
この変数は、ローカルブランチが通常プッシュされるリモートを指定します。これは、@code{branch.NAME.pushRemote}を使用してブランチごとに上書きできます。
@end defvar

以下の変数はブランチの作成中に使用され、さまざまなブランチ固有の変数がこの時点で自動的に設定されるかどうかを制御します。

@defvar branch.autoSetupMerge
この変数は、ブランチNAMEを作成すると、ブランチの作成に使用された開始点に従って変数@code{branch.NAME.merge}と@code{branch.NAME.remote}が設定される状況を指定します。開始点がブランチでない場合、これらの変数は設定されません。

@itemize
@item
@code{always}の場合、開始点がローカルブランチであるかリモートブランチであるかに関係なく、変数が設定されます。
@item
@code{true}(デフォルト)の場合、開始点がリモートブランチの場合は変数が設定されますが、ローカルブランチの場合は設定されません。
@item
@code{false}の場合、変数は設定されません。
@end itemize
@end defvar

@defvar branch.autoSetupRebase
この変数は、ブランチNAMEを作成すると、変数@code{branch.NAME.rebase}が@code{true}に設定されるかどうかを指定します。

@itemize
@item
@code{always}の場合、開始点がローカルブランチであるかリモートブランチであるかに関係なく、変数が設定されます。
@item
@code{local}の場合、変数は開始点がローカルブランチの場合に設定されますが、リモートブランチの場合は設定されません。
@item
@code{remote}の場合、変数は開始点がリモートブランチの場合に設定されますが、ローカルブランチの場合は設定されません。
@item
@code{never}(デフォルト)の場合、変数は設定されません。
@end itemize
@end defvar

注意:
それぞれのコマンドは常にリポジトリローカル値を変更することに注意してください。ローカル値が定義されていないときに使用されるグローバル値を変更する場合は、コマンドラインで変更する必要があります。例:

@example
git config --global remote.autoSetupMerge always
@end example

これらの変数の詳細については、以下もご覧下さい

@ifinfo
(@ref{git-config,,,gitman,})
@end ifinfo
@ifhtml
@c html
@c end html
the <a href="http://git-scm.com/docs/git-config">git-config(1)</a> manpage.
@end ifhtml
@iftex
the git-config(1) manpage.
@end iftex
 こちらもご覧下さい 
@ifinfo
(@ref{git-branch,,,gitman,})
@end ifinfo
@ifhtml
@c html
@c end html
the <a href="http://git-scm.com/docs/git-branch">git-branch(1)</a> manpage.
@end ifhtml
@iftex
the git-branch(1) manpage.
@end iftex
と 
@ifinfo
(@ref{git-checkout,,,gitman,})
@end ifinfo
@ifhtml
@c html
@c end html
the <a href="http://git-scm.com/docs/git-checkout">git-checkout(1)</a>
manpage.
@end ifhtml
@iftex
the git-checkout(1) manpage.
@end iftex
 と(@ref{Pushing})

@defopt magit-prefer-remote-upstream
このオプションは、ユーザーからブランチを読み取り、それをアップストリームブランチとして設定するコマンドが、選択可能な場合に、ローカルブランチまたはリモートブランチをデフォルトの完了候補として提供するかどうかを制御します。

これは、@code{magit-read-upstream-branch}または@code{magit-read-starting-point}を使用するすべてのコマンドに影響します。これには、アップストリームを変更するすべてのコマンドと、新しいブランチを作成する多くのコマンドが含まれます。
@end defopt

@node Auxiliary Branch Commands
@subsection Auxiliary Branch Commands

これらのコマンドは、デフォルトではトランジェントコマンド@code{magit-branch}からは使用できません。

@deffn Command magit-branch-shelve
このコマンドはブランチを棚上げ(shelve)します。
これは、ブランチを削除し、指定されたブランチと同じコミットを指す新しい参照"refs/shelved/BRANCH-NAME"を作成することによって行われます。
削除されたブランチにreflogがあった場合、それは新しいreferenceのreflogとして保持されます。

これは、あなたがブランチを見えなくしたいが、まだ完全に破棄する準備ができていない場合に便利です。
@end deffn

@deffn Command magit-branch-unshelve
このコマンドは、@code{magit-branch-shelve}を使用して以前に棚上げ(shelve)されたブランチの棚上げ(shelve)を解除します。これは、reference
"refs/shelved/BRANCH-NAME"を削除し、削除されたreferenceが指すのと同じコミットを指すブランチ"BRANCH-NAME"を作成することによって行われます。削除されたreferenceにreflogがあった場合、それはブランチのreflogとして復元されます。
@end deffn

@node Merging
@section Merging

こちらもご覧下さい 
@ifinfo
@ref{git-merge,,,gitman,}
@end ifinfo
@ifhtml
@c html
@c end html
the <a href="http://git-scm.com/docs/git-merge">git-merge(1)</a> manpage.
@end ifhtml
@iftex
the git-merge(1) manpage.
@end iftex
  マージの競合を解決する方法については、次節を参照してください。

@table @asis
@item @kbd{m} (@code{magit-merge})
@kindex m
@findex magit-merge
このトランジェント(一時的)なプレフィックス(接頭辞)コマンドは、それに従うサフィックス(接尾辞)コマンドを適切なインフィックス(中置)引数とともに結び付け、いずれかのサフィックスコマンドを選択するまでの間、そのインフィックス引数達とサフィックスコマンド達を一時バッファ(temporary
buffer)に表示します。
@end table

マージが進行中でない場合、トランジェントコマンドにはそれに従うサフィックスコマンドがあります。

@table @asis
@item @kbd{m m} (@code{magit-merge-plain})
@kindex m m
@findex magit-merge-plain
このコマンドは、別のブランチまたは任意のリビジョンを現在のブランチにマージします。
マージされるその別のブランチまたは任意のリビジョンはミニバッファで読み込まれ、デフォルトでポイントのブランチになります。

競合があるか、プレフィックス引数が使用されていない限り、結果のマージコミットは一般的なコミットメッセージを使用し、ユーザーはコミットが作成される前にそれを検査または変更する機会がありません。プレフィックス引数を使用すると、実際にはマージコミットが作成されないため、競合がどのように解決されたかを検査し、コミットメッセージを調整できます。

@item @kbd{m e} (@code{magit-merge-editmsg})
@kindex m e
@findex magit-merge-editmsg
このコマンドは、別のブランチまたは任意のリビジョンを現在のブランチにマージし、コミットメッセージバッファを開いて、ユーザーが調整できるようにします。コミットは、ユーザーが@code{C-c
C-c}で終了するまで実際には作成されません。

@item @kbd{m n} (@code{magit-merge-nocommit})
@kindex m n
@findex magit-merge-nocommit
このコマンドは、別のブランチまたは任意のリビジョンを現在のブランチにマージしますが、実際にはマージコミットを作成しません。その後、ユーザーは、自動競合解決が成功した場合でも、マージをさらに調整したり、コミットメッセージを調整したりできます。

@item @kbd{m a} (@code{magit-merge-absorb})
@kindex m a
@findex magit-merge-absorb
このコマンドは、別のローカルブランチを現在のブランチにマージしてから、前者を削除します。

ソースブランチがマージされる前に、それぞれのリモートブランチがすでに存在する場合、最初にプッシュリモートに強制的にプッシュされます。これにより、それぞれのプルリクエスト(存在する場合)が、マージされているコミットの廃止されたバージョンでスタックすることがなくなります。最後に、@code{magit-branch-pull-request}を使用してマージされたブランチを作成した場合、それぞれのリモートブランチも削除されます。

@item @kbd{m i} (@code{magit-merge-into})
@kindex m i
@findex magit-merge-into
このコマンドは、現在のブランチを別のローカルブランチにマージしてから、前者を削除します。後者が新しい現在のブランチになります。

ソースブランチがマージされる前に、それぞれのリモートブランチがすでに存在する場合、最初にプッシュリモートに強制的にプッシュされます。これにより、それぞれのプルリクエスト(存在する場合)が、マージされているコミットの廃止されたバージョンでスタックすることがなくなります。最後に、@code{magit-branch-pull-request}を使用してマージされたブランチを作成した場合、それぞれのリモートブランチも削除されます。

@item @kbd{m s} (@code{magit-merge-squash})
@kindex m s
@findex magit-merge-squash
このコマンドは、別のブランチまたは任意のリビジョンによって現在のブランチに導入された変更を破棄します。これは、squashコミットによって行われた変更にのみ適用されます。
実際のマージコミットの作成を可能にする情報は保持されません。このコマンドの代わりに、apply用トランジェントコマンドからのコマンドを使用する必要があります。

@item @kbd{m p} (@code{magit-merge-preview})
@kindex m p
@findex magit-merge-preview
このコマンドは、別のブランチまたは任意のリビジョンを現在のブランチにマージするプレビューを表示します。
@end table

マージが進行中の場合、トランジェントコマンドには代わりのサフィックスコマンドがあります。

@table @asis
@item @kbd{m m} (@code{magit-merge})
@kindex m m
@findex magit-merge
ユーザーが競合を解決した後、このコマンドはマージを続行します。一部の競合が解決されなかった場合、このコマンドは失敗します。

@item @kbd{m a} (@code{magit-merge-abort})
@kindex m a
@findex magit-merge-abort
このコマンドは、現在のマージ操作を中止(abort)します。
@end table

@node Resolving Conflicts
@section Resolving Conflicts

ブランチをマージする(または履歴を結合または変更する)と、競合が発生する可能性があります。
同じファイルの2つの完全に異なる部分を2つのブランチで編集してから、これらのブランチの1つを別のブランチにマージすると、Gitはそれを独自に解決できますが、ファイルの同じ領域を編集する場合は、人間が必要です。
2つのバージョン、つまり「競合の側面」を1つに組み合わせる方法を決定します。

ここでは、主題の簡単な紹介のみを提供し、役立ついくつかのツールを紹介します。これが初めての場合は、Git独自の文書やその他のリソースも参照してください。

ファイルに競合があり、Gitがそれ自体で解決できない場合は、ファイルの未解決部分の境界と異なるバージョン間の境界を示すことを目的とした特別なマーカーとともに、両方のバージョンを影響を受けるファイルに配置します。
これらの境界線は、@code{<}、@code{|}、@code{=}、@code{>}のいずれかの6個の同じ文字で構成される文字列で始まり、その後にそれぞれのバージョンのソースに関する情報が続きます。例:

@example
<<<<<<< HEAD
Take the blue pill.
=======
Take the red pill.
>>>>>>> feature
@end example

この場合、1つのブランチで赤い薬(red pill)を服用し、別のブランチで青い薬(blue pill)を選択しました。
これらの2つの分岐するブランチをマージしているので、Gitはどちらの薬を服用したいかをおそらく知ることができません。

この競合を解決するには、ファイルの影響を受ける領域のバージョンを作成する必要があります。一方の側だけを保持し、場合によってはもう一方の側から変更を取り込むために編集して、他のバージョンとマーカーを削除します。次に結果をステージします。
考えられる解決策は次のとおりです:

@example
Take both pills.
@end example

多くの場合、競合の2つの側面だけでなく、ファイルの同じ領域が異なるブランチで2回変更される前の「元の」バージョンも確認すると便利です。
このコマンドを1回実行して、そのバージョンも挿入するようにGitに指示します:

@example
git config --global merge.conflictStyle diff3
@end example

上記の競合は以下のようになっているかもしれません:

@example
<<<<<<< HEAD
Take the blue pill.
||||||| merged common ancestors
Take either the blue or the red pill, but not both.
=======
Take the red pill.
>>>>>>> feature
@end example

その場合、上記の競合解決は正しくありませんでした。これは、競合するバージョンと一緒に元のバージョンを表示することが役立つ理由を示しています。

あなたは競合の解決を手動で完全に実行できますが、Emacsには、この処理に役立ついくつかのパッケージ（Smerge、Ediff(@ref{Top,,,ediff,})、Emerge(@ref{Emerge,,,emacs,}))も用意されています。
Magitは、競合を解決するための独自のツールを提供していませんが、SmergeとEdiffの使用をより便利にします。(EdiffはEmergeに取って代わるので、あなたはEmergeを使いたくなくなる事でしょう。)

Magitステータスバッファでは、競合が解決されていないファイルが"Unstaged changes"または"Staged
changes"セクションに一覧表示されます。
これらの前には"unmerged"という単語が付いています。これは、この文脈では本質的に"unresolved"の同義語です。

ポイントがそのようなファイルセクションにあるときに@code{RET}を押すと、そのファイルを訪れているバッファが表示され、そのバッファで@code{smerge-mode}がオンになり、競合のある最初の領域内にポイントが配置されます。あなたは、通常の編集コマンドやSmergeコマンドを使用してその競合を解決する必要があります。

残念ながら、Smergeにはマニュアルがありませんが、コマンドのリストを取得して@code{C-c ^
C-h}をバインドし、ポイントがコマンド名にあるときに@code{RET}を押してドキュメントを読むことができます。

通常、1つのバージョンを編集してから、そのバージョンのみを保持するようにSmergeに指示します。@code{C-c ^
m}(@code{smerge-keep-mine})を使用して@code{HEAD}バージョンを保持するか、@code{C-c ^
o}(@code{smerge-keep-other})を使用して"|||||||"に続くバージョンを保持します。次に、@code{C-c ^
n}を使用して、同じファイル内の次の競合する領域に移動します。競合の解決が完了したら、Magitステータスバッファに戻ります。
最後の競合を解決した後にバッファを保存すると、Smergeがファイルを自動的にステージするため、ファイルは"unmerged"として表示されなくなり、"modified"として表示されます。

Magitは、前述のSmergeコマンドをラップするようになり、ファイル訪問バッファに移動することなく、これらのキーバインディングを使用できるようになりました。
さらに、競合が解決されていないハンクの@code{k}(@code{magit-discard})は、どちらの側を保持するかを尋ねます。ポイントがそのどちらかの側にある場合は、プロンプトを表示せずに保持します。同様に、未解決のファイルの@code{k}は、どちらの側を保持するかを尋ねます。

あるいは、ファイルのバージョンごとに別々のバッファを使用するEdiffを使用することもできます。
Ediffを使用してファイル内の競合を解決するには、ステータスバッファ内のそのようなファイル上にポイントがあるときに@code{e}を押します。

Ediffは他の目的にも使用できます。MagitからEdiffに入る方法の詳細についてはこちらを参照して下さい(@ref{Ediffing})。
Ediffの使用方法の説明は、このマニュアルの範囲を超えています。代わりにこちらを参照して下さい(@ref{Top,,,ediff,})。

SmergeとEdiffのどちらを使用すべきかわからない場合は、前者を使用してください。理解して使用する方がはるかに簡単であり、本当に複雑な競合を除いて、後者は通常やり過ぎです。

@node Rebasing
@section Rebasing

こちらもご覧下さい 
@ifinfo
@ref{git-rebase,,,gitman,}
@end ifinfo
@ifhtml
@c html
@c end html
the <a href="http://git-scm.com/docs/git-rebase">git-rebase(1)</a> manpage.
@end ifhtml
@iftex
the git-rebase(1) manpage.
@end iftex
  リベース中に発生する競合を解決する方法については、前節を参照してください。

@table @asis
@item @kbd{r} (@code{magit-rebase})
@kindex r
@findex magit-rebase
このトランジェント(一時的)なプレフィックス(接頭辞)コマンドは、それに従うサフィックス(接尾辞)コマンドを適切なインフィックス(中置)引数とともに結び付け、いずれかのサフィックスコマンドを選択するまでの間、そのインフィックス引数達とサフィックスコマンド達を一時バッファ(temporary
buffer)に表示します。
@end table

リベースが進行中でない場合、トランジェントコマンドにはそれ従うサフィックスコマンドがあります。

これらのコマンドの1つを使用して、リベースシーケンスを@emph{開始}します。
Gitは、あなたが途中で中断するように指示したか、競合が原因でコミットの適用が失敗したために中断する可能性があります。その場合、ステータスバッファには、ログセクションに似たセクションで、進行中のリベースシーケンスに関する情報が表示されます。こちらを参照して下さい(@ref{Information
About In-Progress Rebase})。

アップストリーム(upstream)とプッシュリモート(push-remote)の詳細についてはこちらを参照して下さい(@ref{The Two
Remotes})。

@table @asis
@item @kbd{r p} (@code{magit-rebase-onto-pushremote})
@kindex r p
@findex magit-rebase-onto-pushremote
このコマンドは、現在のブランチをプッシュリモートにリベースします。

プレフィックス引数を使用する場合、またはプッシュリモートが構成されていないか使用できない場合は、最初にユーザーにプッシュリモートを構成させます。

@item @kbd{r u} (@code{magit-rebase-onto-upstream})
@kindex r u
@findex magit-rebase-onto-upstream
このコマンドは、現在のブランチをそのアップストリームブランチにリベースします。

プレフィックス引数を使用する場合、またはアップストリームが構成されていないか使用できない場合は、ユーザーが最初にアップストリームを構成できるようにします。

@item @kbd{r e} (@code{magit-rebase-branch})
@kindex r e
@findex magit-rebase-branch
このコマンドは、現在のブランチをミニバッファでユーザーから読み取ったブランチにリベースします。ヘッドからは到達可能であるが、選択したブランチTARGETからは到達できないすべてのコミットがリベースされます。

@item @kbd{r s} (@code{magit-rebase-subset})
@kindex r s
@findex magit-rebase-subset
このコマンドは、非対話型のリベースシーケンスを開始して、コミットをSTARTからNEWBASEの@code{HEAD}に転送します。STARTは、最近のコミットのリストから選択する必要があります。
@end table

デフォルトでは、Magitは@code{--autostash}引数を使用します。これにより、コミットされていない変更はリベースが開始される前にスタッシュに格納されます。これらの変更は、リベースが完了した後に復元され、可能であればスタッシュが削除されます。スタッシュがきれいに適用されない場合、スタッシュは削除されません。これにより、競合を解決するときに何か問題が発生した場合は、あなたは最初からやり直すことができます。

アクションの1つとして、対話型リベース専用のインフィックス引数@code{--interactive}があります。これを使用して、非対話型リベースバリエーションを対話型リベースに変えることができます。

たとえば、機能(feature)ブランチをクリーンアップすると同時に、それを@code{master}にリベースする場合は、@code{r-iu}を使用できますが、代わりに2つのステップで行うことをお勧めします。最初に@code{ri}を使用して機能ブランチをクリーンアップし、次に@code{ru}を使用して@code{master}にリベースします。そうすれば、物事が思ったよりも複雑であることが判明した場合、および/または間違いを犯して最初からやり直さなければならない場合は、作業の半分をやり直すだけで済みます。

@code{--interactive}を明示的に有効にしたあと、それに続く以下のトランジェントコマンド内では@code{--interactive}が有効でない場合でも、常にその引数を使用するため、影響はありません。

@table @asis
@item @kbd{r i} (@code{magit-rebase-interactive})
@kindex r i
@findex magit-rebase-interactive
このコマンドは、対話的なリベースシーケンスを開始します。

@item @kbd{r f} (@code{magit-rebase-autosquash})
@kindex r f
@findex magit-rebase-autosquash
このコマンドは、スカッシュコミットとフィックスアップコミットを、意図したターゲットと組み合わせます。

@item @kbd{r m} (@code{magit-rebase-edit-commit})
@kindex r m
@findex magit-rebase-edit-commit
このコマンドは、ユーザーが1つの古いコミットを編集できるようにする対話的なリベースシーケンスを開始します。

@item @kbd{r w} (@code{magit-rebase-reword-commit})
@kindex r w
@findex magit-rebase-reword-commit
このコマンドは、ユーザーが1つの古いコミットをrewordする対話的なリベースシーケンスを開始します。

@item @kbd{r k} (@code{magit-rebase-remove-commit})
@kindex r k
@findex magit-rebase-remove-commit
このコマンドは、リベースを使用して1つの古いコミットを削除します。
@end table

リベースが進行中の場合、トランジェントコマンドには代わりのサフィックスコマンドがあります。

@table @asis
@item @kbd{r r} (@code{magit-rebase-continue})
@kindex r r
@findex magit-rebase-continue
このコマンドは、現在のリベース操作を再開します。

場合によっては、これにより、編集を行うためのコミットメッセージバッファがポップアップ表示されます。プレフィックス引数を使用すると、古いメッセージはそのまま再利用されます。

@item @kbd{r s} (@code{magit-rebase-skip})
@kindex r s
@findex magit-rebase-skip
このコマンドは、現在のコミットをスキップし、現在のリベース操作を再開します。

@item @kbd{r e} (@code{magit-rebase-edit})
@kindex r e
@findex magit-rebase-edit
このコマンドを使用すると、ユーザーは現在のリベース操作のToDoリストを編集できます。

@item @kbd{r a} (@code{magit-rebase-abort})
@kindex r a
@findex magit-rebase-abort
このコマンドは、現在のリベース操作を中止し、元のブランチを復元します。
@end table

@menu
* Editing Rebase Sequences::  Editing Rebase Sequences
* Information About In-Progress Rebase::  Information About In-Progress 
                                            Rebase
@end menu

@node Editing Rebase Sequences
@subsection Editing Rebase Sequences

@table @asis
@item @kbd{C-c C-c} (@code{with-editor-finish})
@kindex C-c C-c
@findex with-editor-finish
終了コード0で戻ることにより、現在の編集セッションを終了します。Gitは、ファイル内で検出したリベース命令(rebase
instructions)を使用します。

@item @kbd{C-c C-k} (@code{with-editor-cancel})
@kindex C-c C-k
@findex with-editor-cancel
終了コード1で戻ることにより、現在の編集セッションをキャンセルします。その後、Gitはリベースシーケンスの開始を中止します。

@item @kbd{@key{RET}} (@code{git-rebase-show-commit})
@kindex RET
@findex git-rebase-show-commit
別のバッファの現在の行にコミットを表示し、そのバッファを選択します。

@item @kbd{@key{SPC}} (@code{git-rebase-show-or-scroll-up})
@kindex SPC
@findex git-rebase-show-or-scroll-up
別のバッファを選択せずに、現在の行のコミットを別のバッファに表示します。
リビジョンバッファが現在のフレームの別のウィンドウにすでに表示されている場合は、代わりにそのウィンドウを上にスクロールします。

@item @kbd{@key{DEL}} (@code{git-rebase-show-or-scroll-down})
@kindex DEL
@findex git-rebase-show-or-scroll-down
別のバッファを選択せずに、現在の行のコミットを別のバッファに表示します。
リビジョンバッファが現在のフレームの別のウィンドウにすでに表示されている場合は、代わりにそのウィンドウを下にスクロールします。

@item @kbd{p} (@code{git-rebase-backward-line})
@kindex p
@findex git-rebase-backward-line
前の行に移動します。

@item @kbd{n} (@code{forward-line})
@kindex n
@findex forward-line
次の行に移動します。

@item @kbd{M-p} (@code{git-rebase-move-line-up})
@kindex M-p
@findex git-rebase-move-line-up
現在のコミット(またはコマンド)を上に移動します。

@item @kbd{M-n} (@code{git-rebase-move-line-down})
@kindex M-n
@findex git-rebase-move-line-down
現在のコミット(またはコマンド)を下に移動します。

@item @kbd{r} (@code{git-rebase-reword})
@kindex r
@findex git-rebase-reword
現在行のコミットのメッセージを編集します。

@item @kbd{e} (@code{git-rebase-edit})
@kindex e
@findex git-rebase-edit
現在の行のコミットで中断します。

@item @kbd{s} (@code{git-rebase-squash})
@kindex s
@findex git-rebase-squash
現在行のコミットを前行のコミットにマージし、メッセージを編集します。

@item @kbd{f} (@code{git-rebase-fixup})
@kindex f
@findex git-rebase-fixup
現在行のコミットを前行コミットにマージし、現在のコミットのメッセージを破棄します。

@item @kbd{k} (@code{git-rebase-kill-line})
@kindex k
@findex git-rebase-kill-line
現在の実行行(action line)を強制終了します。

@item @kbd{c} (@code{git-rebase-pick})
@kindex c
@findex git-rebase-pick
現在行でcommitを使用します。

@item @kbd{x} (@code{git-rebase-exec})
@kindex x
@findex git-rebase-exec
進行中のコミットの後に実行されるシェルコマンドを挿入します。

現在の行にそのようなコマンドがすでにある場合は、代わりにそれを編集します。プレフィックス引数を使用すると、現在の行にすでにコマンドがある場合でも、新しいコマンドを挿入します。入力が空の場合、現在の行のコマンドを削除します(存在する場合)。

@item @kbd{b} (@code{git-rebase-break})
@kindex b
@findex git-rebase-break
現在行の前にブレークアクション(break action)を挿入し、Gitに、制御をユーザーに戻すように指示します。

@item @kbd{y} (@code{git-rebase-insert})
@kindex y
@findex git-rebase-insert
任意のコミットを読み取り、現在行の下に挿入します。

@item @kbd{C-x u} (@code{git-rebase-undo})
@kindex C-x u
@findex git-rebase-undo
直近の幾つかの変更を元に戻します。@code{undo}と同様ですが、読み取り専用バッファで機能します。
@end table

@defopt git-rebase-auto-advance
行を変更した後、次の行に移動するかどうか。
@end defopt

@defopt git-rebase-show-instructions
リベースバッファ内に使用説明を表示するかどうか。
@end defopt

@defopt git-rebase-confirm-cancel
キャンセルするために確認が必要かどうか。
@end defopt

@code{--rebase-merges}オプションを使用してリベースを実行すると、シーケンスには他のいくつかのタイプのアクションが含まれ、以下のコマンドが関連するようになります。

@table @asis
@item @kbd{l} (@code{git-rebase-label})
@kindex l
@findex git-rebase-label
このコマンドは、ラベルアクションを挿入するか、ポイントのアクションを編集します。

@item @kbd{t} (@code{git-rebase-reset})
@kindex t
@findex git-rebase-reset
このコマンドは、リセットアクションを挿入するか、その時点でアクションを編集します。プロンプトは、現在バッファに存在するラベルを提供します。

@item @kbd{MM} (@code{git-rebase-merge})
@kindex MM
@findex git-rebase-merge
このコマンドは、マージアクションを挿入するか、その時点でのアクションを編集します。プロンプトでは、現在バッファに存在するラベルを提供します。@code{-c}または@code{-C}を介して再利用するメッセージを指定することはサポートされていません。マージのために常にエディタが呼び出されます。

@item @kbd{Mt} (@code{git-rebase-merge-toggle-editmsg})
@kindex Mt
@findex git-rebase-merge-toggle-editmsg
このコマンドは、ポイントでのマージアクションの@code{-C}オプションと@code{-c}オプションを切り替えます。これらのオプションは両方とも、メッセージを再利用する必要があるコミットを指定します。小文字のバリエーションは、マージの作成時にエディタを呼び出すようにGitに指示し、ユーザーがメッセージを編集できるようにします。
@end table

@node Information About In-Progress Rebase
@subsection Information About In-Progress Rebase

リベースシーケンスの進行中、ステータスバッファには、すでに適用されているコミットと、まだ適用する必要のあるコミットを一覧表示するセクションがあります。

コミットは2つに等分されます。ユーザーが競合に対処する必要があるため、またはリベースがそのコミットで中断するように明示的に要求したために、リベースがコミットで中断すると、ポイントは2つのグループを分離するコミットに置かれます。つまり@code{HEAD}です。その上のコミットはまだ適用されていませんが、@code{HEAD}とその下のコミットにはすでに適用されています。適用されたコミットとまだ適用されていないコミットのこれら2つのグループの間に、ドロップされたコミットがある場合があります。

各コミットには単語が前に付けられ、これらの単語はコミットのステータスを示すために異なる色で追加で表示されます。

以下の色が使用されます:

@itemize
@item
@code{default} フェイスと同じ前景色を使用するコミットはまだ適用されていません。

@item
黄色のコミットは、停止(stop)したコミットリベースと特別な関係があります。
これは、「join」や「goal」や「same」や「work」という言葉に使用されます (以下を参照)。

@item
灰色のコミットはすでに適用されています。

@item
青色のコミットは@code{HEAD}コミットです。

@item
緑色のコミットは、リベースシーケンスが中断しているコミットです。これが@code{HEAD}と同じコミットである場合は、たとえば、コミットでリベースが中断した後、まだ何もしていないなら、このコミットは緑色ではなく青色で表示されています。リベースがコミットで中断した後に1つ以上の新しいコミットを作成した場合、同時に存在できるのは@strong{緑色と青色のコミットのみ}です。

@item
赤色のコミットは削除されました。それらは参照用(reference)にのみ示されています。diffを取りやすくします。
@end itemize

もちろん、これらの色は使用中のカラーテーマの影響を受けます。

以下の単語が使用されます:

@itemize
@item
接頭辞が@code{pick}・@code{reword}・@code{edit}・@code{squash}・@code{fixup}であるコミットはまだ適用されていません。これらの単語は、リベースシーケンスの編集に使用されるバッファと同じ意味を持ちます。(@ref{Editing
Rebase Sequences})
@code{--rebase-merges}オプションが指定された場合、@code{reset}・@code{label}・@code{merge}行も存在する可能性があります。

@item
接頭辞が@code{done}・@code{onto}であるコミットはすでに適用されています。そのようなコミットは@code{HEAD}である可能性があり、@code{HEAD}の場合は青色になります。それ以外の場合は灰色です。

@itemize
@item
接頭辞が@code{onto}のコミットは、再適用された他のすべてのコミットの先頭であるコミットです。このコミット自体を再適用する必要はありませんでした。他のコミットの再適用を開始する前に、リベースが巻き戻されたコミットです。

@item
接頭辞が@code{done}のコミットはすでに再適用されています。これには、再適用されたコミットだけでなく、リベース中に作成した新しいコミットも含まれます。
@end itemize

@item
上記の単語のいずれの接頭辞も付いていない他のすべてのコミットは、リベースが中断したコミットに何らかの形で関連しています。

コミットが中断中のコミット(stopped-at
commit)に関連しているかどうかを判断するために、ハッシュ達、ツリー達、およびパッチID達(patch-id)
@footnote{patch-idは、コミットによって導入された@emph{変更}のハッシュです。
これは、コミット自体のハッシュとは異なります。これは、その変更を適用した結果のハッシュ(つまり、結果のツリーとblob)、作成者とコミッターの情報、コミットメッセージ、およびコミットの親のハッシュです。一方、パッチIDハッシュは、追加および削除された行からのみ作成されます。このハッシュを計算するときは、行番号や空白の変更も無視されます。2つのコミットのパッチIDを使用して、「これらのコミットは同じ変更を行いますか？」という質問に答えることができます。
} が比較されています。コミットメッセージはこの目的には使用されません。

一般的に、中断中のコミット(stopped-at
commit)に関連するコミットは、使用されている色のいずれかを持つことができますが、すべての色/単語の組み合わせが可能であるとは限りません。

中断中のコミット(stopped-at commit)に使用される単語は以下のとおりです:

@itemize
@item
接頭辞が@code{void}の場合、それは、そのコミットのすべての変更がいくつかの新しいコミットを使用して適用されたことをMagitが確実に認識していることを示します。このコミットは@code{HEAD}から到達できなくなり、セッションを再開するときに適用されるコミットの1つでもありません。

@item
接頭辞が@code{join}の場合、競合が原因でリベースシーケンスがそのコミットで中断したことを示しています。ここで、変更を既に適用されているものと結合（マージ）する必要があります。
ある意味で、これはで中断したコミットリベースで、その効果はすでにインデックスとワークツリー（競合マーカー付き）にありますが、コミット自体はまだ実際には適用されていません(@code{HEAD}ではありません)。したがって、まだ適用する必要がある他のコミットと同様に、黄色で表示されます。

@item
接頭辞が@code{stop}または、@emph{青色}または@emph{緑色}の@code{same}の場合、それは、リベースがこのコミットで中断したこと、まだ適用されているか、再度適用されたことを示します。そして少なくともそのパッチIDは変更されていません。

@itemize
@item
接頭辞が@code{stop}のコミットの場合、それは、以前に要求したためにリベースがそのコミットで中断したことを示し、そのパッチIDは変更されていません。それでもまったく同じコミットである可能性があります。

@item
接頭辞が@emph{青色}または@emph{緑色}の@code{same}の場合、それは、ツリーまたはハッシュが変更されたが、パッチIDが変更されなかったことを示します。青色の場合は、@code{HEAD}コミットです(青色の場合は常にそうです)。緑色の場合、それ以降（ただし、リベースを続行する前に）他のコミットが作成されているため、@code{HEAD}ではなくなります。
@end itemize

@item
接頭辞が@code{goal}または@emph{黄色}の@code{same}または@code{work}の場合、リベースがそのコミットを適用したが、@code{HEAD}にリセットしたことを示します。
以前のコミット(複数のコミットに分割される可能性が高い)、そしてそのコミットに起因する可能性が高い(必ずしもそうではない)コミットされていない変更が残っています。

@itemize
@item
接頭辞@code{goal}の場合、ファイルを手動で編集したり、インデックスをコミットしたり、ステージしたりすることなく、まったく同じツリー(つまり目標(the
"goal"))で新しいコミットを作成できることを示しています。すべての変更とそれをコミットします。これは、元のツリーが汚染されていない形式でインデックスまたはワークツリーにまだ存在する場合です。

@item
接頭辞が黄色の@code{same}のコミットの場合、まったく同じツリーでコミットを作成することはできなくなっていますが、同じパッチIDでコミットを作成することは可能です。これは、他の変更を加えて新しいコミットを作成したが、元のコミットからの変更が汚染されていない形式でインデックスまたは作業ツリーにまだ存在している場合に当てはまります。

@item
接頭辞が@code{work}の場合、@code{HEAD}を以前のコミットにリセットし、そのコミットに起因するステージされていない変更(unstaged
changes)および/またはステージされた変更(staged
changes)(可能性が高いが、必ずしもそうではない)があることを示します。ただし、すでに他の変更を行っているため、同じツリーまたは少なくとも同じパッチIDで新しいコミットを作成することはできなくなりました。
@end itemize

@item
接頭辞が@code{poof}または@code{gone}の場合、それは、リベースがそのコミットを適用したが、@code{HEAD}を以前のコミットにリセットしたことを示します(複数のコミットに分割する可能性があります)、そしてコミットされていない変更はありません。

@itemize
@item
接頭辞が@code{poof}の場合、それは@code{HEAD}から到達できなくなったことを示しますが、1つ以上のコミットに置き換えられ、まったく同じ効果があります。

@item
接頭辞が@code{gone}の場合、それは@code{HEAD}から到達できなくなったこと、およびその変更が1つ以上の新しいコミットでまだ有効であるかどうかを判断できないことを示します。そうかもしれませんが、もしそうなら、確実に知ることを不可能にする他の変更もあるに違いありません。
@end itemize
@end itemize
@end itemize

あなたが今、上記を完全に理解できなくても心配しないでください。大丈夫、あなたは練習を通して十分な理解を得ることが出来るようになります。

チェリーピッキングなどの他のシーケンス操作についても、同様のセクションが表示されますが、それらの実装に使用されるgitコマンドの制限により、上記の機能の一部が欠けています。最も重要なことは、これらのシーケンスはコミットの"picking"のみをサポートし、"rewording"などの他のアクションはサポートせず、すでに適用されているコミットを追跡しません。

@node Cherry Picking
@section Cherry Picking

こちらもご覧下さい 
@ifinfo
@ref{git-cherry-pick,,,gitman,}
@end ifinfo
@ifhtml
@c html
@c end html
the <a href="http://git-scm.com/docs/git-cherry-pick">git-cherry-pick(1)</a>
manpage.
@end ifhtml
@iftex
the git-cherry-pick(1) manpage.
@end iftex

@table @asis
@item @kbd{A} (@code{magit-cherry-pick})
@kindex A
@findex magit-cherry-pick
このトランジェント(一時的)なプレフィックス(接頭辞)コマンドは、それに従うサフィックス(接尾辞)コマンドを適切なインフィックス(中置)引数とともに結び付け、いずれかのサフィックスコマンドを選択するまでの間、そのインフィックス引数達とサフィックスコマンド達を一時バッファ(temporary
buffer)に表示します。
@end table

cherry-pickまたはrevertが進行中でない場合、トランジェントコマンドはそれに従うサフィックスコマンドがあります。

@table @asis
@item @kbd{A A} (@code{magit-cherry-copy})
@kindex A A
@findex magit-cherry-copy
このコマンドは、COMMITSを別のブランチから現在のブランチにコピーします。リージョンが複数のコミットを選択した場合、プロンプトなしでそれらがコピーされます。それ以外の場合、ユーザーはコミットまたは範囲の入力を求められ、デフォルトではそのポイントでのコミットになります。

@item @kbd{A a} (@code{magit-cherry-apply})
@kindex A a
@findex magit-cherry-apply
このコマンドは、COMMITSの変更を別のブランチから現在のブランチに適用します。リージョンが複数のコミットを選択した場合、プロンプトなしでそれらが使用されます。それ以外の場合、ユーザーはコミットまたは範囲の入力を求められ、デフォルトでそのポイントでのコミットになります。

このコマンドにはトップレベルのバインディングもあり、トップレベルで@code{a}と入力することにより、トランジェントコマンドを使用せずに呼び出すことができます。
@end table

以下のコマンド達は、いくつかのコミットをいくつかのブランチに適用するだけでなく、それらを他のブランチから削除します。
削除は、@code{git-update-ref}または必要に応じて@code{git-rebase}のいずれかを使用して実行されます。コミットを適用することと、@code{git-rebase}を使用してコミットを削除することの両方で、競合が発生する可能性があります。
その場合、これらのコマンドは中止(abort)され、競合を解決するだけでなく、これらのコマンドがまったく存在しなかった場合と同じ方法でプロセスを終了する必要があります。

@table @asis
@item @kbd{A h} (@code{magit-cherry-harvest})
@kindex A h
@findex magit-cherry-harvest
このコマンドは、別のブランチの選択したコミットを現在のブランチに移動し、その、別のブランチから削除します。このコマンドが成功すると、以前と同じ(same)ブランチがcurrentになります。

現在のブランチにコミットを適用したり、他のブランチからコミットを削除したりすると、競合が発生する可能性があります。その場合、このコマンドは中断し、競合を解決してから手動でプロセスを終了する必要があります。

@item @kbd{A d} (@code{magit-cherry-donate})
@kindex A d
@findex magit-cherry-donate
このコマンドは、選択したCOMMITSを現在のブランチから別の既存のブランチに移動し、その、現在のブランチから削除します。このコマンドが成功すると、以前と同じ(same)ブランチがcurrentになります。
@code{HEAD} は最初に切り離し(detach)することができます。

他のブランチにコミットを適用したり、現在のブランチからコミットを削除したりすると、競合が発生する可能性があります。その場合、このコマンドは中断し、競合を解決してから手動でプロセスを終了する必要があります。

@item @kbd{A n} (@code{magit-cherry-spinout})
@kindex A n
@findex magit-cherry-spinout
このコマンドは、選択したCOMMITSを現在のブランチから新しいブランチBRANCHに移動し、その、現在のブランチから削除します。
このコマンドが成功すると、以前と同じ(same)ブランチがcurrentになります。

他のブランチにコミットを適用したり、現在のブランチからコミットを削除したりすると、競合が発生する可能性があります。その場合、このコマンドは中断し、競合を解決してから手動でプロセスを終了する必要があります。

@item @kbd{A s} (@code{magit-cherry-spinoff})
@kindex A s
@findex magit-cherry-spinoff
このコマンドは、選択したCOMMITSを現在のブランチから新しいブランチBRANCHに移動し、その、現在のブランチから削除します。このコマンドが成功すると、新しいブランチがチェックアウトされます。

他のブランチにコミットを適用したり、現在のブランチからコミットを削除したりすると、競合が発生する可能性があります。その場合、このコマンドは中断し、競合を解決してから手動でプロセスを終了する必要があります。
@end table

cherry-pickまたはrevertが進行中の場合、トランジェントコマンドには代わりに従うサフィックスコマンドがあります。

@table @asis
@item @kbd{A A} (@code{magit-sequence-continue})
@kindex A A
@findex magit-sequence-continue
現在のcherry-pickを再開するか、シーケンスをrevertします。

@item @kbd{A s} (@code{magit-sequence-skip})
@kindex A s
@findex magit-sequence-skip
cherry-pickまたはrevertシーケンス中にコミットで中断したものをスキップします。

@item @kbd{A a} (@code{magit-sequence-abort})
@kindex A a
@findex magit-sequence-abort
現在のcherry-pickまたはrevertシーケンスを中止します。これにより、シーケンスの開始以降に行われたすべての変更が破棄されます。
@end table

@menu
* Reverting::                Reverting
@end menu

@node Reverting
@subsection Reverting

@table @asis
@item @kbd{V} (@code{magit-revert})
@kindex V
@findex magit-revert
このトランジェント(一時的)なプレフィックス(接頭辞)コマンドは、それに従うサフィックス(接尾辞)コマンドを適切なインフィックス(中置)引数とともに結び付け、いずれかのサフィックスコマンドを選択するまでの間、そのインフィックス引数達とサフィックスコマンド達を一時バッファ(temporary
buffer)に表示します。
@end table

cherry-pickまたはrevertが進行中でない場合、トランジェントコマンドはそれに従うサフィックスコマンドがあります。

@table @asis
@item @kbd{V V} (@code{magit-revert-and-commit})
@kindex V V
@findex magit-revert-and-commit
新しいコミットの作成によってコミットをrevertします。プロンプトを出してコミットの入力を求めます。デフォルトでは、そのポイントでのコミットになります。
リージョンが複数のコミットを選択した場合は、プロンプトを表示せずにすべてをrevertします。

@item @kbd{V v} (@code{magit-revert-no-commit})
@kindex V v
@findex magit-revert-no-commit
コミットを作業ツリーに逆に適用して、コミットをrevertします。
プロンプトを出してコミットの入力を求めます。デフォルトでは、そのポイントでのコミットになります。リージョンが複数のコミットを選択した場合は、プロンプトを表示せずにすべてをrevertします。
@end table

cherry-pickまたはrevertが進行中の場合、トランジェントコマンドには代わりに従うサフィックスコマンドがあります。

@table @asis
@item @kbd{V A} (@code{magit-sequence-continue})
@kindex V A
@findex magit-sequence-continue
現在のcherry-pickを再開するか、シーケンスをrevertします。

@item @kbd{V s} (@code{magit-sequence-skip})
@kindex V s
@findex magit-sequence-skip
cherry-pickまたはrevertシーケンス中にコミットで中断したものをスキップします。

@item @kbd{V a} (@code{magit-sequence-abort})
@kindex V a
@findex magit-sequence-abort
現在のcherry-pickまたはrevertシーケンスを中止します。これにより、シーケンスの開始以降に行われたすべての変更が破棄されます。
@end table

@node Resetting
@section Resetting

こちらもご覧下さい 
@ifinfo
@ref{git-reset,,,gitman,}
@end ifinfo
@ifhtml
@c html
@c end html
the <a href="http://git-scm.com/docs/git-reset">git-reset(1)</a> manpage.
@end ifhtml
@iftex
the git-reset(1) manpage.
@end iftex

@table @asis
@item @kbd{x} (@code{magit-reset-quickly})
@kindex x
@findex magit-reset-quickly
@code{HEAD}とインデックスを、ユーザーから読み取られたコミットにリセットし、デフォルトでその時点のコミットに設定します。場合によっては、作業ツリーもリセットします。プレフィックス引数を使用して作業ツリーをリセットします。それ以外の場合はリセットしません。

@item @kbd{X m} (@code{magit-reset-mixed})
@kindex X m
@findex magit-reset-mixed
@code{HEAD}をリセットし、ユーザーから読み取ったコミットにインデックスを付け、デフォルトでその時点のコミットに設定します。作業ツリーはそのまま保持されます。

@item @kbd{X s} (@code{magit-reset-soft})
@kindex X s
@findex magit-reset-soft
@code{HEAD}をユーザーから読み取ったコミットにリセットし、デフォルトでその時点でコミットします。インデックスと作業ツリーはそのまま保持されます。

@item @kbd{X h} (@code{magit-reset-hard})
@kindex X h
@findex magit-reset-hard
@code{HEAD}、インデックス、および作業ツリーを、ユーザーから読み取られたコミットにリセットし、デフォルトでそのポイントのコミットに設定します。

@item @kbd{X k} (@code{magit-reset-keep})
@kindex X k
@findex magit-reset-keep
@code{HEAD}、インデックス、および作業ツリーを、ユーザーから読み取られたコミットにリセットし、デフォルトでそのポイントのコミットに設定します。コミットされていない変更はそのまま保持されます。

@item @kbd{X i} (@code{magit-reset-index})
@kindex X i
@findex magit-reset-index
インデックスをユーザーから読み取ったコミットにリセットし、デフォルトでそのポイントでコミットします。@code{HEAD}と作業ツリーをそのままにしておくと、コミットが@code{HEAD}を参照している場合、これによりすべての変更が効果的にステージ解除(unstage)されます。

@item @kbd{X w} (@code{magit-reset-worktree})
@kindex X w
@findex magit-reset-worktree
作業ツリーをユーザーから読み取ったコミットにリセットし、デフォルトでその時点でコミットします。@code{HEAD}とインデックスはそのままにします。

@item @kbd{X f} (@code{magit-file-checkout})
@kindex X f
@findex magit-file-checkout
作業ツリーのファイルを更新し、リビジョンのコンテンツにインデックスを付けます。リビジョンとファイルの両方がユーザーから読み取られます。
@end table

@node Stashing
@section Stashing

こちらもご覧下さい 
@ifinfo
@ref{git-stash,,,gitman,}
@end ifinfo
@ifhtml
@c html
@c end html
the <a href="http://git-scm.com/docs/git-stash">git-stash(1)</a> manpage.
@end ifhtml
@iftex
the git-stash(1) manpage.
@end iftex

@table @asis
@item @kbd{z} (@code{magit-stash})
@kindex z
@findex magit-stash
このトランジェント(一時的)なプレフィックス(接頭辞)コマンドは、それに従うサフィックス(接尾辞)コマンドを適切なインフィックス(中置)引数とともに結び付け、いずれかのサフィックスコマンドを選択するまでの間、そのインフィックス引数達とサフィックスコマンド達を一時バッファ(temporary
buffer)に表示します。

@item @kbd{z z} (@code{magit-stash-both})
@kindex z z
@findex magit-stash-both
インデックスと作業ツリーのスタッシュを作成します。追跡されていないファイル(untracked
files)が含まれるかどうかはインフィックス引数の指定に依ります。1つのプレフィックス引数は@code{--include-untracked}と同等で、2つのプレフィックス引数は@code{--all}と同等です。

@item @kbd{z i} (@code{magit-stash-index})
@kindex z i
@findex magit-stash-index
インデックスのみのスタッシュを作成します。ステージされていない変更(unstaged changes)と追跡されていない変更(untracked
changes)はスタッシュされません。

@item @kbd{z w} (@code{magit-stash-worktree})
@kindex z w
@findex magit-stash-worktree
作業ツリーにステージされていない変更(unstaged changes)のスタッシュを作成します。追跡されていないファイル(untracked
files)は、インフィックス引数に依ります。1つのプレフィックス引数は@code{--include-untracked}と同等で、2つのプレフィックス引数は@code{--all}と同等です。

@item @kbd{z x} (@code{magit-stash-keep-index})
@kindex z x
@findex magit-stash-keep-index
インデックスをそのままにして、インデックスと作業ツリーのスタッシュを作成します。追跡されていないファイル(untracked
files)は、インフィックス引数に依ります。1つのプレフィックス引数は@code{--include-untracked}と同等で、2つのプレフィックス引数は@code{--all}と同等です。

@item @kbd{z Z} (@code{magit-snapshot-both})
@kindex z Z
@findex magit-snapshot-both
インデックスと作業ツリーのスナップショットを作成します。追跡されていないファイル(untracked
files)は、インフィックス引数に依ります。1つのプレフィックス引数は@code{--include-untracked}と同等で、2つのプレフィックス引数は@code{--all}と同等です。

@item @kbd{z I} (@code{magit-snapshot-index})
@kindex z I
@findex magit-snapshot-index
インデックスのみのスナップショットを作成します。ステージされていない変更(unstaged changes)と追跡されていない変更(untracked
changes)はスタッシュされません。

@item @kbd{z W} (@code{magit-snapshot-worktree})
@kindex z W
@findex magit-snapshot-worktree
作業ツリーでステージされていない変更(unstaged changes)のスナップショットを作成します。追跡されていないファイル(untracked
files)は、インフィックス引数に依ります。1つのプレフィックス引数は@code{--include-untracked}と同等で、2つのプレフィックス引数は@code{--all}と同等です。

@item @kbd{z a} (@code{magit-stash-apply})
@kindex z a
@findex magit-stash-apply
作業ツリーにスタッシュを適用します。 スタッシュインデックスを保持するよう試みます。ステージされた変更(staged
changes)があるために失敗した場合は、スタッシュインデックスを保持せずに適用します。

@item @kbd{z p} (@code{magit-stash-pop})
@kindex z p
@findex magit-stash-pop
作業ツリーにスタッシュを適用し、スタッシュリストから削除します。スタッシュインデックスを保持するよう試みます。ステージされた変更(staged
changes)があるためにそれが失敗した場合は、スタッシュインデックスを保持せずに適用し、スタッシュを削除しません。

@item @kbd{z k} (@code{magit-stash-drop})
@kindex z k
@findex magit-stash-drop
スタッシュリストからスタッシュを削除します。リージョンがアクティブになったら、含まれているすべてのスタッシュの削除を提案します。

@item @kbd{z v} (@code{magit-stash-show})
@kindex z v
@findex magit-stash-show
バッファ内のスタッシュのすべてのdiffを表示します。

@item @kbd{z b} (@code{magit-stash-branch})
@kindex z b
@findex magit-stash-branch
STASHから新しいBRANCHを作成してチェックアウトします。ブランチは、スタッシュが作成されたときの現在のコミットで開始されます。

@item @kbd{z B} (@code{magit-stash-branch-here})
@kindex z B
@findex magit-stash-branch-here
現在のブランチまたは@code{HEAD}を開始点(starting-point)として@code{magit-branch}を使用して、新しいBRANCHを作成してチェックアウトします。それからSTASHを適用し、きれいに適用される場合はドロップします。

@item @kbd{z f} (@code{magit-stash-format-patch})
@kindex z f
@findex magit-stash-format-patch
STASHからパッチを作成します。

@item @kbd{k} (@code{magit-stash-clear})
@kindex k
@findex magit-stash-clear
REFを削除して、REFのreflogに保存されているすべてのスタッシュを削除します。

@item @kbd{z l} (@code{magit-stash-list})
@kindex z l
@findex magit-stash-list
バッファ内のすべてのスタッシュを一覧表示します。
@end table

@defopt magit-stashes-margin
このオプションは、欄外が最初にスタッシュバッファに表示されるかどうか、およびそのフォーマット方法を指定します。

値の形式は@code{(INIT STYLE WIDTH AUTHOR AUTHOR-WIDTH)}です。

@itemize
@item
INITがnil以外の場合、欄外(margin)が最初に表示されます。
@item
STYLEは、作成者(author)またはコミッター(committer)の日付をフォーマットする方法を制御します。@code{age}(コミットの経過時間を示す)または@code{age-abbreviated}(時間単位を文字に短縮する)または実際の日付を表す文字列(@code{format-time-string}に適しています)のいずれかになります。オプション@code
{magit-log-margin-show-committer-date}は、表示される日付を制御します。
@item
WIDTHは、欄外(margin)の幅を制御します。これは上位互換性のために存在し、現在値を変更すべきではありません。
@item
AUTHORは、作成者の名前もデフォルトで表示されるかどうかを制御します。
@item
AUTHOR-WIDTHは整数である必要があります。作成者の名前が表示されている場合、これはそのために使用されるスペース(空き)の量を指定します。
@end itemize
@end defopt

@node Transferring
@chapter Transferring

@menu
* Remotes::                  Remotes
* Fetching::                 Fetching
* Pulling::                  Pulling
* Pushing::                  Pushing
* Plain Patches::            Plain Patches
* Maildir Patches::          Maildir Patches
@end menu

@node Remotes
@section Remotes

@menu
* Remote Commands::          Remote Commands
* Remote Git Variables::     Remote Git Variables
@end menu

@node Remote Commands
@subsection Remote Commands

トランジェントプレフィックスコマンド@code{magit-remote}は、リモートを追加し、既存のリモートに変更を加えるために使用されます。このコマンドは、リモート自体のみを処理し、ブランチやコミットの転送は処理しません。それらの機能は個別のトランジェントコマンドから利用できます。

こちらもご覧下さい 
@ifinfo
@ref{git-remote,,,gitman,}
@end ifinfo
@ifhtml
@c html
@c end html
the <a href="http://git-scm.com/docs/git-remote">git-remote(1)</a> manpage.
@end ifhtml
@iftex
the git-remote(1) manpage.
@end iftex

@table @asis
@item @kbd{M} (@code{magit-remote})
@kindex M
@findex magit-remote
このトランジェント(一時的)プレフィックス(接頭辞)コマンドは、それに従うサフィックス(接尾辞)コマンド群を結びつけ、そのサフィックスコマンドのどれかを選ぶまでの間、サフィックス(接尾辞)コマンド群を一時バッファ(temporary
buffer)に表示します。

デフォルトでは、リモート関連のGit変数の値を結び付けて表示し、それらの値を変更することもできます。
@end table

@defopt magit-remote-direct-configure
このオプションは、リモート関連のGit変数にトランジェントコマンド@code{magit-remote}から直接アクセスできるかどうかを制御します。

@code{t}(デフォルト)でローカルブランチがチェックアウトされている場合、@code{magit-remote}はそのブランチのアップストリームリモートの変数、または@code{HEAD}がデタッチされている場合で、存在する場合、@code{origin}の変数を備えています。

@code{nil}の場合は、@code{magit-remote-configure}を使用する必要があります。
@end defopt

@table @asis
@item @kbd{M C} (@code{magit-remote-configure})
@kindex M C
@findex magit-remote-configure
このトランジェントレフィックスコマンドは、リモート関連変数の値を設定するコマンドを結び付け、一時バッファが終了するまでそれらを一時バッファに表示します。

プレフィックス引数を使用すると、このコマンドは常にリモートの入力を求めます。

プレフィックス引数がない場合、これは@code{magit-remote}のサフィックスコマンドとして呼び出されたかどうかと@code{magit-remote-direct-configure}オプションに依存します。@code{magit-remote}がすでにアップストリームの変数を表示している場合、同じリモートの変数を表示する別のトランジェントコマンドを呼び出すことは意味がありません。その場合、このコマンドはリモートの入力を求めます。
@end table

変数についてはこちらの説明をご覧ください(@ref{Remote Git Variables})。

@table @asis
@item @kbd{M a} (@code{magit-remote-add})
@kindex M a
@findex magit-remote-add
このコマンドは、リモートを追加してフェッチします。リモート名とURLがミニバッファで読み取られます。

@item @kbd{M r} (@code{magit-remote-rename})
@kindex M r
@findex magit-remote-rename
このコマンドは、リモートの名前を変更します。 古い名前と新しい名前の両方がミニバッファで読み取られます。

@item @kbd{M u} (@code{magit-remote-set-url})
@kindex M u
@findex magit-remote-set-url
このコマンドは、リモートのURLを変更します。リモートと新しいURLの両方がミニバッファで読み取られます。

@item @kbd{M k} (@code{magit-remote-remove})
@kindex M k
@findex magit-remote-remove
このコマンドは、ミニバッファに読み込まれたリモートを削除します。

@item @kbd{M p} (@code{magit-remote-prune})
@kindex M p
@findex magit-remote-prune
このコマンドは、ミニバッファ内でリモートを読み取り、古いリモート追跡ブランチを削除します。

@item @kbd{M P} (@code{magit-remote-prune-refspecs})
@kindex M P
@findex magit-remote-prune-refspecs
このコマンドは、ミニバッファ内で読み取られたリモートの陳腐化した(stale)refspecを削除します。

refspecでフェッチされるブランチがリモートに1つも存在しない場合、そのrefspecは陳腐化しています。陳腐化したrefspecがあると、Gitがその行以降の陳腐化してないrefspecによるフェッチも拒否するため、問題があります。

陳腐化したrefspecのみが残っている場合、このコマンドは、リモートを削除するか、陳腐化したrefspecをデフォルトのrefspec
("+refs/heads/*:refs/remotes/REMOTE/*") に置き換えることを提案します。

このコマンドは、今や陳腐化したrefspecsのために作成されたリモートトラッキングブランチも削除します。他の陳腐化したブランチは削除されません。
@end table

@defopt magit-remote-add-set-remote.pushDefault
このオプションは、リモートを追加した後に@code{remote.pushDefault}を設定するかどうかをユーザーに尋ねるかどうかを制御します。

@code{ask}の場合、ユーザーは常に質問されます。@code{ask-if-unset}の場合、ユーザーは変数がまだ設定されていない場合にのみ使用できます。@code{nil}の場合、ユーザーは尋ねられず、変数は設定されません。値が文字列の場合、追加されたリモートの名前がその文字列と等しく、変数がまだ設定されていなければ、ユーザーに尋ねられることなく変数が設定されます。
@end defopt

@node Remote Git Variables
@subsection Remote Git Variables

これらの変数は、トランジェントプレフィックスコマンド@code{magit-remote-configure}から設定できます。デフォルトでは、@code{magit-remote}から設定することもできます。こちらを参照して下さい(@ref{Remote
Commands})。

@defvar remote.NAME.url
この変数は、NAMEという名前のリモートのURLを指定します。複数の値を持つことができます。
@end defvar

@defvar remote.NAME.fetch
NAMEという名前のリモートからフェッチするときに使用されるrefspecです。複数の値を持つことができます。
@end defvar

@defvar remote.NAME.pushurl
この変数は、NAME@ という名前のリモートへのプッシュに使用される URL を指定します。 指定されていない場合は、代わりに
@code{remote.NAME.url} が使用されます。 複数の値を持つことができます。
@end defvar

@defvar remote.NAME.push
NAMEという名前のリモートにプッシュするときに使用されるrefspecです。複数の値を持つことができます。
@end defvar

@defvar remote.NAME.tagOpts
この変数は、デフォルトでフェッチされるタグを指定します。値が@code{--no-tags}の場合、タグはフェッチされません。値が@code{--tags}の場合、すべてのタグがフェッチされます。この変数に値がない場合、フェッチされたブランチから到達可能なタグのみがフェッチされます。
@end defvar

@node Fetching
@section Fetching

こちらもご覧下さい 
@ifinfo
@ref{git-fetch,,,gitman,}
@end ifinfo
@ifhtml
@c html
@c end html
the <a href="http://git-scm.com/docs/git-fetch">git-fetch(1)</a> manpage.
@end ifhtml
@iftex
the git-fetch(1) manpage.
@end iftex
 アップストリーム(upstream)とプッシュリモート(push-remote)の詳細についてはこちらを参照して下さい(@ref{The Two
Remotes})。

@table @asis
@item @kbd{f} (@code{magit-fetch})
@kindex f
@findex magit-fetch
このトランジェント(一時的)なプレフィックス(接頭辞)コマンドは、それに従うサフィックス(接尾辞)コマンドを適切なインフィックス(中置)引数とともに結び付け、いずれかのサフィックスコマンドを選択するまでの間、そのインフィックス引数達とサフィックスコマンド達を一時バッファ(temporary
buffer)に表示します。

@item @kbd{f p} (@code{magit-fetch-from-pushremote})
@kindex f p
@findex magit-fetch-from-pushremote
このコマンドは、現在のプッシュリモートからフェッチします。

プレフィックス引数を使用する場合、またはプッシュリモートが構成されていないか使用できない場合は、最初にユーザーにプッシュリモートを構成させます。

@item @kbd{f u} (@code{magit-fetch-from-upstream})
@kindex f u
@findex magit-fetch-from-upstream
このコマンドは、現在のブランチのアップストリームからフェッチします。

アップストリームが現在のブランチ用に構成されていて、既存のリモートに名前を付けている場合は、それを使用します。それ以外の場合は、別のリモートを使用しようと試みます。リモートが1つだけ構成されている場合は、それを使用します。それ以外の場合、"origin"という名前のリモートが存在する場合は、それを使用します。

リモートを判別できない場合、このコマンドは@code{magit-fetch}トランジェントプレフィックスコマンドから使用できず、直接呼び出すとエラーになります。

@item @kbd{f e} (@code{magit-fetch-other})
@kindex f e
@findex magit-fetch-other
このコマンドは、ミニバッファから読み取られたリポジトリからフェッチします。

@item @kbd{f o} (@code{magit-fetch-branch})
@kindex f o
@findex magit-fetch-branch
このコマンドは、リモートからブランチをフェッチします。どちらもミニバッファから読み取られます。

@item @kbd{f r} (@code{magit-fetch-refspec})
@kindex f r
@findex magit-fetch-refspec
このコマンドは、明示的なrefspecを使用してリモートからフェッチします。どちらも、ミニバッファから読み取られます。

@item @kbd{f a} (@code{magit-fetch-all})
@kindex f a
@findex magit-fetch-all
このコマンドは、すべてのリモートからフェッチします。

@item @kbd{f m} (@code{magit-submodule-fetch})
@kindex f m
@findex magit-submodule-fetch
このコマンドは、すべてのサブモジュールをフェッチします。プレフィックス引数を使用して、すべてのサブモジュールのすべてのリモートをフェッチします。
@end table

@defopt magit-pull-or-fetch
デフォルトでは、フェッチコマンドとプルコマンドは、個別のトランジェントプレフィックスコマンドから使用できます。これを@code{t}に設定すると、(すべてではありませんが)上記のサフィックスコマンドの一部が@code{magit-pull}トランジェントコマンドに追加されます。

あなたがそうしたい場合、これらのプレフィックスコマンドのキーバインディングを変更することもできます。例:

@lisp
(setq magit-pull-or-fetch t)
(define-key magit-mode-map "f" 'magit-pull) ; was magit-fetch
(define-key magit-mode-map "F" nil)         ; was magit-pull
@end lisp
@end defopt

@node Pulling
@section Pulling

こちらもご覧下さい 
@ifinfo
@ref{git-pull,,,gitman,}
@end ifinfo
@ifhtml
@c html
@c end html
the <a href="http://git-scm.com/docs/git-pull">git-pull(1)</a> manpage.
@end ifhtml
@iftex
the git-pull(1) manpage.
@end iftex
 アップストリーム(upstream)とプッシュリモート(push-remote)の詳細についてはこちらを参照して下さい(@ref{The Two
Remotes})。

@table @asis
@item @kbd{F} (@code{magit-pull})
@kindex F
@findex magit-pull
このトランジェント(一時的)プレフィックス(接頭辞)コマンドは、それに従うサフィックス(接尾辞)コマンド群を結びつけ、そのサフィックスコマンドのどれかを選ぶまでの間、サフィックス(接尾辞)コマンド群を一時バッファ(temporary
buffer)に表示します。

@item @kbd{F p} (@code{magit-pull-from-pushremote})
@kindex F p
@findex magit-pull-from-pushremote
このコマンドは、現在のブランチのプッシュリモートからプルします。

プレフィックス引数を使用する場合、またはプッシュリモートが構成されていないか使用できない場合は、最初にユーザーにプッシュリモートを構成させます。

@item @kbd{F u} (@code{magit-pull-from-upstream})
@kindex F u
@findex magit-pull-from-upstream
このコマンドは、現在のブランチのアップストリームからプルします。

プレフィックス引数を使用する場合、またはアップストリームが構成されていないか使用できない場合は、ユーザーが最初にアップストリームを構成できるようにします。

@item @kbd{F e} (@code{magit-pull-branch})
@kindex F e
@findex magit-pull-branch
このコマンドは、ミニバッファで読み取られたブランチからプルします。
@end table

@node Pushing
@section Pushing

こちらもご覧下さい 
@ifinfo
@ref{git-push,,,gitman,}
@end ifinfo
@ifhtml
@c html
@c end html
the <a href="http://git-scm.com/docs/git-push">git-push(1)</a> manpage.
@end ifhtml
@iftex
the git-push(1) manpage.
@end iftex
 アップストリーム(upstream)とプッシュリモート(push-remote)の詳細についてはこちらを参照して下さい(@ref{The Two
Remotes})。

@table @asis
@item @kbd{P} (@code{magit-push})
@kindex P
@findex magit-push
このトランジェント(一時的)なプレフィックス(接頭辞)コマンドは、それに従うサフィックス(接尾辞)コマンドを適切なインフィックス(中置)引数とともに結び付け、いずれかのサフィックスコマンドを選択するまでの間、そのインフィックス引数達とサフィックスコマンド達を一時バッファ(temporary
buffer)に表示します。

@item @kbd{P p} (@code{magit-push-current-to-pushremote})
@kindex P p
@findex magit-push-current-to-pushremote
このコマンドは、現在のブランチをそのプッシュリモートにプッシュします。

プレフィックス引数を使用する場合、またはプッシュリモートが構成されていないか使用できない場合は、最初にユーザーにプッシュリモートを構成させます。

@item @kbd{P u} (@code{magit-push-current-to-upstream})
@kindex P u
@findex magit-push-current-to-upstream
このコマンドは、現在のブランチをそのアップストリームブランチにプッシュします。

プレフィックス引数を使用する場合、またはアップストリームが構成されていないか使用できない場合は、ユーザーが最初にアップストリームを構成できるようにします。

@item @kbd{P e} (@code{magit-push-current})
@kindex P e
@findex magit-push-current
このコマンドは、現在のブランチをミニバッファで読み取られたブランチにプッシュします。

@item @kbd{P o} (@code{magit-push-other})
@kindex P o
@findex magit-push-other
このコマンドは、任意のブランチをプッシュするか、どこかにコミットします。ソースとターゲットの両方がミニバッファで読み取られます。

@item @kbd{P r} (@code{magit-push-refspecs})
@kindex P r
@findex magit-push-refspecs
このコマンドは、1つまたは複数のrefspecを使用してリモートにプッシュします。どちらもミニバッファで読み取られます。

複数のrefspecを使用するには、それらをコンマで区切ります。補完は、コロンの前の部分、またはコロンが使用されていない場合にのみ使用できます。

@item @kbd{P m} (@code{magit-push-matching})
@kindex P m
@findex magit-push-matching
このコマンドは、一致するすべてのブランチを別のリポジトリにプッシュします。

リモートが1つしかない場合は、そこにプッシュします。それ以外の場合は、リモートのプロンプトを表示し、現在のブランチ用に構成されたリモートをデフォルトとして提供します。

@item @kbd{P t} (@code{magit-push-tags})
@kindex P t
@findex magit-push-tags
このコマンドは、すべてのタグを別のリポジトリにプッシュします。

リモートが1つしかない場合は、そこにプッシュします。それ以外の場合は、リモートのプロンプトを表示し、現在のブランチ用に構成されたリモートをデフォルトとして提供します。

@item @kbd{P T} (@code{magit-push-tag})
@kindex P T
@findex magit-push-tag
このコマンドは、タグを別のリポジトリにプッシュします。
@end table

注意:
インフィックス引数の1つである@code{--force-with-lease}には、注意が必要です。値なしで渡されます。これは、「リモート追跡ブランチがリモートエンドの対応するブランチと一致する限り、強制プッシュを許可する」ことを意味します。(Magit自体はそのような機能を提供しませんが、)あなたが自動フェッチを実行するツールを設定した場合、@code{--force-with-lease}を使用すると、実際にはリモートトラッキングへの参照状態(the
state of the remote-tracking
refs)を制御または認識していないため、危険な場合があります。その場合は、@code{push.useForceIfIncludes}を@code{true}に設定することを検討する必要があります(Git
2.30以降で使用可能)。

さらに2つのプッシュコマンドが存在しますが、デフォルトではプッシュトランジェントコマンドからは使用できません。それらをトランジェントコマンドに追加する方法については、doc-stringsを参照してください。

@deffn Command magit-push-implicitly args
このコマンドは、明示的なrefspecを使用せずにどこかにプッシュします。

このコマンドは、単純に@code{git push -v
[ARGS]}を実行するだけです。ARGSはインフィックス引数です。明示的なrefspec引数は使用されません。代わりに、動作は少なくとも次のGit変数に依存します:
@code{push.default}、@code{remote.pushDefault}、@code{branch.<branch>.pushRemote}、@code{branch.<branch>.remote}、@code{branch.<branch>.merge}、@code{remote.<remote>.push}

あなたがdescriptionを明示的に指定せずにこのサフィックスコマンドをトランジェントプレフィックスコマンド追加すると、Magitはこのコマンドの動作を予測しようとします。例えば:

@lisp
(transient-insert-suffix 'magit-push \"p\"
  '(\"i\" magit-push-implicitly))"
@end lisp
@end deffn

@deffn Command magit-push-to-remote remote args
このコマンドは、明示的なrefspecを使用せずにリモートであるREMOTEにプッシュします。リモートはミニバッファに読み込まれます。

このコマンドは、単純に@code{git push -v [ARGS]
REMOTE}を実行するだけです。ARGSはインフィックス引数です。refspec引数は使用されません。
代わりに、動作は少なくとも次のGit変数に依存します:
@code{push.default}、@code{remote.pushDefault}、@code{branch.<branch>.pushRemote}、@code{branch.<branch>.remote}、@code{branch.<branch>.merge}、@code{remote.<remote>.push}
@end deffn

@node Plain Patches
@section Plain Patches

@table @asis
@item @kbd{W} (@code{magit-patch})
@kindex W
@findex magit-patch
このトランジェント(一時的)なプレフィックス(接頭辞)コマンドは、それに従うサフィックス(接尾辞)コマンドを適切なインフィックス(中置)引数とともに結び付け、いずれかのサフィックスコマンドを選択するまでの間、そのインフィックス引数達とサフィックスコマンド達を一時バッファ(temporary
buffer)に表示します。

@item @kbd{W c} (@code{magit-patch-create})
@kindex W c
@findex magit-patch-create
このコマンドは、コミットの組み(a set
commits)のパッチを作成します。リージョンが複数のコミットをマークする場合、それらすべてのパッチを作成します。それ以外の場合は、トランジェントプレフィックスコマンドとして機能します。このコマンドは、いくつかのインフィックス引数を備え、サフィックスコマンドとして自身を結び付けます。このコマンドがそれ自体のサフィックスコマンドとして呼び出されると、指定されたインフィックス引数を使用してパッチが作成されます。

@item @kbd{w a} (@code{magit-patch-apply})
@kindex w a
@findex magit-patch-apply
このコマンドはパッチを適用します。これはトランジェントプレフィックスコマンドであり、いくつかのインフィックス引数を備え、サフィックスコマンドとしてそれ自体を結び付けます。このコマンドがそれ自体のサフィックスコマンドとして呼び出されると、指定されたインフィックス引数を使用してパッチが適用されます。

@item @kbd{W s} (@code{magit-patch-save})
@kindex W s
@findex magit-patch-save
このコマンドは、現在のdiffからパッチを作成します。

@code{magit-diff-mode}または@code{magit-revision-mode}バッファ内では、@code{C-x
C-w}もこのコマンドに結び付けられています。
@end table

@code{magit-diff-mode}または@code{magit-revision-mode}バッファ内で@code{C-x
C-w}を使用して、プレーンパッチファイルを保存することもできます。

@node Maildir Patches
@section Maildir Patches

こちらもご覧下さい 
@ifinfo
@ref{git-am,,,gitman,}
@end ifinfo
@ifhtml
@c html
@c end html
the <a href="http://git-scm.com/docs/git-am">git-am(1)</a> manpage.
@end ifhtml
@iftex
the git-am(1) manpage.
@end iftex
 と 
@ifinfo
@ref{git-apply,,,gitman,}
@end ifinfo
@ifhtml
@c html
@c end html
the <a href="http://git-scm.com/docs/git-apply">git-apply(1)</a> manpage.
@end ifhtml
@iftex
the git-apply(1) manpage.
@end iftex

@table @asis
@item @kbd{w} (@code{magit-am})
@kindex w
@findex magit-am
このトランジェント(一時的)なプレフィックス(接頭辞)コマンドは、それに従うサフィックス(接尾辞)コマンドを適切なインフィックス(中置)引数とともに結び付け、いずれかのサフィックスコマンドを選択するまでの間、そのインフィックス引数達とサフィックスコマンド達を一時バッファ(temporary
buffer)に表示します。

@item @kbd{w w} (@code{magit-am-apply-patches})
@kindex w w
@findex magit-am-apply-patches
このコマンドは、1つ以上のパッチを適用します。リージョンがファイルをマークしている場合、それらはパッチとして適用されます。それ以外の場合、このコマンドはミニバッファ内のファイル名を読み取り、デフォルトではそのポイントのファイルになります。

@item @kbd{w m} (@code{magit-am-apply-maildir})
@kindex w m
@findex magit-am-apply-maildir
このコマンドは、maildirからパッチを適用します。

@item @kbd{w a} (@code{magit-patch-apply})
@kindex w a
@findex magit-patch-apply
このコマンドは、プレーンパッチを適用します。詳細はこちらをご覧下さい(@ref{Plain Patches})。
このコマンドは、歴史的な理由から、@code{magit-am}トランジェントコマンドからのみ使用できます。
@end table

"am"操作が進行中の場合、トランジェントコマンドには代わりのサフィックスコマンドがあります。

@table @asis
@item @kbd{w w} (@code{magit-am-continue})
@kindex w w
@findex magit-am-continue
このコマンドは、現在のパッチ適用シーケンスを再開します。

@item @kbd{w s} (@code{magit-am-skip})
@kindex w s
@findex magit-am-skip
このコマンドは、パッチ適用シーケンス中にパッチ当てが中断したものをスキップします。

@item @kbd{w a} (@code{magit-am-abort})
@kindex w a
@findex magit-am-abort
このコマンドは、現在のパッチ適用シーケンスを中止(abort)します。 これにより、シーケンスの開始以降に行われたすべての変更が破棄されます。
@end table

@node Miscellaneous
@chapter Miscellaneous

@menu
* Tagging::                  Tagging
* Notes::                    Notes
* Submodules::               Submodules
* Subtree::                  Subtree
* Worktree::                 Worktree
* Sparse checkouts::         Sparse checkouts
* Bundle::                   Bundle
* Common Commands::          Common Commands
* Wip Modes::                Wip Modes
* Commands for Buffers Visiting Files::  Commands for Buffers Visiting Files
* Minor Mode for Buffers Visiting Blobs::  Minor Mode for Buffers Visiting 
                                             Blobs
@end menu

@node Tagging
@section Tagging

こちらもご覧下さい 
@ifinfo
@ref{git-tag,,,gitman,}
@end ifinfo
@ifhtml
@c html
@c end html
the <a href="http://git-scm.com/docs/git-tag">git-tag(1)</a> manpage.
@end ifhtml
@iftex
the git-tag(1) manpage.
@end iftex

@table @asis
@item @kbd{t} (@code{magit-tag})
@kindex t
@findex magit-tag
このトランジェント(一時的)なプレフィックス(接頭辞)コマンドは、それに従うサフィックス(接尾辞)コマンドを適切なインフィックス(中置)引数とともに結び付け、いずれかのサフィックスコマンドを選択するまでの間、そのインフィックス引数達とサフィックスコマンド達を一時バッファ(temporary
buffer)に表示します。

@item @kbd{t t} (@code{magit-tag-create})
@kindex t t
@findex magit-tag-create
このコマンドは、REVで指定されたNAMEを使用して新しいタグを作成します。プレフィックス引数を使用して、注釈付きタグ(annotated
tag)を作成します。

@item @kbd{t r} (@code{magit-tag-release})
@kindex t r
@findex magit-tag-release
このコマンドはリリースタグを作成します。リリースタグが@code{magit-release-tag-regexp}と一致することを前提としています。

最初に、既存の最も最近のタグを初期入力として表示して新しいタグの名前の入力を求め、バージョン文字列の部分をインクリメントするようにユーザーに任せます。
型破りなリリースタグまたはバージョン番号(例:
@code{v1.2.3-custom.1})を使用する場合、あなたは@code{magit-release-tag-regexp}と@code{magit-tag-version-regexp-alist}変数を設定できます。

@code{--annotate}が有効になっている場合は、新しいタグのメッセージ入力を求められます。提案されたタグメッセージは、対応するバージョン文字列を含み、その代わりに新しいバージョン文字列を使用するという条件で、最も最近のタグのメッセージに基づいています。それ以外の場合は、例えば、TAG
"v1.2.3"と"/path/to/foo-bar"のようなリポジトリであれば."Foo-Bar 1.2.3"のようなものを提案します。

@item @kbd{t k} (@code{magit-tag-delete})
@kindex t k
@findex magit-tag-delete
このコマンドは、1つ以上のタグを削除します。リージョンが複数のタグをマークしている場合(そして他には何もマークしていない場合)、それらを削除することを提案します。それ以外の場合は、単一のタグを削除するように求められ、デフォルトでそのポイントのタグになります。

@item @kbd{t p} (@code{magit-tag-prune})
@kindex t p
@findex magit-tag-prune
このコマンドは、REMOTEにありローカルに欠落しているタグを削除することを提案します。その逆も同様にします。
@end table

@node Notes
@section Notes

こちらもご覧下さい 
@ifinfo
@ref{git-notes,,,gitman,}.
@end ifinfo
@ifhtml
@c html
@c end html
the <a href="http://git-scm.com/docs/git-notes">git-notes(1)</a> manpage.
@end ifhtml
@iftex
the git-notes(1) manpage.
@end iftex

@table @asis
@item @kbd{T} (@code{magit-notes})
@kindex T
@findex magit-notes
このトランジェント(一時的)なプレフィックス(接頭辞)コマンドは、それに従うサフィックス(接尾辞)コマンドを適切なインフィックス(中置)引数とともに結び付け、いずれかのサフィックスコマンドを選択するまでの間、そのインフィックス引数達とサフィックスコマンド達を一時バッファ(temporary
buffer)に表示します。

@item @kbd{T T} (@code{magit-notes-edit})
@kindex T T
@findex magit-notes-edit
コミットに添付されたnoteを編集します。デフォルトでは、そのポイントでのコミットになります。

デフォルトでは、Git変数@code{core.notesRef}または
"refs/notes/commits"の値が未定義の場合は、その値を使用します。

@item @kbd{T r} (@code{magit-notes-remove})
@kindex T r
@findex magit-notes-remove
コミットに添付されたnoteを削除します。デフォルトでは、そのポイントでのコミットになります。

デフォルトでは、Git変数@code{core.notesRef}または
"refs/notes/commits"の値が未定義の場合は、その値を使用します。

@item @kbd{T p} (@code{magit-notes-prune})
@kindex T p
@findex magit-notes-prune
到達不能なコミットに関するnoteを削除します。
@end table

1つのnote refを別のnote refにマージすることが可能です。 その結果、一時的なワークツリー
".git/NOTES@math{_MERGE}@math{_WORKTREE}" で解決する必要のある競合が発生する可能性があります。

@table @asis
@item @kbd{T m} (@code{magit-notes-merge})
@kindex T m
@findex magit-notes-merge
ユーザーから読み取ったrefのnotesを現在のnotes refにマージします。現在のnotes
refは、Git変数@code{core.notesRef}の値、または定義されていない場合は"refs/notes/commits"の値です。
@end table

notesのマージが進行中の場合、トランジェントコマンドは上記のコマンドに代わるサフィックスコマンドがあります。

@table @asis
@item @kbd{T c} (@code{magit-notes-merge-commit})
@kindex T c
@findex magit-notes-merge-commit
競合を手動で解決した後、現在のnotes refマージをコミットします。

@item @kbd{T a} (@code{magit-notes-merge-abort})
@kindex T a
@findex magit-notes-merge-abort
現在のnotes ref マージを中止(abort)します。
@end table

以下の変数達は、notes referenceに@code{magit-notes-*}と@code{git notes}と@code{git
show}がどのように作用して表示するかを制御します。ローカル値とグローバル値の両方が表示され、変更できます。

@defvar core.notesRef
この変数は、デフォルトで表示されるnotes refと、デフォルトで動作するコマンドを指定します。
@end defvar

@defvar notes.displayRef
この変数は、@code{core.notesRef}で指定されたrefに加えて、表示される追加のnotes
refを指定します。複数の値を持つことができ、@code{*}で終わる場合は、@code{refs/notes/}名前空間(または一部の名前にスラッシュが含まれている場合は@code{**})内のすべてのrefを表示します。
@end defvar

@node Submodules
@section Submodules

こちらもご覧下さい 
@ifinfo
@ref{git-submodule,,,gitman,}
@end ifinfo
@ifhtml
@c html
@c end html
the <a href="http://git-scm.com/docs/git-submodule">git-submodule(1)</a>
manpage.
@end ifhtml
@iftex
the git-submodule(1) manpage.
@end iftex

@menu
* Listing Submodules::       Listing Submodules
* submodule用トランジェントコマンド::  submodule用トランジェントコマンド
@end menu

@node Listing Submodules
@subsection Listing Submodules

コマンド@code{magit-list-submodules}は、現在のリポジトリのサブモジュールのリストを別のバッファに表示します。(@ref{Status
Module
Sections})で説明されているように、@code{magit-insert-modules}をフック@code{magit-status-sections-hook}に追加することで、スーパーリポジトリ(super-repository)のステータスバッファにサブモジュールに関する情報を直接表示することもできます。

@deffn Command magit-list-submodules
このコマンドは、現在のリポジトリのサブモジュールのリストを別のバッファに表示します。

"Modules"というタイトルのセクションで@code{RET}を押すと呼び出すことができます。
@end deffn

@defopt magit-submodule-list-columns
このオプションは、コマンド@code{magit-list-submodules}によって表示される列とその表示方法を制御します。

各要素の形式は@code{(HEADER WIDTH FORMAT PROPS)}です。

HEADERは、ヘッダーに表示される文字列です。WIDTHは、列の幅です。FORMATは、1つの引数とリポジトリID(通常はそのベース名)と作業ツリーの最上位に結び付けられたされた@code{default-directory}を使用して呼び出される関数です。挿入する文字列またはnilを返す必要があります。PROPSは、キー@code{:right-align}と@code{:pad-right}と@code{:sort}をサポートするalistです。

@code{:sort} 関数は、 @code{tabulated-list--get-sort} の docstring
に記述されている奇妙なインターフェースを持っています。 あるいは @code{<} や @code{magit-repolist-version<}
を使用できます。これらの関数は、インターフェイスを満たす関数に自動的に置き換えられます。 @code{:sort} を @code{nil}
に設定してソートを禁止します。 指定しない場合、列はデフォルトのソーターを使用してソート可能です。

あなたは列ごとに1文字だけを使用し、列間にパディングなしで数値列の範囲を表示したい場合があるかもしれません。その場合は、適切なHEADERを使用し、WIDTHを1に設定し、@code{:pad-right}を9に設定する必要があります。@code{+}は、9より大きい数値に置き換えられます。
@end defopt

@node submodule用トランジェントコマンド
@subsection submodule用トランジェントコマンド

@table @asis
@item @kbd{o} (@code{magit-submodule})
@kindex o
@findex magit-submodule
このトランジェント(一時的)なプレフィックス(接頭辞)コマンドは、それに従うサフィックス(接尾辞)コマンドを適切なインフィックス(中置)引数とともに結び付け、いずれかのサフィックスコマンドを選択するまでの間、そのインフィックス引数達とサフィックスコマンド達を一時バッファ(temporary
buffer)に表示します。
@end table

以下のコマンドのいくつかは、デフォルトで、リージョンを使用して選択されたモジュールに作用します。簡潔にするために、それらの説明は「選択されたモジュール」について説明していますが、モジュールが選択されていない場合は、代わりに現在のモジュールに作用します。ポイントがモジュール上にない場合は、単一のモジュールを読み取って作用します。プレフィックス引数を使用すると、これらのコマンドは選択したのや現在のモジュールを無視し、その代わりにすべての適切なモジュールに作用します。

@table @asis
@item @kbd{o a} (@code{magit-submodule-add})
@kindex o a
@findex magit-submodule-add
このコマンドは、指定のURLのリポジトリをモジュールとして追加します。オプションのPATHは、スーパープロジェクトのルートを基準にしたモジュールへのパスです。nilの場合、パスはURLに基づいて決定されます。

@item @kbd{o r} (@code{magit-submodule-register})
@kindex o r
@findex magit-submodule-register
このコマンドは、URLを".gitmodules"から"$GIT@math{_DIR}/config"にコピーすることにより、選択したモジュールを登録します。これらの値は、@code{magit-submodule-populate}を実行する前に編集できます。URLを編集する必要がない場合は、後者を直接使用してください。

@item @kbd{o p} (@code{magit-submodule-populate})
@kindex o p
@findex magit-submodule-populate
このコマンドは、選択したモジュールの1つまたは複数の作業ディレクトリを作成し、記録されたコミットをチェックアウトします。

@item @kbd{o u} (@code{magit-submodule-update})
@kindex o u
@findex magit-submodule-update
このコマンドは、記録されたコミットをチェックアウトする選択したモジュールを更新します。

@item @kbd{o s} (@code{magit-submodule-synchronize})
@kindex o s
@findex magit-submodule-synchronize
このコマンドは、選択したモジュールのURLを同期し、スーパープロジェクトの".gitmodules"から".git/config"に値をコピーし、モジュールの値もコピーします。

@item @kbd{o d} (@code{magit-submodule-unpopulate})
@kindex o d
@findex magit-submodule-unpopulate
このコマンドは、選択したモジュールの作業ディレクトリを削除します。

@item @kbd{o l} (@code{magit-list-submodules})
@kindex o l
@findex magit-list-submodules
このコマンドは、現在のリポジトリのモジュールのリストを表示します。

@item @kbd{o f} (@code{magit-fetch-modules})
@kindex o f
@findex magit-fetch-modules
このコマンドは、すべてのモジュールをフェッチします。

オプション@code{magit-fetch-modules-jobs}は、並列にフェッチされるサブモジュールの数を制御します。@code{git
fetch}はスーパーリポジトリのフェッチを行わないことをサポートしていないため、スーパーリポジトリもフェッチします。プレフィックス引数を使用すると、すべてのリモートをフェッチします。
@end table

@node Subtree
@section Subtree

こちらもご覧下さい 
@ifinfo
@ref{git-subtree,,,gitman,}
@end ifinfo
@ifhtml
@c html
@c end html
the <a href="http://git-scm.com/docs/git-subtree">git-subtree(1)</a>
manpage.
@end ifhtml
@iftex
the git-subtree(1) manpage.
@end iftex

@table @asis
@item @kbd{O} (@code{magit-subtree})
@kindex O
@findex magit-subtree
このトランジェントプレフィックスコマンドは、2つのサブトランジェントコマンドを結び付けます。1つはサブツリーをインポートするためのもので、もう1つはサブツリーをエクスポートするためのものです。

@item @kbd{O i} (@code{magit-subtree-import})
@kindex O i
@findex magit-subtree-import
このトランジェント(一時的)なプレフィックス(接頭辞)コマンドは、それに従うサフィックス(接尾辞)コマンドを適切なインフィックス(中置)引数とともに結び付け、いずれかのサフィックスコマンドを選択するまでの間、そのインフィックス引数達とサフィックスコマンド達を一時バッファ(temporary
buffer)に表示します。

このコマンドのサフィックスコマンドはサブツリーをインポートします。

@code{--prefix}引数が設定されている場合、サフィックスコマンドはユーザーにプロンプトを表示せずにそのプレフィックス引数を使用します。設定されていない場合は、ミニバッファでプレフィックス引数を読み取ります。

@item @kbd{O i a} (@code{magit-subtree-add})
@kindex O i a
@findex magit-subtree-add
このコマンドは、REPOSITORYからのCOMMITをPREFIXの新しいサブツリーとして追加します。

@item @kbd{O i c} (@code{magit-subtree-add-commit})
@kindex O i c
@findex magit-subtree-add-commit
このコマンドは、COMMITをPREFIXの新しいサブツリーとして追加します。

@item @kbd{O i m} (@code{magit-subtree-merge})
@kindex O i m
@findex magit-subtree-merge
このコマンドは、COMMITをPREFIXサブツリーにマージします。

@item @kbd{O i f} (@code{magit-subtree-pull})
@kindex O i f
@findex magit-subtree-pull
このコマンドは、COMMITをREPOSITORYからPREFIXサブツリーにプルします。

@item @kbd{O e} (@code{magit-subtree-export})
@kindex O e
@findex magit-subtree-export
このトランジェント(一時的)なプレフィックス(接頭辞)コマンドは、それに従うサフィックス(接尾辞)コマンドを適切なインフィックス(中置)引数とともに結び付け、いずれかのサフィックスコマンドを選択するまでの間、そのインフィックス引数達とサフィックスコマンド達を一時バッファ(temporary
buffer)に表示します。

このコマンドのサフィックスコマンドはサブツリーをエクスポートします。

@code{--prefix}引数が設定されている場合、サフィックスコマンドはユーザーにプロンプトを表示せずにそのプレフィックス引数を使用します。設定されていない場合は、ミニバッファでプレフィックス引数を読み取ります。

@item @kbd{O e p} (@code{magit-subtree-push})
@kindex O e p
@findex magit-subtree-push
このコマンドは、サブツリーPREFIXの履歴を抽出し、それをREPOSITORYのREFにプッシュします。

@item @kbd{O e s} (@code{magit-subtree-split})
@kindex O e s
@findex magit-subtree-split
このコマンドは、サブツリーPREFIXの履歴を抽出します。
@end table

@node Worktree
@section Worktree

こちらもご覧下さい 
@ifinfo
@ref{git-worktree,,,gitman,}
@end ifinfo
@ifhtml
@c html
@c end html
the <a href="http://git-scm.com/docs/git-worktree">git-worktree(1)</a>
manpage.
@end ifhtml
@iftex
the git-worktree(1) manpage.
@end iftex

@table @asis
@item @kbd{Z} (@code{magit-worktree})
@kindex Z
@findex magit-worktree
このトランジェント(一時的)プレフィックス(接頭辞)コマンドは、それに従うサフィックス(接尾辞)コマンド群を結びつけ、そのサフィックスコマンドのどれかを選ぶまでの間、サフィックス(接尾辞)コマンド群を一時バッファ(temporary
buffer)に表示します。

@item @kbd{Z b} (@code{magit-worktree-checkout})
@kindex Z b
@findex magit-worktree-checkout
PATHの新しいworktreeでBRANCHをチェックアウトします。

@item @kbd{Z c} (@code{magit-worktree-branch})
@kindex Z c
@findex magit-worktree-branch
新しいBRANCHを作成し、PATHの新しいworktreeでチェックアウトします。

@item @kbd{Z m} (@code{magit-worktree-move})
@kindex Z m
@findex magit-worktree-move
既存のworktreeを新しいPATHに移動します。

@item @kbd{Z k} (@code{magit-worktree-delete})
@kindex Z k
@findex magit-worktree-delete
worktreeを削除します。デフォルトでは、ポイントのworktreeになります。プライマリworktreeは削除できません。

@item @kbd{Z g} (@code{magit-worktree-status})
@kindex Z g
@findex magit-worktree-status
ポイントでのworktreeのステータスを表示します。

ポイントにworktreeがない場合は、ミニバッファでworktreeを読み取ります。ポイントのworktreeが、現在のバッファにステータスがすでに表示されているworktreeである場合は、代わりにDiredで表示します。
@end table

@node Sparse checkouts
@section Sparse checkouts

スパースチェックアウトは、作業ツリーをディレクトリのサブセットに制限する方法を提供します。 以下をご覧下さい 
@ifinfo
@ref{git-sparse-checkout,,,gitman,}.
@end ifinfo
@ifhtml
@c html
@c end html
the <a
href="http://git-scm.com/docs/git-sparse-checkout">git-sparse-checkout(1)</a>
manpage.
@end ifhtml
@iftex
the git-sparse-checkout(1) manpage.
@end iftex

@strong{警告}: Git はバージョン 2.25 で @code{git sparse-checkout}
コマンドを導入しましたが、まだ実験的であり、変更される可能性があると公告しています。 Magit のインターフェイスも同様と見なす必要があります。
特に、Git が下位互換性のない変更を導入した場合、Magit のスパースチェックアウト機能は、より新しい Git
バージョンを必要とする方法で更新される可能性があります。

@table @asis
@item @kbd{>} (@code{magit-sparse-checkout})
@kindex >
@findex magit-sparse-checkout
このトランジェント(一時的)プレフィックス(接頭辞)コマンドは、それに従うサフィックス(接尾辞)コマンド群を結びつけ、そのサフィックスコマンドのどれかを選ぶまでの間、サフィックス(接尾辞)コマンド群を一時バッファ(temporary
buffer)に表示します。

@item @kbd{> e} (@code{magit-sparse-checkout-enable})
@kindex > e
@findex magit-sparse-checkout-enable
このコマンドは、最上位ディレクトリ内のファイルのみを含むスパースチェックアウトを初期化します。

注意: @code{magit-sparse-checkout-set} と @code{magit-sparse-checkout-add}
は、必要に応じてスパースチェックアウトを自動的に初期化することに注意してください。
ただし、@code{magit-sparse-checkout-enable}
を明示的に呼び出して、@code{magit-sparse-checkout-disable}
を呼び出した後にスパースチェックアウトを再初期化し、追加の引数を @code{git sparse-checkout init} に渡すこともできます。
または初期化を非同期で実行します。

@item @kbd{> s} (@code{magit-sparse-checkout-set})
@kindex > s
@findex magit-sparse-checkout-set
このコマンドは、ディレクトリのリストを取得し、それらのサブディレクトリ内のファイルのみを含めるようにスパースチェックアウトを構成します。
指定されたディレクトリのリストに含まれていない限り、以前に含まれていたディレクトリは除外されます。

@item @kbd{> a} (@code{magit-sparse-checkout-add})
@kindex > a
@findex magit-sparse-checkout-add
このコマンドは @code{magit-sparse-checkout-set} に似ていますが、代わりに、指定されたディレクトリのリストを、スパース
チェックアウトに既に含まれているディレクトリのセットに追加します。

@item @kbd{> r} (@code{magit-sparse-checkout-reapply})
@kindex > r
@findex magit-sparse-checkout-reapply
このコマンドは、現在構成されているスパースチェックアウトパターンを作業ツリーに適用します。
これは、マージやリベースなどの操作の後に除外されたファイルがチェックアウトされている場合に呼び出すと便利です。

@item @kbd{> d} (@code{magit-sparse-checkout-disable})
@kindex > d
@findex magit-sparse-checkout-disable
このコマンドは、完全なチェックアウト(full checkout)を復元(restore)します。 以前のスパースチェックアウトに戻るには、
@code{magit-sparse-checkout-enable} を呼び出します。
@end table

@code{magit-clone} トランジェントで @code{magit-clone-sparse}
コマンドを使用してリポジトリのクローンを作成するときに、スパースチェックアウトを開始することもできます (@ref{Cloning
Repository} を参照)。

スパースチェックアウトが有効になっていることをステータスバッファーに表示する場合は、関数
@code{magit-sparse-checkout-insert-header} を
@code{magit-status-headers-hook} に追加します。

@node Bundle
@section Bundle

こちらもご覧下さい 
@ifinfo
@ref{git-bundle,,,gitman,}.
@end ifinfo
@ifhtml
@c html
@c end html
the <a href="http://git-scm.com/docs/git-bundle">git-bundle(1)</a> manpage.
@end ifhtml
@iftex
the git-bundle(1) manpage.
@end iftex

@deffn Command magit-bundle
このトランジェント(一時的)プレフィックス(接頭辞)コマンドは、@code{git
bundle}サブコマンドを実行するためのいくつかのサフィックス(接尾辞)コマンドを結び付け、サフィックスコマンドが呼び出されるまでそれらを一時バッファ(temporary
buffer)に表示します。
@end deffn

@node Common Commands
@section Common Commands

@deffn Command magit-switch-to-repository-buffer
@end deffn
@deffn Command magit-switch-to-repository-buffer-other-window
@end deffn
@deffn Command magit-switch-to-repository-buffer-other-frame
@end deffn
@deffn Command magit-display-repository-buffer
これらのコマンドは、現在のリポジトリに属する既存のMagitバッファをユーザーから読み取り、(リフレッシュせずに)選択したバッファに切り替えます。

最後のバリエーションは@code{magit-display-buffer}を使用してこれを行うため、@code{magit-display-buffer-function}を尊重します。
@end deffn

これらは、メジャーモードが@code{magit-mode}から派生するすべてのバッファで使用できるコマンドの一部です。以下のコマンドのほかに他の一般的なコマンドがありますが、これらは他には当てはまりませんでした。

@table @asis
@item @kbd{C-w} (@code{magit-copy-section-value})
@kindex C-w
@findex magit-copy-section-value
このコマンドは、現在のセクションの値を@code{kill-ring}に保存し、現在のセクションがコミットまたはブランチまたはタグセクションである場合、(参照される)リビジョンを@code{magit-revision-stack}にプッシュします。

現在のセクションがブランチまたはタグであり、プレフィックス引数が使用されている場合、その先端(tip)のリビジョンは、参照名の代わりに@code{kill-ring}に保存されます。

リージョンがアクティブな場合、このコマンドは、上記のように動作する代わりに、@code{kill-ring-save}のように@code{kill-ring}にそれを保存します。プレフィックス引数が使用され、領域がハンク内にある場合、プレフィックス引数の符号に応じて、diffマーカー列が削除され、追加または削除された行のみが保持されます。

@item @kbd{M-w} (@code{magit-copy-buffer-revision})
@kindex M-w
@findex magit-copy-buffer-revision
このコマンドは、現在のバッファに表示されているリビジョンを@code{kill-ring}に保存し、@code{magit-revision-stack}にもプッシュします。これは主に@code{magit-revision-mode}バッファでの使用を目的としています。これは、どのリビジョンを保存する必要があるかが常に明確である唯一のバッファです。

他のほとんどのMagitバッファは通常、何らかの方法で複数のリビジョンを表示するため、このコマンドはそれらの1つを選択する必要があり、その選択が常に最良の選択であるとは限りません。
@end table

Magitの外部では、@code{M-w}と@code{C-w}は通常@code{kill-ring-save}と@code{kill-region}にバインドされており、これらのコマンドはMagitバッファでも役立ちます。したがって、リージョンがアクティブな場合、これらのコマンドは両方とも、上記のようにではなく、@code{kill-ring-save}のように動作します。

@node Wip Modes
@section Wip Modes

Gitは、ユーザーが誤って削除した変更を復元するのに十分な時間、@strong{コミットされた変更}を保持します。これは、コミットされたが参照されなくなったオブジェクトを一定期間(デフォルトでは30日間)ガベージコレクションしないことによって行われます。

ただし、Gitは、作業ツリーのコミットされていない変更を追跡せず、インデックス(ステージ領域)も追跡しません。Magitを使用すると、コミットされていない変更を簡単に変更できるため、その過程で自分の足を簡単に撃つことができます(訳注:墓穴を掘るぐらいの意味)。

そのため、Magitは、特定のアクションの後または前に、追跡ファイル(tracked
files)を進行中のreferenceに保存するグローバルモードを提供します。(現在のところ、追跡されていないファイルは保存されず、技術的な理由から、最初のコミットが作成されるまでは何も保存されません)。

インデックスと作業ツリーの状態を追跡するために、2つの別々の進行中のrefernceが使用されます。それは@code{refs/wip/index/<branchref>}と@code{refs/wip/wtree/<branchref>}です。ここで@code{<branchref>}は現在のブランチの完全なrefで、例えば@code{refs/heads/master}です。@code{HEAD}がデタッチされると、@code{<branchref>}の替わりに@code{HEAD}が使用されます。

別のブランチをチェックアウトする(または@code{HEAD}をデタッチする)と、その後の変更では異なるwip refsが使用されます。

@defopt magit-wip-mode
このモードが有効になっている場合、コミットされていない変更は、必要に応じて(つまり、データ損失が発生する可能性がある場合)、専用の進行中のrefsにコミットされます。

この変数を直接設定しても効果はありません。カスタムインターフェイスを使用してこれを行うか、それぞれのモード関数を呼び出します。

歴史的な理由から、このモードは他の4つの@code{magit-wip-*}モードの上に実装されています。あなたが wip
refsが更新されるタイミングをより細かく制御したい場合は、これらのモードを個別に使用することもできます。しかし、それはお勧めしません。こちらを参照して下さい(@ref{Legacy
Wip Modes})。
@end defopt

ブランチとそのwip
refsのログを表示するには、コマンド@code{magit-wip-log}と@code{magit-wip-log-current}を使用します。これらのコマンドを使用するときは、@code{--graph}を使用する必要があります。

@deffn Command magit-wip-log
このコマンドは、ブランチとそのwip refsのログを表示します。負のプレフィックス引数を使用すると、worktree wip refs
のみが表示されます。

プレフィックス引数の絶対値は、表示される各wip
refsの「ブランチ」の数を制御します。これは、@code{magit-wip-merge-branch}の値が@code{nil}の場合にのみ関係します。
@end deffn

@deffn Command magit-wip-log-current
このコマンドは、現在のブランチとそのwip refs のログを表示します。負のプレフィックス引数を使用すると、worktree wip refs
のみが表示されます。

プレフィックス引数の絶対値は、表示される各wip
refsの「ブランチ」の数を制御します。これは、@code{magit-wip-merge-branch}の値が@code{nil}の場合にのみ関係します。
@end deffn

@table @asis
@item @kbd{X w} (@code{magit-reset-worktree})
@kindex X w
@findex magit-reset-worktree
このコマンドは、@code{HEAD}とインデックスをそのままにして、作業ツリーをユーザーから読み取られたコミットにリセットし、デフォルトでそのポイントのコミットにリセットします。

これを使用して、ファイルをwip ref
にコミットされた状態に復元できます。これにより、このコマンドを呼び出す前に存在していた可能性のあるステージされていない変更(unstaged
changes)がすべて破棄されることに注意してください(ただし、もちろん、作業ツリー wip refにコミットした後でのみ)。
@end table

注意:
@code{magit-wip-mode}を有効にしても、完全な保護にはならないことに注意してください。@code{magit-wip-mode}を使用しているにもかかわらず変更が失われる可能性が最も高いシナリオは、Emacsの外部で変更を加えてから、Emacsの外部でそれを破棄することです。そのようなシナリオのいくつかでは、EmacsパッケージであるMagitには、あなたが自分の足を撃つのを防ぐチャンスがありません。

Magitがwip
refsに変更をコミットしたかどうかわからない場合は、追跡されたすべてのファイルへのすべての変更がコミットされるように明示的に要求できます。

@table @asis
@item @kbd{M-x magit-wip-commit}
@findex magit-wip-commit
このコマンドは、追跡されたすべてのファイルに対するすべての変更を、インデックスおよび作業ツリーの進行中のrefsにコミットします。上記のモードと同様に、追跡されていないファイルはコミットされませんが、追跡されているすべてのファイルの変更がチェックされます。モードがEmacs/Magitの外部で行われた変更を見落としている可能性があると思われる場合は、このコマンドを使用します。
@end table

@defopt magit-wip-namespace
進行中の作業のrefsに使用される名前空間。スラッシュで終了する必要があります。wip
refsの名前は@code{<namespace>index/<branchref>}や@code{<namespace>wtree/<branchref>}です。@code{HEAD}がデタッチされているときにスナップショットが作成されると、@code{<branchref>}の代わりに@code{HEAD}が使用されます。
@end defopt

@defopt magit-wip-mode-lighter
@code{magit-wip--mode}のモードラインライター(lighter)。
@end defopt

@menu
* Wip Graph::                Wip Graph
* Legacy Wip Modes::         Legacy Wip Modes
@end menu

@node Wip Graph
@subsection Wip Graph

@defopt magit-wip-merge-branch
このオプションは、ブランチで新しいコミットが作成された後に、現在のブランチを wip refs にマージするかどうかを制御します。

nil以外でかつ現在のブランチに新しいコミットがある場合、新しいwipコミットを作成する前に、それがwip
refにマージされます。これにより、wip履歴の検査が容易になり、wipコミットがガベージコレクションされることはありません。

nilでかつ現在のブランチに新しいコミットがある場合、新しいwipコミットを作成する前に、wip
refがブランチの先端(tip)にリセットされます。この設定では、wipコミットは最終的にガベージコレクションされます。
@end defopt

@code{magit-wip-merge-branch}が@code{t}の場合、履歴は以下のようになります:

@example
  *--*--*--*--*--*       refs/wip/index/refs/heads/master
 /     /     /
A-----B-----C            refs/heads/master
@end example

@code{magit-wip-merge-branch}が@code{nil}の場合、実際のブランチでコミットを作成してから変更を加えると、wip
refが再作成され、新しいコミットからフォークされます。ただし、wip refs
の古いコミットは失われません。それらはまだreflogから入手できます。wip
refsのフォーク点がいつ変更されたかを簡単に確認できるように、"restart
autosaving"(自動保存の再開)というメッセージを含む追加のコミットが作成されます(以下の@code{xxO}コミットはそのような境界コミットです)。

開始時は

@example
      BI0---BI1    refs/wip/index/refs/heads/master
     /
A---B              refs/heads/master
     \
      BW0---BW1    refs/wip/wtree/refs/heads/master
@end example

で、ステージされた変更(staged changes)をコミットし、ファイルを編集して保存すると、以下のようになります。

@example
      BI0---BI1        refs/wip/index/refs/heads/master
     /
A---B---C              refs/heads/master
     \   \
      \   CW0---CW1    refs/wip/wtree/refs/heads/master
       \
        BW0---BW1      refs/wip/wtree/refs/heads/master@@@{2@}
@end example

インデックスwip
refのフォーク点は、何らかの変更が行われるまで変更されません。同様に、ブランチをチェックアウトしたり、コミットを作成したりしても、作業ツリーwip
refのフォーク点は変更されません。フォーク点は、それぞれのwip refにコミットする必要のある変更が実際に行われるまで調整されません。

@node Legacy Wip Modes
@subsection Legacy Wip Modes

@code{magit-wip-mode}モード(を参照)を使用してください。以下のモードは歴史的な事情で残されています。無視することをお勧めします。

以下の変数達を直接設定しても効果はありません。カスタムインターフェイスを使用してこれを行うか、それぞれのモード関数を呼び出します。

@defopt magit-wip-after-save-mode
このモードが有効になっている場合、Gitリポジトリで追跡されているファイルを訪問するバッファを保存すると、現在の状態が現在のブランチの作業ツリー wip
refにコミットされます。
@end defopt

@defopt magit-wip-after-apply-mode
このモードを有効にすると、Gitリポジトリで追跡されているファイルに変更を適用(つまり、ステージ、ステージ解除、discard、revert、regulary
apply)すると、現在の状態が現在のブランチのインデックスや作業ツリーのwip refsにコミットされます。
@end defopt

Emacsを使用してファイルを編集し、Magitを使用してGitと対話するだけの場合は、上記の2つのモードで、すべての変更を偶発的な損失から保護するのに十分なはずです。しかし、実際はそうではありません。以前の変更が失われる可能性のある変更を行う前に、wip
refsにコミットする2つの追加モードが存在します。

@defopt magit-wip-before-change-mode
このモードを有効にすると、特定のコマンドで、あなたが変更しようとしているファイルに既に存在する変更をコミットします。
@end defopt

@defopt magit-wip-initial-backup-mode
このモードを有効にすると、ファイルを訪問するバッファが作成されてから初めて保存される前に、ファイルの現在のバージョンがworktree wip
refにコミットされます。

これにより、@code{backup-buffer}が保存するのと同じバージョンのファイルがバックアップされます。@code{backup-buffer}はバックアップファイルを使用しますが、このモードは他のMagit
Wipモードで使用されるものと同じ worktree wip
refを使用します。@code{backup-buffer}と同様に、これは1回だけ実行されます。バッファを強制終了してファイルに再度訪問しない限り、Emacsセッションごとに1つのバックアップのみが作成されます。

このモードは、@code{backup-buffer}に影響を与える変数を無視し、その関数と一緒に使用できます。これは、Gitリポジトリで追跡されるファイルのみをバックアップするため推奨されます。
@end defopt

@defopt magit-wip-after-save-local-mode-lighter
@code{magit-wip-after-save-local-mode}のモードラインライター(lighter)。
@end defopt

@defopt magit-wip-after-apply-mode-lighter
@code{magit-wip-after-apply-mode}のモードラインライター(lighter)
@end defopt

@defopt magit-wip-before-change-mode-lighter
@code{magit-wip-before-change-mode}のモードラインライター(lighter)
@end defopt

@defopt magit-wip-initial-backup-mode-lighter
@code{magit-wip-initial-backup-mode}のモードラインライター(lighter)
@end defopt

@node Commands for Buffers Visiting Files
@section Commands for Buffers Visiting Files

ユーザーが@code{magit-define-global-key-bindings}を@code{nil}に設定しない限り、Magitはいくつかのグローバルキーバインディングを定義します。これには、@code{C-c
M-g}の@code{magit-file-dispatch}への結び付けが含まれます。@code{C-c
g}の方がはるかに優れたバインディングですが、@code{C-c
<letter>}名前空間はユーザー用に予約されているため、パッケージでの使用は許可されていません。@code {C-c
g}を使用する場合は、そのバインディングを自分で追加する必要があります。こちらも参照下さい(@ref{Default
Bindings})と(@ref{Key Binding Conventions,,,elisp,})

あなたがより良いバインディングを欲する場合、あなた自身で追加する必要があります:

@lisp
(global-set-key (kbd "C-c g") 'magit-file-dispatch)
@end lisp

以下に示すキーバインディングは、@code{magit-file-dispatch}のバインディングを改善していないことを前提としています。

@table @asis
@item @kbd{C-c M-g} (@code{magit-file-dispatch})
@kindex C-c M-g
@findex magit-file-dispatch
このトランジェント(一時的)プレフィックス(接頭辞)コマンドは、それに従うサフィックス(接尾辞)コマンド群を結びつけ、そのサフィックスコマンドのどれかを選ぶまでの間、サフィックス(接尾辞)コマンド群を一時バッファ(temporary
buffer)に表示します。

ファイルに訪問しないバッファで呼び出されると、通常の@code {magit-dispatch}にフォールバックします。

@item @kbd{C-c M-g s} (@code{magit-stage-file})
@kindex C-c M-g s
@findex magit-stage-file
現在のバッファが訪問しているファイルのすべての変更をステージします。

@item @kbd{C-c M-g u} (@code{magit-unstage-file})
@kindex C-c M-g u
@findex magit-unstage-file
現在のバッファが訪問しているファイルのすべての変更をステージ解除します。

@item @kbd{C-c M-g c} (@code{magit-commit})
@kindex C-c M-g c
@findex magit-commit
このトランジェントプレフィックスコマンドは、それに従うサフィックスコマンドと適切なインフィックス引数とともに結び付け、サフィックスコマンドを選ぶまでの間、そのサフィックスコマンドと適切なインフィックス引数を一時バッファに表示します(@ref{コミット開始})。

@item @kbd{C-c M-g D} (@code{magit-diff})
@kindex C-c M-g D
@findex magit-diff
このトランジェントプレフィックスコマンドは、いくつかのdiffサフィックスコマンドとインフィックス引数を結び付けし、サフィックスコマンドが呼び出されるまでそれらを一時バッファに表示します。参照(@ref{Diffing})

これは、@code{d}がMagitバッファで結び付けられているのと同じコマンドです。このコマンドがfile-visitingバッファから呼び出された場合、diffを特定のファイルに制限するオプション(@code{--})の初期値が訪問したファイルに設定されます。

@item @kbd{C-c M-g d} (@code{magit-diff-buffer-file})
@kindex C-c M-g d
@findex magit-diff-buffer-file
このコマンドは、現在のバッファが訪れるblobのファイルのdiffを表示します。
@end table

@defopt magit-diff-buffer-file-locked
このオプションは、@code{magit-diff-buffer-file}が専用のバッファを使用するかどうかを制御します。こちらを参照して下さい(@ref{Modes
and Buffers})。
@end defopt

@table @asis
@item @kbd{C-c M-g L} (@code{magit-log})
@kindex C-c M-g L
@findex magit-log
このトランジェントプレフィックスコマンドは、いくつかのログ用サフィックスコマンドとインフィックス引数を結び付け、サフィックスコマンドが呼び出されるまでそれらを一時バッファに表示します。参照(@ref{Logging})。

これは、@code{l}がMagitバッファで結び付けられているのと同じコマンドです。このコマンドがfile-visitingバッファから呼び出された場合、ログを特定のファイルに制限するオプション(@code{--})の初期値が訪問したファイルに設定されます。

@item @kbd{C-c M-g l} (@code{magit-log-buffer-file})
@kindex C-c M-g l
@findex magit-log-buffer-file
このコマンドは、現在のバッファが訪問するblobのファイルのログを表示します。プレフィックス引数が使用されている場合、または@code{--follow}がアクティブなログ引数である場合は、名前が変更されます。リージョンがアクティブな場合、ログは選択した行範囲に制限されます。

@item @kbd{C-c M-g t} (@code{magit-log-trace-definition})
@kindex C-c M-g t
@findex magit-log-trace-definition
このコマンドは、ポイントでの定義のログを表示します。
@end table

@defopt magit-log-buffer-file-locked
このオプションは、@code{magit-log-buffer-file}が専用のバッファを使用するかどうかを制御します。参照(@ref{Modes
and Buffers})。
@end defopt

@table @asis
@item @kbd{C-c M-g B} (@code{magit-blame})
@kindex C-c M-g B
@findex magit-blame
このトランジェントプレフィックスコマンドは、すべてのblameサフィックスコマンドを適切なインフィックス引数とともに結び付け、サフィックスコマンドが呼び出されるまで一時バッファに表示します。

このコマンドと以下のコマンドの詳細については、こちらを参照(@ref{Blaming})。
@end table

@code{magit-blame}サブトランジェントコマンドに加えて、ディスパッチトランジェントコマンドはいくつかのblameサフィックスコマンドを直接結び付けます。これらのコマンドとバインディングについては、こちらを参照して下さい(@ref{Blaming})。

@table @asis
@item @kbd{C-c M-g e} (@code{magit-edit-line-commit})
@kindex C-c M-g e
@findex magit-edit-line-commit
このコマンドは、現在の行を追加したコミットを編集可能にします。

プレフィックス引数を使用すると、コミットが編集可能になり、行がある場合は削除されます。コミットは@code{git
blame}を使用して決定され、@code{HEAD}から到達可能である場合は、@code{git rebase
--interactive}を使用して編集可能にするか、そうでない場合はコミット(またはそれを指すブランチ)をチェックアウトします。

@item @kbd{C-c M-g p} (@code{magit-blob-previous})
@kindex C-c M-g p
@findex magit-blob-previous
変更した現在のファイルの以前のBLOBを訪問します。
@end table

単一のファイルで動作するが、デフォルトではファイルトランジェントコマンドで有効になっていない追加のコマンドがいくつかあります:

@deffn Command magit-file-rename
このコマンドは、ユーザーから読み取ってファイルの名前を変更します。
@end deffn

@deffn Command magit-file-delete
このコマンドは、ユーザーから読み取ってファイルを削除します。
@end deffn

@deffn Command magit-file-untrack
このコマンドは、ユーザーから読み取られたファイルの追跡を解除(untrack)します。
@end deffn

@deffn Command magit-file-checkout
このコマンドは、作業ツリー内のファイルを更新し、リビジョンの内容にインデックスを付けます。リビジョンとファイルの両方がユーザーから読み取られます。
@end deffn

それらを有効にするには、トランジェントコマンド(@code{C-c M-g})を呼び出し、「編集モード」(@code{C-x
l})に入り、「トランジェントレベル」(再び@code{C-x
l})を設定し、@code{5}を入力し、編集モードを終了します(@code{C-g})。こちらも参照下さい(@ref{Enabling and
Disabling Suffixes,,,transient,})。

@node Minor Mode for Buffers Visiting Blobs
@section Minor Mode for Buffers Visiting Blobs

@code{magit-blob-mode}は、blob訪問バッファで特定のMagit機能を有効にします。このようなバッファは、@code{magit-find-file}と以下で説明するいくつかのコマンドを使用して作成できます。これらのコマンドは、このマイナーモードの開始も処理します。現在、このモードはいくつかのキーバインディングのみを確立しますが、これは拡張される可能性があります。

@table @asis
@item @kbd{p} (@code{magit-blob-previous})
@kindex p
@findex magit-blob-previous
変更した現在のファイルの以前のBLOBを訪問します。

@item @kbd{n} (@code{magit-blob-next})
@kindex n
@findex magit-blob-next
変更した現在のファイルの次のBLOBを訪問します。

@item @kbd{q} (@code{magit-kill-this-buffer})
@kindex q
@findex magit-kill-this-buffer
現在のバッファを強制終了します。
@end table

@node Customizing
@chapter Customizing

GitとEmacsはどちらも高度にカスタマイズ可能です。MagitはGit磁器であると同時にEmacsパッケージでもあるため、Git変数とEmacsオプションの両方を使用してカスタマイズすることは理にかなっています。ただし、この柔軟性には、以下のような問題もあります。

@itemize
@item
一部のGit変数は、明示的なサポートを必要とせずに、Magitで自動的に効果を発揮します。それが望ましい場合もあれば、一方でMagitを壊す場合もあります。

特定のGit設定がMagitを壊したが、コマンドラインでその設定を使い続けたい場合は、@code{magit-git-global-arguments}に@code{("-c"
"some.variable=compatible-value")}のようなものを追加してMagitの値をオーバーライドすることで実現できます。

@item
@code{fetch.prune=true}のような特定の設定は、(単にそれぞれのGitコマンドを呼び出すため)Magitコマンドによって尊重されますが、それらの値はそれぞれの一時バッファに反映されません。この場合、@code{magit-fetch}の@code{--prune}引数はアクティブまたは非アクティブである可能性がありますが、それでもGit変数がサフィックスコマンドによって尊重されることを妨げません。したがって、@code{--prune}引数が、pruningが発生しないことを示しているように見える方法で表示されているにもかかわらず、pruningが発生する可能性があります。
@end itemize

今後のリリースで、これらの問題や同様の問題に対処する予定です。

@menu
* Per-Repository Configuration::  Per-Repository Configuration
* 基本設定::             基本設定
@end menu

@node Per-Repository Configuration
@section Per-Repository Configuration

Magitは、Git変数とEmacsオプションの両方を使用して、リポジトリごとの設定を行う事ができます。

あるリポジトリのみのGit変数を設定するには、@code{$HOME/.gitconfig}や@code{/etc/gitconfig}の代わりに@code{/path/to/repo/.git/config}に設定するだけです。参照: 
@ifinfo
(@ref{git-config,,,gitman,})
@end ifinfo
@ifhtml
@c html
@c end html
the <a href="http://git-scm.com/docs/git-config">git-config(1)</a> manpage.
@end ifhtml
@iftex
the git-config(1) manpage.
@end iftex

同様に、Emacsオプションは、@code{/path/to/repo/.dir-locals.el}を編集することによってあるリポジトリのみに設定できます。こちらを参照して下さい(@ref{Directory
Variables,,,emacs,})。たとえば、1つの巨大なリポジトリでfile-visitingバッファの自動リフレッシュを無効にするには、以下を使用します:

@itemize
@item
@code{/path/to/huge/repo/.dir-locals.el}

@lisp
((nil . ((magit-refresh-buffers . nil))))
@end lisp
@end itemize

非常に大きなリポジトリのMagitバッファに特定の情報を挿入するのはコストがかかるかもしれません。その場合、そのようなリポジトリに対してのみそれぞれのセクションインサーターを無効にすることができます:

@itemize
@item
@code{/path/to/tag/invested/repo/.dir-locals.el}

@lisp
((magit-status-mode
  . ((eval . (magit-disable-section-inserter 'magit-insert-tags-header)))))
@end lisp
@end itemize

@defun magit-disable-section-inserter fn
この関数は、現在のリポジトリのセクションインサーターFNを無効にします。@code{.dir-locals.el}と@code{.dir-locals-2.el}のみでの使用を目的としています。
@end defun

すべてではありませんが複数のリポジトリに同じ設定を適用したい場合は、リポジトリローカル構成ファイルの同期を維持するのはすぐに面倒になります。これを回避するには、特定のクラスのリポジトリ(「巨大なリポジトリ」など)の構成ファイルを作成してから、それらのファイルをリポジトリごとの構成ファイルに含めることができます。
例えば:

@itemize
@item
@code{/path/to/huge/repo/.git/config}

@example
[include]
        path = /path/to/huge-gitconfig
@end example

@item
@code{/path/to/huge-gitconfig}

@example
[status]
        showUntrackedFiles = no
@end example

@item
@code{$HOME/.emacs.d/init.el}

@lisp
(dir-locals-set-class-variables 'huge-git-repository
   '((nil . ((magit-refresh-buffers . nil)))))

(dir-locals-set-directory-class
   "/path/to/huge/repo/" 'huge-git-repository)
@end lisp
@end itemize

@node 基本設定
@section 基本設定

次の2つの節は、安全性やパフォーマンス上の理由から、多くのユーザーがカスタマイズする可能性のあるいくつかの変数について説明します。

@menu
* Safety::                   Safety
* Performance::              Performance
* Default Bindings::         Default Bindings
@end menu

@node Safety
@subsection Safety

この節では、安全上の理由から変更する(または変更しない)可能性のあるさまざまな変数について説明します。

Gitは、ユーザーが誤って削除した変更を復元するのに十分な時間、コミットした変更を保持します。作業ツリーのコミットされていない変更に対しては同じことを行わず、インデックス(ステージ領域)に対しても同じことを行いません。Magitを使用すると、コミットされていない変更を簡単に変更できるため、その過程で自分の足を簡単に撃つことができます。そのため、Magitは、特定のアクションの前後に追跡されているファイルを進行中のreferenceに保存する3つのグローバルモードを提供します。こちらを参照して下さい(@ref{Wip
Modes})。

これらのモードは、パフォーマンス上の懸念から、デフォルトでは有効になっていません。
代わりに、破壊的な可能性のあるコマンドの多くは、使用するたびに確認が必要です。多くの場合、これは@code{magit-no-confirm}にシンボルを追加することで無効にできます(@ref{補完と確認})。
さまざまなwipモードを有効にする場合は、このリストに@code{safe-with-wip}を追加する必要があります。

同様に、ファイルをシステムのゴミ箱に移動する前に確認を要求する必要はありません。誤ってファイルをゴミ箱に移動した場合は、そこから回復できます。オプション@code{magit-delete-by-moving-to-trash}は、システムのゴミ箱を使用するかどうかを制御します。これはデフォルトの場合です。
それでも、@code{trash}は@code{magit-no-confirm}のメンバーではありません。あなたはこれを変更したいと思うかもしれません。

デフォルトでは、訪問したファイルがディスク上で変更されると、訪問したファイルは自動的revertされます。
これは見た目ほど危険ではありませんが、十分な情報に基づいて決定を下すには確認が必要です。こちらを参照して下さい(@ref{Risk of
Reverting Automatically})

@node Performance
@subsection Performance

Magitは副作用のために@code{git}を実行した後、現在のMagitバッファとそれぞれのステータスバッファもリフレッシュします。これが必要なのは、そうしないと、ユーザーが気付かないうちに古い情報が表示される可能性があるためです。Magitバッファは、コンテンツを最初から再作成することで更新されます。これにより、更新が簡単になり、エラーが発生しにくくなりますが、コストも高くなります。シンプルに保ち、すべてを最初から再作成することは古い設計上の決定であり、それから逸脱するには大規模なリファクタリングが必要になります。

次のメジャーリリースに間に合うようにそれを行う予定です。また、ログとdiffを非同期で作成する予定です。これも大いに役立つはずですが、大幅なリファクタリングも必要です。

一方、Magitに、現在のMagitバッファのみを自動的にリフレッシュするように指示できますが、ステータスバッファはリフレッシュできません。
これを行うと、ステータスバッファは、現在のバッファである場合にのみ自動的にリフレッシュされます。

@lisp
(setq magit-refresh-status-buffer nil)
@end lisp

また、サードパーティのパッケージが@code{magit-refresh-buffer-hook}と@code{magit-status-refresh-hook}と@code{magit-pre-refresh-hook}と@code{magit-post-refresh-hook}に何かを追加していないかどうかを確認する必要があります。その場合は、それらの追加がパフォーマンスに大きな影響を与えるかどうかを確認してください。

Magitは、@code{M-x
magit-toggle-verbose-refresh}を使用して詳細にバッファをリフレッシュするように指示できます。これを有効にすると、どのセクションがボトルネックであるかを把握するのに役立ちます。追加の出力は、@code{*Messages*}バッファにあります。

Magitは、訪問したファイルがディスク上で変更されると、現在のリポジトリ内にある訪問したファイルのバッファもrevertします。これは、組み込みライブラリ@code{autorevert}の@code{auto-revert-mode}の上に実装されています。それがパフォーマンスに影響を与えるかどうかを判断するには、多数のバッファが存在する場合、および/または一部のバッファがTRAMPを使用してファイルを訪問する場合に、パフォーマンスが大幅に低下するかどうかを確認します。
もしパフォーマンスに影響があるなら、この確認が役に立つはずです。

@lisp
(setq auto-revert-buffer-list-filter
      'magit-auto-revert-repository-buffer-p)
@end lisp

別のアプローチについては、こちらを参照(@ref{Automatic Reverting of File-Visiting Buffers})

あなたがデフォルトで無効になっている機能を有効にしている場合は、それらがパフォーマンスに大きな影響を与えるかどうかを確認する必要があります。少なくとも大規模なリポジトリではパフォーマンスが低下することがわかっているため、それらはデフォルトでは有効になっていない可能性があります。

特定の異常に大きなリポジトリ内でのみパフォーマンスが低下する場合は、リポジトリごとまたはリポジトリクラスごとにのみ特定の機能を無効にすることをお勧めします。こちらを参照して下さい(@ref{Per-Repository
Configuration})。たとえば、非常に多くのタグがあるリポジトリ内の次の現在のタグを判別するのに長い時間がかかります。したがって、前節で説明されているように、@code{magit-insert-tags-headers}を無効にすることをお勧めします。

@menu
* Microsoft Windows Performance::  Microsoft Windows Performance
* MacOS Performance::        MacOS Performance
@end menu

@anchor{Log Performance}
@subsubheading Log Performance

ログを表示するとき、Magitは、不要な作業を回避することを期待して、最初に表示されるコミットの数を制限します。@code{--graph}を使用する場合は、残念ながら、これは大きな履歴に対して望ましい効果をもたらしません。GitのメンテナであるJunioは、gitメーリングリスト(@uref{http://www.spinics.net/lists/git/msg232230.html})で次のように述べています。「@code{--graph}は履歴全体を計算したいと考えているので、max-countは、@code{--graph}が計算を行った後の出力フェーズにのみ影響します。」

言い換えれば、Gitが差分を出力するのが遅いということでも、Magitが出力を解析するのが遅いということでもありません。問題は、Gitが如何に早く狼煙を上げるかです。

実際には、@code{-<N>}を使用するだけでなく、範囲を使用してコミットの数を制限することで、この問題を回避しています。しかし残念ながら、それが常に可能であるとは限りません。

数千を超えるコミットが表示される場合、@code{--graph}を使用すると処理速度が低下する可能性があります。

@code{--color --graph}の使用はさらに遅くなります。
Magitは、Emacsの一部であるコードを使用して、制御文字をfaceに変換します。そのコードはかなり遅く、これは多くのブランチとマージを含むログを表示するときに非常に目立ちます。そのため、@code{--color}はデフォルトで有効ではなくなりました。そのままにしておくことを検討してください。

@anchor{Diff Performance}
@subsubheading Diff Performance

diffが遅い場合は、次の変数のすべてまたは一部を@code{nil}に設定して、オプションのdiff機能をオフにすることを検討してください:
@code{magit-diff-highlight-indentation}、@code{magit-diff-highlight-trailing}、@code{magit-diff-paint-whitespace}、@code{magit-diff-highlight-hunk-body}、@code{magit-diff-refine-hunk}.

任意のdiffの代わりにコミットを表示すると、いくつかの追加情報が表示されます。この情報の計算は、特定の状況を考えると非常にコストがかかる可能性があります。@code{magit-revision-mode}を使用してコミットを確認する方が、@code{magit-diff-mode}で同じコミットを確認するよりもかなり時間がかかる場合は、@code{magit-revision-insert-related-refs}を@code{nil}に設定することを検討してください。

あなたが削除されたファイルを含むdiffに頻繁に直面する場合は、@code{--irreversible-delete}引数を有効にすることをお勧めします。これを行うと、diffはファイルが削除されたことを示しはしますが、ファイルの完全に削除された内容の表示は行いません。この引数はデフォルトでは使用できません。こちらを参照して下さい(@ref{Enabling
and Disabling
Suffixes,,,transient,})。それが完了したら、それを有効にしてその設定を保存する必要があります。こちらを参照して下さい(@ref{Saving
Values,,,transient,})。これは、diff(@code{d})とdiff
refresh(@code{D})の両方のトランジェントポップアップで行う必要があります。

@anchor{Refs Buffer Performance}
@subsubheading Refs Buffer Performance

"references
buffer"のリフレッシュが遅い場合、それは通常、数百のrefsが表示されているためです。これに対処する最善の方法は、明らかに、表示するref数を減らすことです。

あなたがタグのリストを表示することに興味がない、または興味がほとんど無い場合は、タグを表示しないことから始めます。

@lisp
(remove-hook 'magit-refs-sections-hook 'magit-insert-tags)
@end lisp

それから、あなたはリストされているリモートブランチが実際にすべて存在することも確認する必要があります。これを行うには、@code{f-pa}を使用して存在しなくなったブランチをpruningします。

@anchor{Committing Performance}
@subsubheading Committing Performance

あなたがコミットを開始すると、Magitはデフォルトで、コミットしようとしている変更のdiffを自動的に表示します。大規模なコミットの場合、これには長い時間がかかる可能性があります。これは、コミットする前に実際に検査する予定のない大量の生成データをコミットする場合に特に気が散ります。この動作は、以下を使用してオフにできます:

@lisp
(remove-hook 'server-switch-hook 'magit-commit-diff)
@end lisp

それからあなたは、@code{C-c
C-d}と入力して、実際に見たいときにdiffを表示できますが、それはそのときだけです。またはフックはそのままにしておいて、diffの生成に時間がかかりすぎる場合に、@code{C-g}と入力することもできます。これを行うと、diffバッファが壊れてしまいますが、この方法で行うと、通常はdiffを確認できるという利点があります。これは、潜在的な問題を見つける可能性が高くなるため便利です。

@node Microsoft Windows Performance
@unnumberedsubsubsec Microsoft Windows Performance

ステータスバッファを更新するには、@code{git}を数十回実行する必要があります。これはMicrosoft
Windowsでは問題があります。なぜならこのオペレーティングシステムはプロセスの開始が非常に遅いためです。残念ながら、これはMicrosoft自身によってのみ修正できる問題であり、彼らはそうすることに特に関心を持っていないようです。

サブプロセスの問題の他に、Windows固有のパフォーマンスの問題もあります。これらのいくつかには回避策があります。"Git for
Windows"のメンテナは、Windowsのパフォーマンスを向上させようとしています。最新のパフォーマンス調整を利用するには、常に最新のリリースを使用してください。
Magitも、Windows固有の問題を回避しようとします。

一部の情報源によると、以下のGit変数を設定することも役立ちます。

@example
git config --global core.preloadindex true   # default since v2.1
git config --global core.fscache true        # default since v2.8
git config --global gc.auto 256
@end example

また、あなたはアンチウイルスプログラムがパフォーマンスに影響を与えているかどうかを確認すべきです。

@node MacOS Performance
@unnumberedsubsubsec MacOS Performance

Emacs
26.1より前は、macOSでは@code{fork}を使用して子プロセスが作成されていました。それは不必要にGUIリソースをコピーし、高コストです。その結果、DarwinではLinuxよりもフォークに約30倍の時間がかかり、Magitは多くの@code{git}プロセスを開始するため、かなりの違いが生じました。

したがって、あなたは少なくともEmacs
26.1を使用していることを確認してください。その場合、より高速な@code{vfork}が使用されます。(子プロセスの作成には、Linuxと比較してDarwinではまだ約2倍の時間がかかります。)
@footnote{詳細についてはこちらを参照してください
@uref{https://lists.gnu.org/archive/html/bug-gnu-emacs/2017-04/msg00201.html}}

@node Default Bindings
@subsection Default Bindings

@defopt magit-define-global-key-bindings
このオプションは、Magitが現在のセッションで初めて使用される前であっても、一部のMagitコマンドがグローバルキーマップに自動的にバインドされるかどうかを制御します。

この変数がデフォルト以外である、nilでない場合、以下のバインディングがグローバルキーマップに追加される可能性があります。

@multitable {aaaaaaaaa} {aaaaaaaaaaaaaaaaaaaaa}
@item @code{C-x g}
@tab @code{magit-status}
@item @code{C-x M-g}
@tab @code{magit-dispatch}
@item @code{C-c M-g}
@tab @code{magit-file-dispatch}
@end multitable

これらのバインディングは、@code{after-init-hook}の実行時に追加される場合があります。各バインディングは、その時点で他のキーが同じコマンドにバインドされておらず、他のコマンドが同じキーにバインドされていない場合にのみ追加されます。つまり、不要なバインディングや、他のバインディングと競合するバインディングの追加は避けようとしています。

上記のバインディングの追加は、@code{after-init-hook}が呼び出されて、ユーザーがinitファイルの任意の場所に変数を設定できるようになるまで遅延されます(@code{magit}がロードまたは自動ロードされる前に必ず設定する必要はありません)。競合する可能性のあるすべてのユーザーバインディングがすでに追加されている可能性を高めるためです。

この変数を設定するには、@code{setq}またはカスタムインターフェイスのいずれかを使用します。関数@code{customize-set-variable}を使用しないでください。使用すると、フォームが評価されるとすぐにMagitが読み込まれます(これは、カスタマイズされた変数を定義するライブラリを読み込まない@code{custom-set-variables}とは異なります)。

この変数をnilに設定しても、キーバインディングがすでに追加された後に設定しては効果はありません。

@code{C-c M-g}ではなく@code{C-c
g}を@code{magit-file-dispatch}にバインドすることをお勧めします。@code{C-c
g}の方がはるかに優れたバインディングですが、@code{C-c
<letter>}名前空間はユーザー専用に厳密に予約されています。Magitがデフォルトでそれを使用するのを妨げます。

@lisp
(global-set-key (kbd "C-c g") 'magit-file-dispatch)
@end lisp

こちらも参照下さい(@ref{Commands for Buffers Visiting Files})と(@ref{Key Binding
Conventions,,,elisp,})
@end defopt

@node 配管コマンド(Plumbing)
@chapter 配管コマンド(Plumbing)

以下の節では、Magitのコア部分の抽象化のいくつかを使用して、Magit自体を拡張する方法、または個別の拡張を実装する方法について説明します。

Magitで使用される低レベルの機能のいくつかは、個別の ライブラリ/パッケージ
に分解されているため、Magitに依存することなく他のパッケージで使用できます。@code{with-editor}についてはこちらを参照して下さい(@ref{Top,,,with-editor,})。
@code{transient}についてはこちらを参照して下さい(@ref{Top,,,transient,})。

独自のMagit拡張機能によって提供されるコマンドにバインドできる未使用のキーを見つけようとしている場合は、@uref{https://github.com/magit/magit/wiki/Plugin-Dispatch-Key-Registry}をチェックアウトしてください。

@menu
* Calling Git::              Calling Git
* Section Plumbing::         Section Plumbing
* Refreshing Buffers::       Refreshing Buffers
* 慣習::                   慣習
@end menu

@node Calling Git
@section Calling Git

Magitは、Gitを呼び出すための多くの特殊な関数を提供します。これらの関数はすべて、@code{magit-git.el}または@code{magit-process.el}のいずれかで定義され、接頭辞@code{magit-run-}または@code{magit-call-}または@code{magit-start-}または@code{magit-git-}のいずれかが付いています(@code{magit-git-}は他の目的にも使用されます)。

これらの関数はすべて、Git(または場合によっては任意の実行可能ファイル)のコマンドライン引数を指定する文字列である、無制限の数の引数を受け入れます。これらの引数は、実行可能ファイルに渡される前にフラット化(flattened)されます。したがって、文字列の代わりに、@code{nil}である文字列と引数のリストを黙って削除することもできます。これらの関数の一部は、これらのコマンドライン引数の前に単一の必須引数も必要とします。

大まかに言えば、これらの関数はGitを実行して、何らかの値を取得するか、副作用を検出します。値を返す関数は、Magitバッファにデータを取り込むために必要な情報を収集するのに役立ちますが、他の関数はMagitコマンドを実装するために使用されます。

値のみのグループの関数は常に同期的に実行され、リフレッシュをトリガーすることはありません。副作用グループの関数は、Gitを同期的に実行するか非同期的に実行するか、および実行可能ファイルの終了時にリフレッシュをトリガーするかどうかに応じて、さらにサブグループに分割できます。

@menu
* Getting a Value from Git::  Getting a Value from Git
* Calling Git for Effect::   Calling Git for Effect
@end menu

@node Getting a Value from Git
@subsection Getting a Value from Git

これらの関数は、値、終了ステータス、または出力を取得するためにGitを実行します。
もちろん、それらを使用して副作用のあるGitコマンドを実行することもできますが、それは避ける必要があります。

@defun magit-git-exit-code &rest args
ARGSを伴ったgitを実行し、そのexit codeを返します。
@end defun

@defun magit-git-success &rest args
ARGSを伴ってgitを実行し、exit codeが@code{0}ならば@code{t}を返し、exit
codeがそれ以外の場合は@code{nil}を返します。
@end defun

@defun magit-git-failure &rest args
ARGSを伴ってgitを実行し、exit codeが@code{1}ならば@code{t}を返し、exit
codeがそれ以外の場合は@code{nil}を返します。
@end defun

@defun magit-git-true &rest args
ARGSを伴ってgitを実行し、gitによって出力される最初の行が文字列"true"の場合は@code{t}を返し、それ以外の場合は@code{nil}を返します。
@end defun

@defun magit-git-false &rest args
ARGSを伴ってgitを実行し、gitによって出力される最初の行が文字列"false"の場合は@code{t}を返し、それ以外の場合は@code{nil}を返します。
@end defun

@defun magit-git-insert &rest args
ARGSを伴ってgitを実行し、その出力をポイントに挿入します。
@end defun

@defun magit-git-string &rest args
ARGSを伴ってgitを実行し、その出力の最初の行を返します。出力がない場合、または改行文字(newline
character)で始まる場合は、@code{nil}が返されます。
@end defun

@defun magit-git-lines &rest args
ARGSを伴ってgitを実行し、その出力を行のリスト(list)として返します。出力の空行は省略されます。
@end defun

@defun magit-git-items &rest args
ARGSを伴ってgitを実行し、nullで区切られた出力をリスト(list)として返します。空のアイテムは省略されます。

オプション@code{magit-git-debug}の値がnil以外で、gitがゼロ以外の終了ステータスで終了する場合は、エコー領域でそのことを警告し、現在のリポジトリのプロセスバッファにgitの標準エラーを含むセクションを追加します。
@end defun

@defun magit-process-git destination &rest args
別のプロセスでGitを同期的に呼び出し、終了コードを返します。DESTINATIONは、ファイルハンドラーがサポートされていることを除いて、@code{call-process}のように出力を処理する方法を指定します。呼び出し中はCygwinの「noglob」オプションを有効にし、unix
eol変換を保証します。
@end defun

@defun magit-process-file process &optional infile buffer display &rest args
別のプロセスでファイルを同期的に処理します。@code{process-file}と同じですが、呼び出し中はCygwinの「noglob」オプションを一時的に有効にし、unix
eol変換を保証します。
@end defun

上記の関数のいずれかを使用しているときにエラーが発生した場合、それは通常、バグが原因です。つまり、実際にはサポートされていない引数を使用しています。
このようなエラーは通常報告されませんが、発生した場合はデバッグできる必要があります。

@defopt magit-git-debug
@code{magit-git-insert}または@code{magit-git-string}または@code{magit-git-lines}または@code{magit-git-items}の使用時に発生するエラーを報告するかどうか。これは実際にはエラーを発生させません。代わりに、エコー領域にメッセージが表示され、gitの標準エラーが現在のリポジトリのプロセスバッファの新しいセクションに挿入されます。
@end defopt

@defun magit-git-str &rest args
これは、オプション@code{magit-git-debug}を無視する@code{magit-git-string}のバリエーションです。これは主に、そのオプションを尊重する関数のエラーを処理するときに使用することを目的としています。エラーの処理中にこのような関数を使用すると、さらに別のエラーが発生する可能性があるため、無限再帰が発生する可能性があります。おそらく、あなたは、この関数を使用する必要を感じないでしょう。
@end defun

@node Calling Git for Effect
@subsection Calling Git for Effect

これらの関数は、gitを実行して何らかの効果を生み出すために使用されます。実際にgitを実行するほとんどのMagitコマンドは、そのような関数を使用して実行します。

これらの関数を使用するときにgitの出力を消費する必要がないため、それらの出力は代わりにリポジトリごとのバッファに記録されます。これは、Magitバッファの@code{$}または、他の場所では@code{M-x
magit-process}を使用して表示できます。

これらの関数は、2つの異なる方法で効果を発揮する可能性があります。まず、gitを実行すると何かが変わる可能性があります。つまり、新しいコミットを作成またはプッシュします。
次に、その変更では、リポジトリの変更された状態を反映するためにMagitバッファをリフレッシュする必要がある場合があります。
ただし、リフレッシュが常に望ましいとは限らないため、gitが戻った後、これらの関数の一部のみがそのようなリフレッシュを実行します。

gitを非同期で実行すると便利な場合があります。たとえば、ユーザーがプッシュを開始したばかりの場合、それが完了するまでユーザーを待たせる理由はありません。それ以外の場合は、ユーザーに他のことをさせる前にgitが完了するのを待つのが理にかなっています。
たとえば、変更をステージした後は、自動的に次の行の変更に移動するため、リフレッシュが完了するまで待つと便利です。

@defun magit-call-git &rest args
ARGSを伴ってgitを同期的に呼び出します。
@end defun

@defun magit-call-process program &rest args
ARGSを伴って同期的にPROGRAMを呼び出します。
@end defun

@defun magit-run-git &rest args
ARGSを伴ってgitを同期的に呼び出し、それからリフレッシュします。
@end defun

@defun magit-run-git-with-input &rest args
ARGSを伴って同期的にgitを呼び出し、標準入力(standard input)で現在のバッファの内容を送信します。

現在のバッファの@code{default-directory}がリモートファイルシステム上にある場合、この関数は実際にはgitを非同期で実行します。ただし、プロセスが戻るのを待つため、関数自体は同期しています。
@end defun

@defun magit-git &rest args
副作用についてのみ、ARGSを伴って同期的にgitを呼び出します。この関数はバッファをリフレッシュしません。
@end defun

@defun magit-git-wash washer &rest args
ARGSを伴ってGitを実行して、洗浄された出力をポイントに挿入します。実際には、最初に生の出力をポイントに挿入します。出力がない場合は、@code{magit-cancel-section}を呼び出します。それ以外の場合は、挿入されたテキストのみ一時的にバッファをnarrowし、最初に移動してから、ARGSを唯一の引数として関数WASHERを呼び出します。
@end defun

以下は非同期バリエーションです。

@defun magit-run-git-async &rest args
Gitを開始(start)し、リフレッシュの準備をして、プロセスオブジェクトを返します。ARGSはフラット化され、Gitへの引数として使用されます。

エコー領域にコマンドライン引数を表示します。

Gitから戻った後、いくつかのバッファがリフレッシュされます。それは、この関数が呼び出されたときに現在のバッファ(Magitバッファであり、まだ生きている場合)と、それぞれのMagitステータスバッファです。@code{magit-revert-buffers}がnil以外の場合、現在のリポジトリで追跡されているファイルを訪問している変更されていないバッファはrevertされます。
@end defun

@defun magit-run-git-with-editor &rest args
GIT@math{_EDITOR}をエクスポートし、Gitを開始します。また、リフレッシュの準備をして、プロセスオブジェクトを返します。ARGSはフラット化され、Gitへの引数として使用されます。

エコー領域にコマンドライン引数を表示します。

Gitから戻った後、いくつかのバッファがリフレッシュされます。それは、この関数が呼び出されたときに現在のバッファ(Magitバッファであり、まだ生きている場合)と、それぞれのMagitステータスバッファです。
@end defun

@defun magit-start-git input &rest args
Gitを開始し、リフレッシュの準備をして、プロセスオブジェクトを返します。

INPUTがnilでない場合、それはバッファまたは既存のバッファの名前である必要があります。バッファの内容がプロセスの標準入力になります。

オプション@code{magit-git-executable}はGit実行可能ファイルを指定し、オプション@code{magit-git-global-arguments}は定数引数を指定します。残りの引数ARGSは、Gitへの引数を指定します。それらは使用前にフラット化されます。

Gitから戻った後、いくつかのバッファがリフレッシュされます。それは、この関数が呼び出されたときに現在のバッファ(Magitバッファであり、まだ生きている場合)と、それぞれのMagitステータスバッファです。@code{magit-revert-buffers}がnil以外の場合、現在のリポジトリで追跡されているファイルを訪問している変更されていないバッファはrevertされます。
@end defun

@defun magit-start-process &rest args
PROGRAMを開始し、リフレッシュの準備をして、プロセスオブジェクトを返します。

オプションの引数INPUTがnil以外の場合、それはバッファまたは既存のバッファの名前である必要があります。バッファの内容がプロセスの標準入力になります。

プロセスは@code{start-file-process}を使用して開始され、センチネル(番兵)
@code{magit-process-sentinel}とフィルター@code{magit-process-filter}を使用するようにセットアップされます。これらの関数に必要な情報は、プロセスオブジェクトに格納されます。この関数から戻ったとき、プロセスはまだ実行を開始していないため、センチネルとフィルターをオーバーライドすることができます。

プロセスから戻った後、@code{magit-process-sentinel}は、@code{magit-start-process}が呼び出されたときに現在のバッファ(Magitバッファであり、まだ生きている場合)と、それぞれのMagitステータスバッファをリフレッシュします。@code{magit-revert-buffers}がnil以外の場合、現在のリポジトリで追跡されているファイルを訪問している変更されていないバッファはrevertされます。
@end defun

@defvar magit-this-process
開始しようとしている子プロセス。これは、フィルターとセンチネル(番兵)を変更するために使用できます。
@end defvar

@defvar magit-process-raise-error
これがnil以外の場合、gitがゼロ以外の終了ステータスで終了すると、@code{magit-process-sentinel}はエラーを発生させます。これはデバッグ用です。
@end defvar

@node Section Plumbing
@section Section Plumbing

@menu
* Creating Sections::        Creating Sections
* Section Selection::        Section Selection
* Matching Sections::        Matching Sections
@end menu

@node Creating Sections
@subsection Creating Sections

@defmac magit-insert-section &rest args
ポイントにセクションを挿入します。

TYPEのセクションオブジェクトを作成し、その@code{value}スロットにVALUEを格納して、ポイントにセクションを挿入します。TYPEはセクションタイプで、シンボルです。現在のセクションに作用する多くのコマンドは、そのタイプに応じて異なる動作をします。また、変数@code{magit-TYPE-section-map}が存在する場合は、それをセクションに属するすべてのテキストのテキストプロパティ@code{keymap}として使用します(ただし、これはサブセクションで上書きされる場合があります)。
TYPEは、@code{(eval FORM)}の形式にすることもできます。この場合、FORMは実行時に評価されます。

オプションのVALUEはセクションの値であり、通常はセクションを操作するときに必要な文字列です。

オプションのHIDEがnil以外の場合、デフォルトでセクション本体を折りたたみます。つまり、それは最初にセクションを作成するときです。しかし、バッファをリフレッシュするときは折りたたみません。それ以外の場合は、デフォルトで展開します。これは、@code{magit-section-set-visibility-hook}を使用して上書きできます。リフレッシュ中にセクションが再作成されると、先行の可視性が継承され、HIDEは無視されます(ただし、フックは引き続き尊重されます)。

BODYは、セクションの見出しと本文を実際に挿入する任意の数のフォームです。オプションのNAMEを指定する場合は、シンボルにする必要があります。シンボルは、挿入されるセクションの構造体(struct)に結び付けられます。

BODYが評価される前に、セクションオブジェクトの@code{start}が@code{point}の値に設定され、BODYが評価された後、その@code{end}が@code{point}の新しい値に設定されます。
BODYは、@code{point}を前進させる責任があります。

セクションが空であることがBODY内で判明した場合は、@code{magit-cancel-section}を使用して、部分的に挿入されたセクションのすべてのトレースを中止して削除できます。これは、Gitの出力を洗浄(wash)してセクションを作成し、Gitが今回は実際には何も出力しなかった場合に発生する可能性があります。
@end defmac

@defun magit-insert-heading &rest args
現在挿入されているセクションの見出しを挿入します。

この関数は、@code{magit-insert-section}内でのみ使用する必要があります。

引数なしで呼び出された場合は、挿入されるセクションを表すオブジェクトの@code{content}スロットを@code{point}のマーカーに設定するだけです。この関数をこのように使用する場合、セクションには1行のみを含める必要があります。

文字列でなければならない引数ARGSを指定して呼び出された場合は、それらの文字列をポイントに挿入します。これが発生する前はセクションにテキストを含めないでください。その後、セクションには1行だけを含める必要があります。@code{face}プロパティがこれらの文字列のいずれかの内部のどこかに設定されている場合は、それらすべてを変更せずに挿入します。それ以外の場合は、挿入されたすべてのテキストに@code{magit-section-heading}
faceを使用します。

セクション構造体の@code{content}プロパティは、見出しの終わり(@code{start}から@code{content}まで続く)と本文の始まり(@code{content}から@code{end}まで続く)です。@code{content}の値がnilの場合、セクションには見出しがなく、本文を折りたたむことはできません。セクションに見出しがある場合、その高さは、末尾の改行文字を含めて、正確に1行である必要があります。これは強制されません。あなたはそれを正しくする責任があります。唯一の例外は、この関数が必要に応じて改行文字を挿入することです。
@end defun

@defun magit-cancel-section
現在挿入されているセクションをキャンセルします。これにより、@code{magit-insert-section}への最も内側の呼び出しが終了し、その呼び出し内ですでに発生したことのすべての痕跡が削除されます。
@end defun

@defun magit-define-section-jumper sym title &optional value
現在挿入されているセクションSYMをキャンセルします。
これにより、@code{magit-insert-section}への最も内側の呼び出しが終了し、その呼び出し内ですでに発生したことのすべての痕跡が削除されます。
@end defun

@node Section Selection
@subsection Section Selection

@defun magit-current-section
ポイントのセクションを返します。
@end defun

@defun magit-region-sections &optional condition multiple
選択したセクションのリストを返します。

リージョンがアクティブで、有効なセクション選択を構成している場合は、選択されたすべてのセクションのリストを返します。これは、領域がセクションの見出しで始まり、同じセクションまたは兄弟セクションの見出しで終わる場合です。オプションのMULTIPLEがnil以外の場合、領域は同じセクションで開始および終了できません。

選択が無効な場合は、nilを返します。この場合、選択したセクションに作用する可能性のあるほとんどのコマンドは、代わりにそのポイントのセクションに作用します。

領域が他のバッファにあるように見える場合、選択は無効です。選択が有効な場合、領域は@code{magit-section-highlight}
faceを使用します。これは、物事が少し複雑になるdiffには適用されませんが、ここでも、領域が通常のように見える場合でも、この関数に関する限り、これは有効な選択ではありません。

オプションのCONDITIONがnil以外の場合、選択は有効である必要があるだけではありません。選択したすべてのセクションは、さらにCONDITIONと一致する必要があります。一致しない場合、nilが返されます。CONDITIONが取ることができる形式については、@code{magit-section-match}を参照してください。
@end defun

@defun magit-region-values &optional condition multiple
選択したセクションの値のリストを返します。

@code{magit-region-sections}(を参照)によって返される値を返します。
@end defun

@node Matching Sections
@subsection Matching Sections

@table @asis
@item @kbd{M-x magit-describe-section-briefly}
@findex magit-describe-section-briefly
ポイントのセクションに関する情報を表示します。このコマンドは、デバッグを目的としています。
@end table

@defun magit-section-ident section
SECTIONの一意のIDを返します。戻り値の形式は@code{((TYPE . VALUE)...)}です。
@end defun

@defun magit-get-section ident &optional root
IDENTで識別されるセクションを返します。IDENTは、@code{magit-section-ident}によって返されるリストである必要があります。
@end defun

@defun magit-section-match condition &optional section
SECTIONがCONDITIONと一致する場合は、@code{t}を返します。SECTIONは、デフォルトでポイントのセクションになります。SECTIONが指定されておらず、ポイントにもセクションがない場合は、@code{nil}を返します。

CONDITIONは、以下の形式をとることができます:
@itemize
@item
@code{(CONDITION...)}

上記のCONDITIONのいずれかが一致する場合に一致します。

@item
@code{[CLASS...]}

セクションのクラスが最初のCLASSまたはそのサブクラスと同じである場合に一致します。セクションの親クラスは2番目のCLASSと一致します。以下同様。

@item
@code{[* CLASS...]}

@code{[CLASS...]}に一致するセクションと、それらのすべての子セクションを再帰的に一致させます。

@item
@code{CLASS}

セクションのクラスがCLASSまたはそのサブクラスと同じである場合に一致します。親セクションのクラスに関係なくです。
@end itemize

各CLASSは、@code{magit-section}から派生したクラスを識別するクラスシンボルである必要があります。下位互換性のために、CLASSは「タイプシンボル」にすることもできます。@code{type}スロットの値が@code{eq}の場合、セクションはそのようなシンボルに一致します。タイプシンボルの@code{magit--section-type-alist}にエントリがある場合、そのクラスがそのalistのタイプに対応するクラスのサブクラスであれば、セクションもそのタイプに一致します。

注意:
もちろん、正確にしたい場合を除いて、@code{magit-describe-section-briefly}によって出力される完全なセクション系統を指定する必要はないことに注意してください。
@end defun

@defun magit-section-value-if condition &optional section
ポイントのセクションがCONDITIONと一致する場合は、その値を返します。

オプションのSECTIONがnil以外の場合は、代わりにそれが一致するかどうかをテストします。ポイントにセクションがなく、SECTIONがnilの場合は、nilを返します。
セクションが一致しない場合は、nilを返します。

CONDITIONが取ることができる形式については、@code{magit-section-match}を参照してください。
@end defun

@defun magit-section-case &rest clauses
ポイントのセクションのタイプに関する条項(clauses)から選択します。

各句は(CONDITION
BODY@dots{})のようになります。セクションのタイプは、各条件と比較されます。最初の一致のBODYフォームが順番に評価され、最後のフォームの値が返されます。BODY内では、シンボル@code{it}がポイントのセクションに結び付けられています。句が成功しない場合、またはポイントにセクションがない場合は、nilを返します。

CONDITIONが取ることができる形式については、@code{magit-section-match}を参照してください。さらに、@code{t}のCONDITIONは最後の節で許可され、他のCONDITIONが一致しない場合は、ポイントにセクションがない場合でも一致します。
@end defun

@defvar magit-root-section
現在のバッファのルートセクション。他のすべてのセクションは、このセクションの子孫です。この変数の値は@code{magit-insert-section}によって設定されるため、変更しないでください。
@end defvar

diff関連のセクションには、いくつかの追加ツールがあります。

@defun magit-diff-type &optional section
別のタイプのSECTIONを返します。

返されるタイプは、@code{staged}または@code{unstaged}または@code{committed}または@code{undefined}のいずれかのシンボルです。このタイプは、すべてのセクションに共通の一般的なタイプ(対応する@code{magit-section}構造体の@code{type}スロットに格納されます)と同様の目的を果たしますが、追加情報を考慮に入れます。SECTIONがdiffに関連しておらず、それを含むバッファもdiffのみのバッファではない場合は、nilを返します。

現在、タイプは@code{tracked}と@code{untracked}のいずれかになりますが、これらの値は、本来あるべきすべての場所で明示的に処理されるわけではありません。考えられる修正は、ここでnilを返すことです。

セクションは、@code{diff}または@code{hunk}セクション、または子のタイプが@code{diff}であるセクションである必要があります。オプションのSECTIONがnilの場合、現在のセクションのdiffタイプを返します。メジャーモードが@code{magit-diff-mode}であるバッファでは、SECTIONは無視され、タイプは他の手段を使用して決定されます。@code{magit-revision-mode}バッファでは、タイプは常に@code{committed}です。
@end defun

@defun magit-diff-scope &optional section strict
SECTIONの別のスコープまたは選択したセクション達を返します。

diffの「スコープ」は、diffのどの部分が選択されているかを示します。これは、@code{region}または@code{hunk}または@code{hunks}または@code{file}または@code{files}または@code{list}のいずれかのシンボルです。@code{magit-diff-type}によって返されるdiffの"type"とこれを混同しないでください。

オプションのSECTIONがnil以外の場合は、リージョンによって選択されたセクションを無視して、そのスコープを返します。それ以外の場合は、現在のセクションのスコープを返します。または、リージョンがアクティブで、diff関連セクションの有効なグループを選択した場合は、これらのセクションのタイプ、つまり@code{hunks}または@code{files}を返します。SECTION(または現在のセクションがnil)が@code{hunk}セクションであり、リージョンがそのセクションの本体内で開始および終了する場合、タイプは@code{region}です。

オプションのSTRICTがnil以外の場合、ポイントのセクションのdiffタイプが@code{untracked}であるか、ポイントのセクションが実際には@code{diff}ではなく@code{diffstat}セクションである場合は、nilを返します。
@end defun

@node Refreshing Buffers
@section Refreshing Buffers

新しいMagitバッファを作成したり、既存のバッファに表示されているものを変更したりするすべてのコマンドは、@code{magit-mode-setup}を呼び出すことによって行います。
特に、この関数は、@code{default-directory}(リポジトリの最上位)と@code{magit-refresh-function}と@code{magit-refresh-args}のバッファローカル値を設定します。

バッファは、@code{magit-refresh-args}の値を引数として@code{magit-refresh-function}(@code{magit-*-refresh-buffer}という名前の関数。@code{*}の部分は@code{diff}のようなのが入ります)のローカル値である関数を呼び出すことによってリフレッシュされます。

@defmac magit-mode-setup buffer switch-func mode refresh-func &optional refresh-args
この機能は、BUFFERを表示および選択し、MODEをオンにして、最初にリフレッシュします。

この関数は、引数としてBUFFERとMODEとSWITCH-FUNCを指定して@code{magit-mode-display-buffer}を呼び出すことにより、BUFFERを表示し、オプションでBUFFERを選択します。次に、@code{magit-refresh-function}のローカル値をREFRESH-FUNCに設定し、@code{magit-refresh-args}のローカル値をREFRESH-ARGSに設定します。最後に、引数としてREFRESH-ARGSを指定してREFRESH-FUNCを呼び出すことにより、バッファ内容を作成します。

BUFFERに切り替える前に、すべての引数が評価されます。
@end defmac

@defun magit-mode-display-buffer buffer mode &optional switch-function
この機能は、あるウィンドウにBUFFERを表示してそのウインドウを選択します。BUFFERは、バッファまたは文字列、つまりバッファの名前の場合があります。バッファを返します。

選択したフレームにBUFFERがすでに表示されていない限り、前のウィンドウ構成をバッファローカル値として保存し、後で@code{magit-mode-bury-buffer}で復元できるようにします。

バッファが表示され、SWITCH-FUNCTIONを使用してそのバッファが選択されます。それが@code{nil}の場合、現在のバッファのメジャーモードが@code{magit-mode}から派生していれば、@code{pop-to-buffer}が使用されます。それ以外の場合は、@code{switch-to-buffer}が使用されます。
@end defun

@defvar magit-refresh-function
このバッファローカル変数の値は、現在のバッファをリフレッシュするために使用される関数です。@code{magit-refresh-args}を引数として呼び出されます。
@end defvar

@defvar magit-refresh-args
@code{magit-refresh-function}が現在のバッファを更新するために使用する引数のリスト(list)。@code{magit-refresh-function}は、これらの引数を使用して呼び出されます。

通常、値は@code{magit-mode-setup}を使用して設定されますが、値を変更できるコマンドを提供すると便利な場合もあります。たとえば、@code{magit-diff-refresh}トランジェントコマンドを使用すると、どのdiffを表示するかを再度指定しなくても、diffの表示に使用される引数を変更できますが、@code{magit-diff-more-context}と@code{magit-diff-less-context}と@code{magit-diff-default-context}は、@code{-U<N>}引数のみを変更します。どちらの場合も、これはこの変数の値を変更してから、この@code{magit-refresh-function}を呼び出すことによって行われます。
@end defvar

@node 慣習
@section 慣習

こちらもご覧ください(@ref{補完と確認})。

@menu
* Theming Faces::            Theming Faces
@end menu

@node Theming Faces
@subsection Theming Faces

デフォルトのテーマでは、ローカルブランチに青色、リモートブランチに緑色、タグにgoldenrod色(茶色がかった黄色;訳注:#daa520)を使用します。新しいテーマを作成するときは、おそらくその例に従う必要があります。テーマがすでに他の色を使用している場合は、それに依ります。

以前のリリースでは、これらの reference
faceには背景色とその周囲のボックスがありました。基本的なデフォルトのfaceは、Magitバッファのノイズを大幅に減らすために、もはやそうしていません。少なくともボックスに関しては、その例に従う必要があります。(ボックスは、ハイライトオーバーレイとテキストプロパティの背景の間の競合を回避するために過去に使用されていました。ハイライトによって他の背景色が消えることがなくなったため、これは不要になりました)。または、背景色やボックスを保持することもできますが、次に、それに応じて@code{magit-branch-current}を調整するために特別な注意を払う必要があります。デフォルトでは、ほとんど@code{magit-branch-local}のように見えますが、ボックスがあります(デフォルトでは、前者がボックスを使用する唯一のfaceであり、正確に突き出ています(stick
out))。前者もボックスを使用する場合は、後者とは別の方法で異なることを確認する必要があります。

テーマにするのが最も難しいfaceは、diff、見出し、ハイライト、およびリージョンに関連するfaceです。4つのグループすべてに分類されるfaceがあります。これを正すためにはまだしばらくのお時間を頂きたいと思います。

デフォルトのテーマの@code{region}のfaceは、明るいバリエーションと暗いバリエーションの両方、およびEmacsやサードパーティによって配布されている他の多くのテーマでは非常に醜いです。本当に目立つ背景色を使用するのが一般的です。これは醜いですが、それが唯一の問題である場合は許容されます。残念ながら、多くのテーマは前景色も設定しているため、領域内のすべてのテキストが読みやすくなっています。そうしないと、前景色が領域の背景色に近すぎて読めない場合があります。ただし、リージョン内のテキストでは構文の強調表示がすべて失われることも意味します。

@code{region}のfaceを正しくするために行われた作業は、テーマの一般的な品質の良い指標であると思います。@code{region}のfaceの推奨事項は、次のとおりです:
@code{default}のfaceの背景色とは少し異なる背景色を使用し、前景色をまったく設定しないでください。したがって、明るいテーマの場合、@code{default}の背景色として明るい(おそらく色付きの)灰色を使用し、@code{region}の背景としてやや暗い灰色を使用する場合があります。これは通常、他のfaceの前景色と衝突しないようにするには十分なはずです。ただし、他のfaceでも背景色として明るい灰色が設定されている場合は、それらのfaceと衝突しないようにする必要があります(ただし、許容できる場合もあります)。

Magitは、リージョンが独自の定義で「無効」である場合にのみ@code{region}のfaceを使用します。Magitバッファでは、領域を使用して複数の兄弟セクションを選択し、それをサポートするコマンドが現在のセクションだけでなくこれらすべてのセクションに作用するようにするか、単一のハンクセクション内の行を選択します。
他のすべての場合、セクションは無効と見なされ、Magitはそれに基づいて行動しません。
しかし、そのような無効なセクションは、ユーザーがポイントを有効にするのに十分な位置に移動していないか、非magitコマンドを使用して領域を操作したいために発生します。例:
@code{kill-region}

したがって、無効なセクションに通常の@code{region}のfaceを使用するのは仕様(feature)です。これは、Magitがそれに基づいて行動することができないことをユーザーに伝えます。そのfaceが少し奇妙に見えても(ただしそれほどではありませんが)、セクション見出しの背景色や背景色を持つ他のものと衝突する場合は許容されます。

Magitは現在のセクションを強調表示します。セクションにサブセクションがある場合、それらすべてが強調表示されます。これは、名前に"highlight"が含まれているfaceを使用して行われます。ほとんどのセクションでは、@code{magit-section-highlight}が本文と見出しの両方に使用されます。@code{region}のfaceと同様に、背景色を@code{default}と同様に設定する必要があります。ハイライトの背景色は、@code{region}の背景色と@code{default}の背景色の両方とは異なる必要があります。

diff関連セクションの場合、Magitはさまざまなfaceを使用して、選択したセクションのさまざまな部分を強調表示します。ハンクの見出しは、他のすべてのセクションの見出しとは異なり、デフォルトで背景色になっていることに注意してください。ハンクの間に非常に目立つ区切り記号があると便利だからです。そのfaceの@code{magit-diff-hunk-heading}は、@code{magit-diff-hunk-heading-highlight}と@code{magit-section-highlight}の両方、および@code{magit-diff-context}と@code{magit-diff-context-highlight}とは異なる必要があります。デフォルトでは、前景色を変更することでこれを行います。
背景色を変更すると複雑になり、回避できないものはすでに十分にあります。(また、セクションの見出しは常に太字にすることをお勧めしますが、サブセクションがあるセクションの場合のみです)。

diff関連の兄弟セクション、つまり複数のファイルまたはハンクを選択する有効な領域がある場合、これらすべてのセクションの本文はそれぞれのハイライトfaceを使用しますが、見出しは代わりに
@code{magit-diff-file-heading-selection} face または
@code{magit-diff-hunk-heading-selection} face
のどちらかを使用します。これらのfaceは、領域がアクティブであることを明確に視覚的に示すために、通常のハイライトバリエーションとは異なる必要があります。

diff関連のfaceにテーマを設定するときは、オプション@code{magit-diff-refine-hunk}を@code{all}に設定することから始めます。個人的には、現在のハンクのみを改良するか、ハンクの改良をまったく使用しないことを好むかもしれません。しかし、テーマのユーザーの中には、すべてのハンクを改良することを望んでいる人がいるため、それに対応する必要があります。

(また、@code{magit-diff-highlight-indentation}と@code{magit-diff-highlight-trailing}と@code{magit-diff-paint-whitespace}をオンにして、コードに空白エラー(some
whitespace errors)を挿入します。テストに使用します。)

追加された行については、@code{magit-diff-added}と@code{magit-diff-added-highlight}と@code{smerge-refined-added}の3つのfaceを調整する必要があります。後者が前者の両方、および@code{smerge-other}と@code{diff-added}でうまく機能することを確認してください。次に、削除された行、コンテキスト行、追加された行、およびそれらによって追加された行についても同じようにします。また、追加、削除、およびコンテキストのそれぞれのfaceが、強調表示されたバリエーションと強調表示されていないバリエーションの両方でほぼ同じ彩度を使用していることを確認してください。また、ファイルとdiffの見出しがコンテキスト行とうまく機能することを確認します(たとえば、見た目を変えます)。線のfaceは、前景色と背景色の両方を設定する必要があります。たとえば、追加された行には、2つの異なる緑色を使用します。

これはハイライトされたバリエーションとハイライトされていないバリエーションの両方の前景色が同じである場合に最適です。したがって、ハイライトとハイライトされていない背景、リファインされた背景、およびハイライトコンテキストの背景で適切に機能する色を見つける必要があります。ハンクの内部領域がある場合、追加行と削除行の背景色はその領域内でのみ使用されます。領域外では、強調表示されたコンテキストの背景色が使用されます。これにより、何がステージされているかを簡単に確認できます。ハンクの内部領域では、ハンクの見出しは@code{magit-diff-hunk-heading-selection}を使用して表示され、領域内にある線の周りに追加される細い線も同様です。その背景色は、他のさまざまな関連する背景色と十分に区別する必要があります。

これを行うのは簡単ではありません。テーマが特定の色のセットに制限されている場合は、ここで例外を作成する必要があります。そうでなければ、すべてのバリエーションでdiffの見栄えを良くすることは不可能です。実際には、これらのfaceのデフォルトの定義に固執したい場合があります。警告します！
正しく行わないと、ユーザーからはMagitのバグのように見える場合があることに注意してください。正しく行うか、まったく行わないでください。

@node FAQ
@appendix FAQ

以下の2つ節には、よくある質問が一覧表示してあります。@strong{よくある最近}の質問、つまりまだマニュアルに記載されていない質問のリストについては→@uref{https://github.com/magit/magit/wiki/FAQ}

どうぞこちらご覧下さい @ref{Debugging Tools}

@menu
* FAQ - How to @dots{}?::    FAQ - How to @dots{}?
* FAQ - Issues and Errors::  FAQ - Issues and Errors
@end menu

@node FAQ - How to @dots{}?
@appendixsec FAQ - How to @dots{}?

@menu
* Magitの発音は？::     Magitの発音は？
* How to show git's output?::  How to show git's output?
* How to install the gitman info manual?::  How to install the gitman info 
                                              manual?
* How to show diffs for gpg-encrypted files?::  How to show diffs for 
                                                  gpg-encrypted files?
* How does branching and pushing work?::  How does branching and pushing 
                                            work?
* VCを無効にする必要がありますか？::  VCを無効にする必要がありますか？
@end menu

@node Magitの発音は？
@appendixsubsec Magitの発音は？

発音は@code{mu[m's] git}または@code{magi@{c => t@}}のいずれかで問題ありません。

スローガンは "It's Magit! The magical Git client"
なので、magiCとmagiTが同じように聞こえないことを考慮しながら、Magitをmagic(魔法)のように発音するのは理にかなっています。(訳注「マジット」)

ドイツ語の"Magie"は英語の"magic"と同じ発音ではないため、ドイツ語を話す場合は、上記の合理性を使用して前者の発音を使用することを正当化できます。@code{Mag@{ie
=> it@}}

以前の発音が好きだからと、前者の発音を使用してもかまいません。

参照 @uref{https://magit.vc/assets/videos/magic.mp4}(訳注:2021年現在ファイルが存在しない模様)。
こちらもご覧ください@uref{https://emacs.stackexchange.com/questions/13696}

@node How to show git's output?
@appendixsubsec How to show git's output?

最近実行されたgitコマンドの出力を表示するには、@code{$}(または、それが利用できない場合は@code{M-x
magit-process-buffer})を押します。これにより、git呼び出しごとのセクションを含むバッファが表示されます。いつものように@code{TAB}を押して展開または折りたたみできます。

デフォルトでは、gitの出力は、副作用の目的のために実行された場合にのみプロセスバッファに挿入されます。出力が何らかの方法で消費される場合、それをプロセスバッファに挿入することもコストがかかりすぎます。デバッグの目的で、@code{magit-git-debug}を@code{t}に設定することで、とにかくそうすることができます。

@node How to install the gitman info manual?
@appendixsubsec How to install the gitman info manual?

Gitのmanpage達は、@code{gitman}というinfoマニュアルとしてエクスポートできます。Infoはmampageへのリンクをサポートしていないため、Magit独自のinfoマニュアルは実際のmanpageではなくそのマニュアルのノードにリンクしています。

残念ながら、一部のディストリビューションではデフォルトで@code{gitman}マニュアルがインストールされていないため、入手するには別のドキュメントパッケージをインストールする必要があります。

Magitは、それぞれのmanpageを表示する代わりに、@code{gitman}
infoマニュアルへのリンクを訪問する機能を追加するInfoにパッチを適用します。そのアプローチを好む場合は、@code{magit-view-git-manual-method}の値をサポートされているパッケージ@code{man}または@code{woman}のいずれかに設定します。例:

@lisp
(setq magit-view-git-manual-method 'man)
@end lisp

@node How to show diffs for gpg-encrypted files?
@appendixsubsec How to show diffs for gpg-encrypted files?

Gitは暗号化されたファイルのdiffの表示をサポートしていますが、そうするように指示する必要があります。MagitはGitを使用してdiffを取得するだけなので、Gitを設定すると、Magit内に表示されるdiffにも影響します。

@example
git config --global diff.gpg.textconv "gpg --no-tty --decrypt"
echo "*.gpg filter=gpg diff=gpg" > .gitattributes
@end example

@node How does branching and pushing work?
@appendixsubsec How does branching and pushing work?

こちらをご覧ください @ref{Branching} と @uref{http://emacsair.me/2016/01/18/magit-2.4}

@node VCを無効にする必要がありますか？
@appendixsubsec VCを無効にする必要がありますか？

あなたはVC(組み込みのバージョン管理インターフェイス)を使用しない場合、あなたは特に、VCを使用することを推奨していたため、無効にしたくなるかもしれません。

我々は、あなたがVCを無効にすることはお勧めしません。これを行うと、有効になっているVCに依存する便利なサードパーティパッケージ(@code{diff-hl}など)が破損します。

あなたがとにかくVCを無効にすることを選択した場合は、@code{vc-handled-backends}の値を変更することで無効にできます。

@node FAQ - Issues and Errors
@appendixsec FAQ - Issues and Errors

@menu
* Magit is slow::            Magit is slow
* I changed several thousand files at once and now Magit is unusable::  I 
                                                                          changed 
                                                                          several 
                                                                          thousand 
                                                                          files 
                                                                          at 
                                                                          once 
                                                                          and 
                                                                          now 
                                                                          Magit 
                                                                          is 
                                                                          unusable
* コミットに問題があります::  コミットに問題があります
* MS WindowsではMagitでpushできません::  MS 
                                                   WindowsではMagitでpushできません
* 私は macOS を使用しています。その何かはシェルでは動きますが、Magitでは動きません: 私は macOS を使用しています。その何かはシェルでは動きますが、Magitでは動きません.  私は 
                                                                                                                                                                                                                                             macOS 
                                                                                                                                                                                                                                             を使用しています。その何かはシェルでは動きますが、Magitでは動きません: 
                                                                                                                                                                                                                                             私は 
                                                                                                                                                                                                                                             macOS 
                                                                                                                                                                                                                                             を使用しています。その何かはシェルでは動きますが、Magitでは動きません
* ファイルを展開してdiffを表示するとファイルが消えます::  ファイルを展開してdiffを表示するとファイルが消えます
* @code{COMMIT_EDITMSG}バッファのpointが間違っています::  @code{COMMIT_EDITMSG}バッファのpointが間違っています
* モード行の情報が常に最新ではない::  モード行の情報が常に最新ではない
* 同じ名前を共有するブランチとタグは何かを壊します::  同じ名前を共有するブランチとタグは何かを壊します
* 私のGitフックはコマンドラインでは機能しますが、Magit内では機能しません::  私のGitフックはコマンドラインでは機能しますが、Magit内では機能しません
* コマンドラインからコミットする場合、@code{git-commit-mode}は使用されません::  コマンドラインからコミットする場合、@code{git-commit-mode}は使用されません
* file-visitingバッファにジャンプすると、ポイントは非表示のテキスト内にあります::  file-visitingバッファにジャンプすると、ポイントは非表示のテキスト内にあります
* MS-WindowsからEmacsのTrampモードを使用するとステージできません::  MS-WindowsからEmacsのTrampモードを使用するとステージできません
* 私はポップアップのデフォルトを保存できなくなりました::  私はポップアップのデフォルトを保存できなくなりました
@end menu

@node Magit is slow
@appendixsubsec Magit is slow

@ref{Performance} や @ref{I changed several thousand files at once and now
Magit is unusable} を参照してください。

@node I changed several thousand files at once and now Magit is unusable
@appendixsubsec I changed several thousand files at once and now Magit is unusable

(一度に数千のファイルを変更したら、Magit が使用できなくなりました)Magit は現在、このような状況下ではうまく機能しないと予想されます。
ちゃんと動くと素敵ですよね。 このような条件下で満足のいくパフォーマンスを達成するには、かなりのリファクタリングが必要になります。
これは簡単な作業ではありませんが、最終的には時間を見つけて実現したいと考えています。

ただし、今のところは、コマンドラインを使用してこのコミットを完了することをお勧めします。こちらも参照して下さい(@ref{Performance})。

@node コミットに問題があります
@appendixsubsec コミットに問題があります

これは、Magitが適切なemacsclient実行可能ファイルを見つけるのに問題があることを意味している可能性があります(@ref{Configuring
With-Editor,,,with-editor,} and @ref{Debugging,,,with-editor,})。

@node MS WindowsではMagitでpushできません
@appendixsubsec MS WindowsではMagitでpushできません

Magitにありがちな問題であることはほぼ確実です。あなたがコマンドラインでpushできる場合、構成(configuration)の問題である可能性が限りなく高いです。

詳細なセットアップ手順は、@uref{https://github.com/magit/magit/wiki/Pushing-with-Magit-from-Windows}にあります。

@node 私は macOS を使用しています。その何かはシェルでは動きますが、Magitでは動きません
@appendixsubsec 私は macOS を使用しています。その何かはシェルでは動きますが、Magitでは動きません

これは通常、Emacsがシェルと同じ環境変数を持っていないために発生します。@uref{https://github.com/purcell/exec-path-from-shell}をインストールして設定してみてください。デフォルトでは、@code{$PATH}を同期します。これにより、Magitはシェルで使用しているものと同じ@code{git}を見つけることができます。

SOMETHINGが「コミットおよび/またはタグ署名のためのgpg-agentを使用したパスフレーズキャッシング」("passphrase
caching with gpg-agent for commit and/or tag
signing")である場合、あなたは@code{$GPG_AGENT_INFO}も同期する必要があります。

@node ファイルを展開してdiffを表示するとファイルが消えます
@appendixsubsec ファイルを展開してdiffを表示するとファイルが消えます

これはおそらく、@code{diff.*}
Git変数の変更が原因です。あなたはおそらく@code{magit-git-global-arguments}を何らかの理由で設定しています。よって、あなたはMagit内で@code{magit-git-global-arguments}をカスタマイズしたのを元に戻す(undo)だけです。

@node @code{COMMIT_EDITMSG}バッファのpointが間違っています
@appendixsubsec @code{COMMIT_EDITMSG}バッファのpointが間違っています

Magitも `git-commit`
も、コミットメッセージの書き込みに使用されるバッファ内のポイントをいじらないので、他の何かがわるさをしているに違いありません。

あなたはfile-visitingバッファのポイントを復元するモードをグローバルに有効にしている可能性があります。少し意外かもしれませんが、コミットメッセージを書くと、実際にはファイルを編集していることになります。

したがって、どのパッケージが実行されているかを把握する必要があります。@code{saveplace}と@code{pointback}と@code{session}が候補になる可能性があります。以下のスニペットが役立つかもしれません:

@lisp
(setq session-name-disable-regexp "\\(?:\\`'\\.git/[A-Z_]+\\'\\)")

(with-eval-after-load 'pointback
  (lambda ()
    (when (or git-commit-mode git-rebase-mode)
      (pointback-mode -1))))
@end lisp

@node モード行の情報が常に最新ではない
@appendixsubsec モード行の情報が常に最新ではない

Magitは、モードラインに表示されている@code{Git-master}のようなバージョン管理情報については責任を負いません。「VC」とも呼ばれる組み込みの「バージョン管理」パッケージは、その情報を更新し、より頻繁に更新するように指示できます:

@lisp
(setq auto-revert-check-vc-info t)
@end lisp

しかし、そうするとフォーマンスが悪化します。 より多くの(過度に楽観的な)情報についてはこちらを参照して下さい(@ref{VC Mode
Line,,,emacs,})。

あなたがこの情報をモード行に表示するこをあまり気にしないなら、@emph{不正確な}情報を単にモード行に表示しないことを検討してください。

@lisp
(setq-default mode-line-format
              (delete '(vc-mode vc-mode) mode-line-format))
@end lisp

@node 同じ名前を共有するブランチとタグは何かを壊します
@appendixsubsec 同じ名前を共有するブランチとタグは何かを壊します

または、より一般的には、あいまいなrefnameはSOMETHINGを壊します。

Magitは、refが"refs/heads/"と"refs/tags/"と"refs/remotes/"名前空間全体で明確に名前が付けられていることを前提としています(つまり、これらのプレフィックスが削除されても、すべての名前は一意のままです)。あいまいなrefnameはサポートされていないと見なし、あいまいでない命名スキームを使用することをお勧めします。ただし、refnameがあいまいなリポジトリを使用している場合は、発生した問題を報告してください。簡単な修正があるかどうかを調査できます。

@node 私のGitフックはコマンドラインでは機能しますが、Magit内では機能しません
@appendixsubsec 私のGitフックはコマンドラインでは機能しますが、Magit内では機能しません

Magitが@code{git}を呼び出すと、@code{--literal-pathspecs}を含むいくつかのグローバル引数が追加されます。Magitによって開始された@code{git}プロセスは、その設定を他の@code{git}プロセスに渡します。これは、@code{--literal-pathspecs}引数を使用してサブプロセスを呼び出すのではなく、環境変数@code{GIT_LITERAL_PATHSPECS}を設定することによって行われます。したがって、@code{unset
GIT_LITERAL_PATHSPECS}を使用して、フックスクリプトでこの設定をオーバーライドできます。

@node コマンドラインからコミットする場合、@code{git-commit-mode}は使用されません
@appendixsubsec コマンドラインからコミットする場合、@code{git-commit-mode}は使用されません

これは、@code{git-commit.el}がまだロードされていないか、サーバーがまだ起動されていないためです。Magitからコミットするときは常にこれらの処理が為されています。これを行うにはMagitをロードする必要があり、そのためには@code{git-commit}をロードしてサーバーを開始する必要があります。

あなたがコマンドラインからコミットする場合は、これらのことを自分で処理する必要があります。@code{init.el}ファイルには以下のものが含まれている必要があります:

@lisp
(require 'git-commit)
(server-mode)
@end lisp

あなたは`(require 'git-commit)`の代わりに以下を使用することもできます:

@lisp
(load "/path/to/magit-autoloads.el")
@end lisp

@code{git-commit}をロードすると、Magitの大部分がロードされるため、これを実行することをお勧めします。

@code{(server-mode)}には、あなたが試してみたいバリエーションもいくつかあると思います。作者の私が個人的に使用するものは:

@lisp
(use-package server
  :config (or (server-running-p) (server-mode)))
@end lisp

今やあなたは以下を使用できます:

@example
$ emacs&
$ EDITOR=emacsclient git commit
@end example

けれども以下は使用できません:

@example
$ killall emacs
$ EDITOR="emacsclient --alternate-editor emacs" git commit
@end example

これは実際には@code{emacsclient}ではなく@code{emacs}を使用することになります。この場合でも、コミットメッセージは編集できますが、@code{git-commit-mode}は使用されず、プロセスを終了するには@code{emacs}を終了する必要があります。

これのトートロジーになりますが、@code{emacs}インスタンスが実行されていなくても、@code{emacsclient}を使用して実行中の@code{emacs}インスタンスに接続できるようにする場合は、@code{emacsclient}を直接使用することはできません。

代わりに、以下のようなことを行うスクリプトを作成する必要があります:

(@code{--alternate-editor}を使用せずに)@code{emacsclient}を使用することを試みてください。それが成功した場合は、他に何もしません。それ以外の場合は、@code{emacs
&}を開始(@code{init.el}は@code{server-start}を呼び出す必要があります)し、@code{emacsclient}の使用を再試行します。

@node file-visitingバッファにジャンプすると、ポイントは非表示のテキスト内にあります
@appendixsubsec file-visitingバッファにジャンプすると、ポイントは非表示のテキスト内にあります

これは、ハンクで@code{RET}と入力して、それぞれの位置にあるそれぞれのファイルを訪問したときに発生する可能性があります。この問題の1つの解決策は、@code{global-reveal-mode}を使用することです。ポイント周辺のテキストが常に表示されるようにします。それがあなたの好みに対してあまりにも刺激的である場合は、代わりに@code{magit-diff-visit-file-hook}を使用してテキストを表示することができます。おそらく、@code{reveal-post-command}を使用するか、Orgバッファ@code{org-reveal}を使用します。

@node MS-WindowsからEmacsのTrampモードを使用するとステージできません
@appendixsubsec MS-WindowsからEmacsのTrampモードを使用するとステージできません

Trampを使用してリモートマシンに接続し、ローカルマシンがMS
Windowsを使用している場合、Magitは個々のハンクをステージ(または適用)できない場合があります。

@code{tramp-tests.el}の最後で説明したように、このシナリオでは@code{process-send-eof}に問題があるようです。これについてTrampのメンテナに連絡しました。
今のところ、これは残念ながらそれが機能せず、私たちがそれについて何もできないことを意味します。詳細については、@uref{https://github.com/magit/magit/issues/3624}にコメントしてください。

@node 私はポップアップのデフォルトを保存できなくなりました
@appendixsubsec 私はポップアップのデフォルトを保存できなくなりました

Magitは、トランジェントポップアップメニューを実装するためにMagit-Popupを使用していました。現在は、代わりにTransientを使用しています。これはMagit-Popupの後継です。

以前のMagit-Popupメニューでは、ポップアップバッファで@code{C-c
C-c}を使用して、ユーザー設定を保存することができました(たとえば、コミット用のgpg署名キーの設定)。これによりポップアップは閉じられますが、今後のポップアップのデフォルトとして設定が保存されるのです。

トランジェントメニューに切り替えると、この機能は代わりに@code{C-x
C-s}を介して利用できるようになりました。@code{C-x}プレフィックスには、Transientを使用する場合にも他のオプションがあり、入力すると表示されます。詳細については@uref{https://magit.vc/manual/transient/Saving-Values.html#Saving-Values}を参照してください。

@node Debugging Tools
@chapter Debugging Tools

Magitとその依存関係には、いくつかのデバッグツールが用意されています。問題を報告する前にこれらのツールを使用していただければ幸いです。問題を報告するときは、関連するすべての出力を含めてください。

@table @asis
@item @kbd{M-x magit-version}
@findex magit-version
このコマンドは、現在使用されているMagit、Git、およびEmacsのバージョンをエコー領域に表示します。非インタラクティブでは、これは単にMagitバージョンを返すだけです。

@item @kbd{M-x magit-emacs-Q-command}
@findex magit-emacs-Q-command
このコマンドは、エコー領域にデバッグシェルコマンドを表示し、それをキルリングに追加します。そのコマンドをシェルに貼り付けして実行します。

このシェルコマンドは、@code{magit}とその依存関係のみがロードされた状態で@code{emacs}を開始します。構成も他のインストール済みパッケージもロードされません。これにより、Magitに問題があるのか他の問題にあるのかを簡単に判断できます。

あなたがMagitをそのGitリポジトリから実行する場合は、このコマンドの出力の代わりに@code{make emacs-Q}を使用できるはずです。

@item @kbd{M-x magit-toggle-git-debug}
@findex magit-toggle-git-debug
このコマンドは、追加の git エラーが報告されるかどうかを切り替えます。

Magitは基本的に次の2つの理由のいずれかでgitを呼び出します: 副作用のため、または標準出力を使って何かをするためです。

gitが副作用のために実行されると、エラーメッセージを含むその出力は、@code{$}を使用したときに表示されるプロセスバッファに送られます。

gitの出力が何らかの方法で消費されると、それもこのバッファに挿入するにはコストがかかりすぎますが、このオプションがnil以外で、gitがゼロ以外の終了ステータスで返される場合、少なくともこのバッファにその標準エラーが挿入されます。

これは、デバッグのみを目的としています。 これを永続的に有効にしないでください。パフォーマンスに悪影響を及ぼす可能性があります。 また、git
がゼロ以外の終了ステータスで終了し、エラーメッセージを出力するからといって、それがこと Magit
に関してはエラーであるとは限らないことに注意してください。これが、通常、これらのエラーメッセージを非表示にするもう 1 つの理由です。
エラーメッセージが予期しない動作に関連しているかどうかは、ケースバイケースで判断する必要があります。

@item @kbd{M-x magit-toggle-verbose-refresh}
@findex magit-toggle-verbose-refresh
このコマンドは、Magitがバッファを詳細にリフレッシュするかどうかを切り替えます。これを有効にすると、どのセクションがボトルネックであるかを把握するのに役立ちます。追加の出力は、@code{*Messages*}バッファにあります。

@item @kbd{M-x magit-debug-git-executable}
@findex magit-debug-git-executable
このコマンドは、使用可能で使用されている@code{git}実行可能ファイルに関する情報を含むバッファを表示し、@code{exec-path}の問題を調査するときに役立ちます。

こちらもご覧ください(@ref{Git実行ファイル})。

@item @kbd{M-x with-editor-debug}
@findex with-editor-debug
このコマンドは、使用可能で使用されている@code{emacsclient}実行可能ファイルに関する情報を含むバッファを表示し、Magit(または@code{with-editor})が適切な@code{emacsclient}実行可能ファイルを見つけられない理由を調査するときに役立ちます。

こちらもご覧ください(@ref{Debugging,,,with-editor,})
@end table

@noindent
どうぞこちらもご覧下さい @ref{FAQ}

@node Keystroke Index
@appendix Keystroke Index

@printindex ky

@node Function and Command Index
@appendix Function and Command Index

@printindex fn

@node Variable Index
@appendix Variable Index

@printindex vr

@bye
